/* automatically generated by rust-bindgen */

pub const __LINUX__: u32 = 1;
pub const SIZEOF_VOIDP: u32 = 8;
pub const HAVE_GCC_ATOMICS: u32 = 1;
pub const HAVE_PTHREAD_SPINLOCK: u32 = 1;
pub const HAVE_LIBC: u32 = 1;
pub const HAVE_ALLOCA_H: u32 = 1;
pub const HAVE_SYS_TYPES_H: u32 = 1;
pub const HAVE_STDIO_H: u32 = 1;
pub const STDC_HEADERS: u32 = 1;
pub const HAVE_STDLIB_H: u32 = 1;
pub const HAVE_STDARG_H: u32 = 1;
pub const HAVE_MALLOC_H: u32 = 1;
pub const HAVE_MEMORY_H: u32 = 1;
pub const HAVE_STRING_H: u32 = 1;
pub const HAVE_STRINGS_H: u32 = 1;
pub const HAVE_INTTYPES_H: u32 = 1;
pub const HAVE_STDINT_H: u32 = 1;
pub const HAVE_CTYPE_H: u32 = 1;
pub const HAVE_MATH_H: u32 = 1;
pub const HAVE_ICONV_H: u32 = 1;
pub const HAVE_SIGNAL_H: u32 = 1;
pub const HAVE_LIBUDEV_H: u32 = 1;
pub const HAVE_DBUS_DBUS_H: u32 = 1;
pub const HAVE_MALLOC: u32 = 1;
pub const HAVE_CALLOC: u32 = 1;
pub const HAVE_REALLOC: u32 = 1;
pub const HAVE_FREE: u32 = 1;
pub const HAVE_ALLOCA: u32 = 1;
pub const HAVE_GETENV: u32 = 1;
pub const HAVE_SETENV: u32 = 1;
pub const HAVE_PUTENV: u32 = 1;
pub const HAVE_UNSETENV: u32 = 1;
pub const HAVE_QSORT: u32 = 1;
pub const HAVE_ABS: u32 = 1;
pub const HAVE_BCOPY: u32 = 1;
pub const HAVE_MEMSET: u32 = 1;
pub const HAVE_MEMCPY: u32 = 1;
pub const HAVE_MEMMOVE: u32 = 1;
pub const HAVE_MEMCMP: u32 = 1;
pub const HAVE_STRLEN: u32 = 1;
pub const HAVE_STRDUP: u32 = 1;
pub const HAVE_STRCHR: u32 = 1;
pub const HAVE_STRRCHR: u32 = 1;
pub const HAVE_STRSTR: u32 = 1;
pub const HAVE_STRTOL: u32 = 1;
pub const HAVE_STRTOUL: u32 = 1;
pub const HAVE_STRTOLL: u32 = 1;
pub const HAVE_STRTOULL: u32 = 1;
pub const HAVE_STRTOD: u32 = 1;
pub const HAVE_ATOI: u32 = 1;
pub const HAVE_ATOF: u32 = 1;
pub const HAVE_STRCMP: u32 = 1;
pub const HAVE_STRNCMP: u32 = 1;
pub const HAVE_STRCASECMP: u32 = 1;
pub const HAVE_STRNCASECMP: u32 = 1;
pub const HAVE_VSSCANF: u32 = 1;
pub const HAVE_VSNPRINTF: u32 = 1;
pub const HAVE_ATAN: u32 = 1;
pub const HAVE_ATAN2: u32 = 1;
pub const HAVE_ACOS: u32 = 1;
pub const HAVE_ASIN: u32 = 1;
pub const HAVE_CEIL: u32 = 1;
pub const HAVE_COPYSIGN: u32 = 1;
pub const HAVE_COS: u32 = 1;
pub const HAVE_COSF: u32 = 1;
pub const HAVE_FABS: u32 = 1;
pub const HAVE_FLOOR: u32 = 1;
pub const HAVE_LOG: u32 = 1;
pub const HAVE_POW: u32 = 1;
pub const HAVE_SCALBN: u32 = 1;
pub const HAVE_SIN: u32 = 1;
pub const HAVE_SINF: u32 = 1;
pub const HAVE_SQRT: u32 = 1;
pub const HAVE_FSEEKO: u32 = 1;
pub const HAVE_FSEEKO64: u32 = 1;
pub const HAVE_SIGACTION: u32 = 1;
pub const HAVE_SA_SIGACTION: u32 = 1;
pub const HAVE_SETJMP: u32 = 1;
pub const HAVE_NANOSLEEP: u32 = 1;
pub const HAVE_SYSCONF: u32 = 1;
pub const HAVE_CLOCK_GETTIME: u32 = 1;
pub const HAVE_MPROTECT: u32 = 1;
pub const HAVE_ICONV: u32 = 1;
pub const HAVE_PTHREAD_SETNAME_NP: u32 = 1;
pub const HAVE_SEM_TIMEDWAIT: u32 = 1;
pub const SDL_LOADSO_DISABLED: u32 = 1;
pub const SDL_AUDIO_DRIVER_ALSA: u32 = 1;
pub const SDL_AUDIO_DRIVER_PULSEAUDIO: u32 = 1;
pub const SDL_AUDIO_DRIVER_DISK: u32 = 1;
pub const SDL_AUDIO_DRIVER_DUMMY: u32 = 1;
pub const SDL_AUDIO_DRIVER_OSS: u32 = 1;
pub const SDL_INPUT_LINUXEV: u32 = 1;
pub const SDL_INPUT_LINUXKD: u32 = 1;
pub const SDL_JOYSTICK_LINUX: u32 = 1;
pub const SDL_HAPTIC_LINUX: u32 = 1;
pub const SDL_LOADSO_DLOPEN: u32 = 1;
pub const SDL_THREAD_PTHREAD: u32 = 1;
pub const SDL_THREAD_PTHREAD_RECURSIVE_MUTEX: u32 = 1;
pub const SDL_TIMER_UNIX: u32 = 1;
pub const SDL_VIDEO_DRIVER_DUMMY: u32 = 1;
pub const SDL_VIDEO_DRIVER_WAYLAND: u32 = 1;
pub const SDL_VIDEO_DRIVER_WAYLAND_QT_TOUCH: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XCURSOR: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XINERAMA: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XINPUT2: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XINPUT2_SUPPORTS_MULTITOUCH: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XRANDR: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XSCRNSAVER: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XSHAPE: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XVIDMODE: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_SUPPORTS_GENERIC_EVENTS: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_CONST_PARAM_XDATA32: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_CONST_PARAM_XEXTADDDISPLAY: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_HAS_XKBKEYCODETOKEYSYM: u32 = 1;
pub const SDL_VIDEO_RENDER_OGL: u32 = 1;
pub const SDL_VIDEO_RENDER_OGL_ES2: u32 = 1;
pub const SDL_VIDEO_OPENGL: u32 = 1;
pub const SDL_VIDEO_OPENGL_ES2: u32 = 1;
pub const SDL_VIDEO_OPENGL_EGL: u32 = 1;
pub const SDL_VIDEO_OPENGL_GLX: u32 = 1;
pub const SDL_POWER_LINUX: u32 = 1;
pub const SDL_FILESYSTEM_UNIX: u32 = 1;
pub const SDL_ASSEMBLY_ROUTINES: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 1;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 28;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: u32 = 1;
pub const __PTHREAD_MUTEX_NUSERS_AFTER_KIND: u32 = 0;
pub const __PTHREAD_MUTEX_USE_UNION: u32 = 0;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _ALLOCA_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _INTTYPES_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const PRId8: &'static [u8; 2usize] = b"d\0";
pub const PRId16: &'static [u8; 2usize] = b"d\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIi8: &'static [u8; 2usize] = b"i\0";
pub const PRIi16: &'static [u8; 2usize] = b"i\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIo8: &'static [u8; 2usize] = b"o\0";
pub const PRIo16: &'static [u8; 2usize] = b"o\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIu8: &'static [u8; 2usize] = b"u\0";
pub const PRIu16: &'static [u8; 2usize] = b"u\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIx8: &'static [u8; 2usize] = b"x\0";
pub const PRIx16: &'static [u8; 2usize] = b"x\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIX8: &'static [u8; 2usize] = b"X\0";
pub const PRIX16: &'static [u8; 2usize] = b"X\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const _CTYPE_H: u32 = 1;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const _ICONV_H: u32 = 1;
pub const SDL_ASSERT_LEVEL: u32 = 2;
pub const SDL_NULL_WHILE_LOOP_CONDITION: u32 = 0;
pub const SDL_LIL_ENDIAN: u32 = 1234;
pub const SDL_BIG_ENDIAN: u32 = 4321;
pub const SDL_BYTEORDER: u32 = 1234;
pub const SDL_MUTEX_TIMEDOUT: u32 = 1;
pub const SDL_RWOPS_UNKNOWN: u32 = 0;
pub const SDL_RWOPS_WINFILE: u32 = 1;
pub const SDL_RWOPS_STDFILE: u32 = 2;
pub const SDL_RWOPS_JNIFILE: u32 = 3;
pub const SDL_RWOPS_MEMORY: u32 = 4;
pub const SDL_RWOPS_MEMORY_RO: u32 = 5;
pub const RW_SEEK_SET: u32 = 0;
pub const RW_SEEK_CUR: u32 = 1;
pub const RW_SEEK_END: u32 = 2;
pub const SDL_AUDIO_MASK_BITSIZE: u32 = 255;
pub const SDL_AUDIO_MASK_DATATYPE: u32 = 256;
pub const SDL_AUDIO_MASK_ENDIAN: u32 = 4096;
pub const SDL_AUDIO_MASK_SIGNED: u32 = 32768;
pub const AUDIO_U8: u32 = 8;
pub const AUDIO_S8: u32 = 32776;
pub const AUDIO_U16LSB: u32 = 16;
pub const AUDIO_S16LSB: u32 = 32784;
pub const AUDIO_U16MSB: u32 = 4112;
pub const AUDIO_S16MSB: u32 = 36880;
pub const AUDIO_U16: u32 = 16;
pub const AUDIO_S16: u32 = 32784;
pub const AUDIO_S32LSB: u32 = 32800;
pub const AUDIO_S32MSB: u32 = 36896;
pub const AUDIO_S32: u32 = 32800;
pub const AUDIO_F32LSB: u32 = 33056;
pub const AUDIO_F32MSB: u32 = 37152;
pub const AUDIO_F32: u32 = 33056;
pub const AUDIO_U16SYS: u32 = 16;
pub const AUDIO_S16SYS: u32 = 32784;
pub const AUDIO_S32SYS: u32 = 32800;
pub const AUDIO_F32SYS: u32 = 33056;
pub const SDL_AUDIO_ALLOW_FREQUENCY_CHANGE: u32 = 1;
pub const SDL_AUDIO_ALLOW_FORMAT_CHANGE: u32 = 2;
pub const SDL_AUDIO_ALLOW_CHANNELS_CHANGE: u32 = 4;
pub const SDL_AUDIO_ALLOW_ANY_CHANGE: u32 = 7;
pub const SDL_MIX_MAXVOLUME: u32 = 128;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const SDL_CACHELINE_SIZE: u32 = 128;
pub const SDL_ALPHA_OPAQUE: u32 = 255;
pub const SDL_ALPHA_TRANSPARENT: u32 = 0;
pub const SDL_SWSURFACE: u32 = 0;
pub const SDL_PREALLOC: u32 = 1;
pub const SDL_RLEACCEL: u32 = 2;
pub const SDL_DONTFREE: u32 = 4;
pub const SDL_WINDOWPOS_UNDEFINED_MASK: u32 = 536805376;
pub const SDL_WINDOWPOS_CENTERED_MASK: u32 = 805240832;
pub const SDLK_SCANCODE_MASK: u32 = 1073741824;
pub const SDL_BUTTON_LEFT: u32 = 1;
pub const SDL_BUTTON_MIDDLE: u32 = 2;
pub const SDL_BUTTON_RIGHT: u32 = 3;
pub const SDL_BUTTON_X1: u32 = 4;
pub const SDL_BUTTON_X2: u32 = 5;
pub const SDL_HAT_CENTERED: u32 = 0;
pub const SDL_HAT_UP: u32 = 1;
pub const SDL_HAT_RIGHT: u32 = 2;
pub const SDL_HAT_DOWN: u32 = 4;
pub const SDL_HAT_LEFT: u32 = 8;
pub const SDL_HAT_RIGHTUP: u32 = 3;
pub const SDL_HAT_RIGHTDOWN: u32 = 6;
pub const SDL_HAT_LEFTUP: u32 = 9;
pub const SDL_HAT_LEFTDOWN: u32 = 12;
pub const SDL_RELEASED: u32 = 0;
pub const SDL_PRESSED: u32 = 1;
pub const SDL_TEXTEDITINGEVENT_TEXT_SIZE: u32 = 32;
pub const SDL_TEXTINPUTEVENT_TEXT_SIZE: u32 = 32;
pub const SDL_QUERY: i32 = -1;
pub const SDL_IGNORE: u32 = 0;
pub const SDL_DISABLE: u32 = 0;
pub const SDL_ENABLE: u32 = 1;
pub const SDL_HAPTIC_CONSTANT: u32 = 1;
pub const SDL_HAPTIC_SINE: u32 = 2;
pub const SDL_HAPTIC_LEFTRIGHT: u32 = 4;
pub const SDL_HAPTIC_TRIANGLE: u32 = 8;
pub const SDL_HAPTIC_SAWTOOTHUP: u32 = 16;
pub const SDL_HAPTIC_SAWTOOTHDOWN: u32 = 32;
pub const SDL_HAPTIC_RAMP: u32 = 64;
pub const SDL_HAPTIC_SPRING: u32 = 128;
pub const SDL_HAPTIC_DAMPER: u32 = 256;
pub const SDL_HAPTIC_INERTIA: u32 = 512;
pub const SDL_HAPTIC_FRICTION: u32 = 1024;
pub const SDL_HAPTIC_CUSTOM: u32 = 2048;
pub const SDL_HAPTIC_GAIN: u32 = 4096;
pub const SDL_HAPTIC_AUTOCENTER: u32 = 8192;
pub const SDL_HAPTIC_STATUS: u32 = 16384;
pub const SDL_HAPTIC_PAUSE: u32 = 32768;
pub const SDL_HAPTIC_POLAR: u32 = 0;
pub const SDL_HAPTIC_CARTESIAN: u32 = 1;
pub const SDL_HAPTIC_SPHERICAL: u32 = 2;
pub const SDL_HAPTIC_INFINITY: u32 = 4294967295;
pub const SDL_HINT_FRAMEBUFFER_ACCELERATION: &'static [u8; 29usize] =
    b"SDL_FRAMEBUFFER_ACCELERATION\0";
pub const SDL_HINT_RENDER_DRIVER: &'static [u8; 18usize] = b"SDL_RENDER_DRIVER\0";
pub const SDL_HINT_RENDER_OPENGL_SHADERS: &'static [u8; 26usize] = b"SDL_RENDER_OPENGL_SHADERS\0";
pub const SDL_HINT_RENDER_DIRECT3D_THREADSAFE: &'static [u8; 31usize] =
    b"SDL_RENDER_DIRECT3D_THREADSAFE\0";
pub const SDL_HINT_RENDER_SCALE_QUALITY: &'static [u8; 25usize] = b"SDL_RENDER_SCALE_QUALITY\0";
pub const SDL_HINT_RENDER_VSYNC: &'static [u8; 17usize] = b"SDL_RENDER_VSYNC\0";
pub const SDL_HINT_VIDEO_ALLOW_SCREENSAVER: &'static [u8; 28usize] =
    b"SDL_VIDEO_ALLOW_SCREENSAVER\0";
pub const SDL_HINT_VIDEO_X11_XVIDMODE: &'static [u8; 23usize] = b"SDL_VIDEO_X11_XVIDMODE\0";
pub const SDL_HINT_VIDEO_X11_XINERAMA: &'static [u8; 23usize] = b"SDL_VIDEO_X11_XINERAMA\0";
pub const SDL_HINT_VIDEO_X11_XRANDR: &'static [u8; 21usize] = b"SDL_VIDEO_X11_XRANDR\0";
pub const SDL_HINT_GRAB_KEYBOARD: &'static [u8; 18usize] = b"SDL_GRAB_KEYBOARD\0";
pub const SDL_HINT_MOUSE_RELATIVE_MODE_WARP: &'static [u8; 29usize] =
    b"SDL_MOUSE_RELATIVE_MODE_WARP\0";
pub const SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS: &'static [u8; 33usize] =
    b"SDL_VIDEO_MINIMIZE_ON_FOCUS_LOSS\0";
pub const SDL_HINT_IDLE_TIMER_DISABLED: &'static [u8; 28usize] = b"SDL_IOS_IDLE_TIMER_DISABLED\0";
pub const SDL_HINT_ORIENTATIONS: &'static [u8; 21usize] = b"SDL_IOS_ORIENTATIONS\0";
pub const SDL_HINT_ACCELEROMETER_AS_JOYSTICK: &'static [u8; 30usize] =
    b"SDL_ACCELEROMETER_AS_JOYSTICK\0";
pub const SDL_HINT_XINPUT_ENABLED: &'static [u8; 19usize] = b"SDL_XINPUT_ENABLED\0";
pub const SDL_HINT_GAMECONTROLLERCONFIG: &'static [u8; 25usize] = b"SDL_GAMECONTROLLERCONFIG\0";
pub const SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS: &'static [u8; 37usize] =
    b"SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS\0";
pub const SDL_HINT_ALLOW_TOPMOST: &'static [u8; 18usize] = b"SDL_ALLOW_TOPMOST\0";
pub const SDL_HINT_TIMER_RESOLUTION: &'static [u8; 21usize] = b"SDL_TIMER_RESOLUTION\0";
pub const SDL_HINT_VIDEO_HIGHDPI_DISABLED: &'static [u8; 27usize] = b"SDL_VIDEO_HIGHDPI_DISABLED\0";
pub const SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK: &'static [u8; 39usize] =
    b"SDL_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK\0";
pub const SDL_HINT_VIDEO_WIN_D3DCOMPILER: &'static [u8; 26usize] = b"SDL_VIDEO_WIN_D3DCOMPILER\0";
pub const SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT: &'static [u8; 36usize] =
    b"SDL_VIDEO_WINDOW_SHARE_PIXEL_FORMAT\0";
pub const SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES: &'static [u8; 32usize] =
    b"SDL_VIDEO_MAC_FULLSCREEN_SPACES\0";
pub const SDL_MAX_LOG_MESSAGE: u32 = 4096;
pub const SDL_MAJOR_VERSION: u32 = 2;
pub const SDL_MINOR_VERSION: u32 = 0;
pub const SDL_PATCHLEVEL: u32 = 2;
pub const SDL_INIT_TIMER: u32 = 1;
pub const SDL_INIT_AUDIO: u32 = 16;
pub const SDL_INIT_VIDEO: u32 = 32;
pub const SDL_INIT_JOYSTICK: u32 = 512;
pub const SDL_INIT_HAPTIC: u32 = 4096;
pub const SDL_INIT_GAMECONTROLLER: u32 = 8192;
pub const SDL_INIT_EVENTS: u32 = 16384;
pub const SDL_INIT_NOPARACHUTE: u32 = 1048576;
pub const SDL_INIT_EVERYTHING: u32 = 29233;
pub const XlibSpecificationRelease: u32 = 6;
pub const X_PROTOCOL: u32 = 11;
pub const X_PROTOCOL_REVISION: u32 = 0;
pub const None: u32 = 0;
pub const ParentRelative: u32 = 1;
pub const CopyFromParent: u32 = 0;
pub const PointerWindow: u32 = 0;
pub const InputFocus: u32 = 1;
pub const PointerRoot: u32 = 1;
pub const AnyPropertyType: u32 = 0;
pub const AnyKey: u32 = 0;
pub const AnyButton: u32 = 0;
pub const AllTemporary: u32 = 0;
pub const CurrentTime: u32 = 0;
pub const NoSymbol: u32 = 0;
pub const NoEventMask: u32 = 0;
pub const KeyPressMask: u32 = 1;
pub const KeyReleaseMask: u32 = 2;
pub const ButtonPressMask: u32 = 4;
pub const ButtonReleaseMask: u32 = 8;
pub const EnterWindowMask: u32 = 16;
pub const LeaveWindowMask: u32 = 32;
pub const PointerMotionMask: u32 = 64;
pub const PointerMotionHintMask: u32 = 128;
pub const Button1MotionMask: u32 = 256;
pub const Button2MotionMask: u32 = 512;
pub const Button3MotionMask: u32 = 1024;
pub const Button4MotionMask: u32 = 2048;
pub const Button5MotionMask: u32 = 4096;
pub const ButtonMotionMask: u32 = 8192;
pub const KeymapStateMask: u32 = 16384;
pub const ExposureMask: u32 = 32768;
pub const VisibilityChangeMask: u32 = 65536;
pub const StructureNotifyMask: u32 = 131072;
pub const ResizeRedirectMask: u32 = 262144;
pub const SubstructureNotifyMask: u32 = 524288;
pub const SubstructureRedirectMask: u32 = 1048576;
pub const FocusChangeMask: u32 = 2097152;
pub const PropertyChangeMask: u32 = 4194304;
pub const ColormapChangeMask: u32 = 8388608;
pub const OwnerGrabButtonMask: u32 = 16777216;
pub const KeyPress: u32 = 2;
pub const KeyRelease: u32 = 3;
pub const ButtonPress: u32 = 4;
pub const ButtonRelease: u32 = 5;
pub const MotionNotify: u32 = 6;
pub const EnterNotify: u32 = 7;
pub const LeaveNotify: u32 = 8;
pub const FocusIn: u32 = 9;
pub const FocusOut: u32 = 10;
pub const KeymapNotify: u32 = 11;
pub const Expose: u32 = 12;
pub const GraphicsExpose: u32 = 13;
pub const NoExpose: u32 = 14;
pub const VisibilityNotify: u32 = 15;
pub const CreateNotify: u32 = 16;
pub const DestroyNotify: u32 = 17;
pub const UnmapNotify: u32 = 18;
pub const MapNotify: u32 = 19;
pub const MapRequest: u32 = 20;
pub const ReparentNotify: u32 = 21;
pub const ConfigureNotify: u32 = 22;
pub const ConfigureRequest: u32 = 23;
pub const GravityNotify: u32 = 24;
pub const ResizeRequest: u32 = 25;
pub const CirculateNotify: u32 = 26;
pub const CirculateRequest: u32 = 27;
pub const PropertyNotify: u32 = 28;
pub const SelectionClear: u32 = 29;
pub const SelectionRequest: u32 = 30;
pub const SelectionNotify: u32 = 31;
pub const ColormapNotify: u32 = 32;
pub const ClientMessage: u32 = 33;
pub const MappingNotify: u32 = 34;
pub const GenericEvent: u32 = 35;
pub const LASTEvent: u32 = 36;
pub const ShiftMask: u32 = 1;
pub const LockMask: u32 = 2;
pub const ControlMask: u32 = 4;
pub const Mod1Mask: u32 = 8;
pub const Mod2Mask: u32 = 16;
pub const Mod3Mask: u32 = 32;
pub const Mod4Mask: u32 = 64;
pub const Mod5Mask: u32 = 128;
pub const ShiftMapIndex: u32 = 0;
pub const LockMapIndex: u32 = 1;
pub const ControlMapIndex: u32 = 2;
pub const Mod1MapIndex: u32 = 3;
pub const Mod2MapIndex: u32 = 4;
pub const Mod3MapIndex: u32 = 5;
pub const Mod4MapIndex: u32 = 6;
pub const Mod5MapIndex: u32 = 7;
pub const Button1Mask: u32 = 256;
pub const Button2Mask: u32 = 512;
pub const Button3Mask: u32 = 1024;
pub const Button4Mask: u32 = 2048;
pub const Button5Mask: u32 = 4096;
pub const AnyModifier: u32 = 32768;
pub const Button1: u32 = 1;
pub const Button2: u32 = 2;
pub const Button3: u32 = 3;
pub const Button4: u32 = 4;
pub const Button5: u32 = 5;
pub const NotifyNormal: u32 = 0;
pub const NotifyGrab: u32 = 1;
pub const NotifyUngrab: u32 = 2;
pub const NotifyWhileGrabbed: u32 = 3;
pub const NotifyHint: u32 = 1;
pub const NotifyAncestor: u32 = 0;
pub const NotifyVirtual: u32 = 1;
pub const NotifyInferior: u32 = 2;
pub const NotifyNonlinear: u32 = 3;
pub const NotifyNonlinearVirtual: u32 = 4;
pub const NotifyPointer: u32 = 5;
pub const NotifyPointerRoot: u32 = 6;
pub const NotifyDetailNone: u32 = 7;
pub const VisibilityUnobscured: u32 = 0;
pub const VisibilityPartiallyObscured: u32 = 1;
pub const VisibilityFullyObscured: u32 = 2;
pub const PlaceOnTop: u32 = 0;
pub const PlaceOnBottom: u32 = 1;
pub const FamilyInternet: u32 = 0;
pub const FamilyDECnet: u32 = 1;
pub const FamilyChaos: u32 = 2;
pub const FamilyInternet6: u32 = 6;
pub const FamilyServerInterpreted: u32 = 5;
pub const PropertyNewValue: u32 = 0;
pub const PropertyDelete: u32 = 1;
pub const ColormapUninstalled: u32 = 0;
pub const ColormapInstalled: u32 = 1;
pub const GrabModeSync: u32 = 0;
pub const GrabModeAsync: u32 = 1;
pub const GrabSuccess: u32 = 0;
pub const AlreadyGrabbed: u32 = 1;
pub const GrabInvalidTime: u32 = 2;
pub const GrabNotViewable: u32 = 3;
pub const GrabFrozen: u32 = 4;
pub const AsyncPointer: u32 = 0;
pub const SyncPointer: u32 = 1;
pub const ReplayPointer: u32 = 2;
pub const AsyncKeyboard: u32 = 3;
pub const SyncKeyboard: u32 = 4;
pub const ReplayKeyboard: u32 = 5;
pub const AsyncBoth: u32 = 6;
pub const SyncBoth: u32 = 7;
pub const RevertToParent: u32 = 2;
pub const Success: u32 = 0;
pub const BadRequest: u32 = 1;
pub const BadValue: u32 = 2;
pub const BadWindow: u32 = 3;
pub const BadPixmap: u32 = 4;
pub const BadAtom: u32 = 5;
pub const BadCursor: u32 = 6;
pub const BadFont: u32 = 7;
pub const BadMatch: u32 = 8;
pub const BadDrawable: u32 = 9;
pub const BadAccess: u32 = 10;
pub const BadAlloc: u32 = 11;
pub const BadColor: u32 = 12;
pub const BadGC: u32 = 13;
pub const BadIDChoice: u32 = 14;
pub const BadName: u32 = 15;
pub const BadLength: u32 = 16;
pub const BadImplementation: u32 = 17;
pub const FirstExtensionError: u32 = 128;
pub const LastExtensionError: u32 = 255;
pub const InputOutput: u32 = 1;
pub const InputOnly: u32 = 2;
pub const CWBackPixmap: u32 = 1;
pub const CWBackPixel: u32 = 2;
pub const CWBorderPixmap: u32 = 4;
pub const CWBorderPixel: u32 = 8;
pub const CWBitGravity: u32 = 16;
pub const CWWinGravity: u32 = 32;
pub const CWBackingStore: u32 = 64;
pub const CWBackingPlanes: u32 = 128;
pub const CWBackingPixel: u32 = 256;
pub const CWOverrideRedirect: u32 = 512;
pub const CWSaveUnder: u32 = 1024;
pub const CWEventMask: u32 = 2048;
pub const CWDontPropagate: u32 = 4096;
pub const CWColormap: u32 = 8192;
pub const CWCursor: u32 = 16384;
pub const CWX: u32 = 1;
pub const CWY: u32 = 2;
pub const CWWidth: u32 = 4;
pub const CWHeight: u32 = 8;
pub const CWBorderWidth: u32 = 16;
pub const CWSibling: u32 = 32;
pub const CWStackMode: u32 = 64;
pub const ForgetGravity: u32 = 0;
pub const NorthWestGravity: u32 = 1;
pub const NorthGravity: u32 = 2;
pub const NorthEastGravity: u32 = 3;
pub const WestGravity: u32 = 4;
pub const CenterGravity: u32 = 5;
pub const EastGravity: u32 = 6;
pub const SouthWestGravity: u32 = 7;
pub const SouthGravity: u32 = 8;
pub const SouthEastGravity: u32 = 9;
pub const StaticGravity: u32 = 10;
pub const UnmapGravity: u32 = 0;
pub const NotUseful: u32 = 0;
pub const WhenMapped: u32 = 1;
pub const Always: u32 = 2;
pub const IsUnmapped: u32 = 0;
pub const IsUnviewable: u32 = 1;
pub const IsViewable: u32 = 2;
pub const SetModeInsert: u32 = 0;
pub const SetModeDelete: u32 = 1;
pub const DestroyAll: u32 = 0;
pub const RetainPermanent: u32 = 1;
pub const RetainTemporary: u32 = 2;
pub const Above: u32 = 0;
pub const Below: u32 = 1;
pub const TopIf: u32 = 2;
pub const BottomIf: u32 = 3;
pub const Opposite: u32 = 4;
pub const RaiseLowest: u32 = 0;
pub const LowerHighest: u32 = 1;
pub const PropModeReplace: u32 = 0;
pub const PropModePrepend: u32 = 1;
pub const PropModeAppend: u32 = 2;
pub const GXclear: u32 = 0;
pub const GXand: u32 = 1;
pub const GXandReverse: u32 = 2;
pub const GXcopy: u32 = 3;
pub const GXandInverted: u32 = 4;
pub const GXnoop: u32 = 5;
pub const GXxor: u32 = 6;
pub const GXor: u32 = 7;
pub const GXnor: u32 = 8;
pub const GXequiv: u32 = 9;
pub const GXinvert: u32 = 10;
pub const GXorReverse: u32 = 11;
pub const GXcopyInverted: u32 = 12;
pub const GXorInverted: u32 = 13;
pub const GXnand: u32 = 14;
pub const GXset: u32 = 15;
pub const LineSolid: u32 = 0;
pub const LineOnOffDash: u32 = 1;
pub const LineDoubleDash: u32 = 2;
pub const CapNotLast: u32 = 0;
pub const CapButt: u32 = 1;
pub const CapRound: u32 = 2;
pub const CapProjecting: u32 = 3;
pub const JoinMiter: u32 = 0;
pub const JoinRound: u32 = 1;
pub const JoinBevel: u32 = 2;
pub const FillSolid: u32 = 0;
pub const FillTiled: u32 = 1;
pub const FillStippled: u32 = 2;
pub const FillOpaqueStippled: u32 = 3;
pub const EvenOddRule: u32 = 0;
pub const WindingRule: u32 = 1;
pub const ClipByChildren: u32 = 0;
pub const IncludeInferiors: u32 = 1;
pub const Unsorted: u32 = 0;
pub const YSorted: u32 = 1;
pub const YXSorted: u32 = 2;
pub const YXBanded: u32 = 3;
pub const CoordModeOrigin: u32 = 0;
pub const CoordModePrevious: u32 = 1;
pub const Complex: u32 = 0;
pub const Nonconvex: u32 = 1;
pub const Convex: u32 = 2;
pub const ArcChord: u32 = 0;
pub const ArcPieSlice: u32 = 1;
pub const GCFunction: u32 = 1;
pub const GCPlaneMask: u32 = 2;
pub const GCForeground: u32 = 4;
pub const GCBackground: u32 = 8;
pub const GCLineWidth: u32 = 16;
pub const GCLineStyle: u32 = 32;
pub const GCCapStyle: u32 = 64;
pub const GCJoinStyle: u32 = 128;
pub const GCFillStyle: u32 = 256;
pub const GCFillRule: u32 = 512;
pub const GCTile: u32 = 1024;
pub const GCStipple: u32 = 2048;
pub const GCTileStipXOrigin: u32 = 4096;
pub const GCTileStipYOrigin: u32 = 8192;
pub const GCFont: u32 = 16384;
pub const GCSubwindowMode: u32 = 32768;
pub const GCGraphicsExposures: u32 = 65536;
pub const GCClipXOrigin: u32 = 131072;
pub const GCClipYOrigin: u32 = 262144;
pub const GCClipMask: u32 = 524288;
pub const GCDashOffset: u32 = 1048576;
pub const GCDashList: u32 = 2097152;
pub const GCArcMode: u32 = 4194304;
pub const GCLastBit: u32 = 22;
pub const FontLeftToRight: u32 = 0;
pub const FontRightToLeft: u32 = 1;
pub const FontChange: u32 = 255;
pub const XYBitmap: u32 = 0;
pub const XYPixmap: u32 = 1;
pub const ZPixmap: u32 = 2;
pub const AllocNone: u32 = 0;
pub const AllocAll: u32 = 1;
pub const DoRed: u32 = 1;
pub const DoGreen: u32 = 2;
pub const DoBlue: u32 = 4;
pub const CursorShape: u32 = 0;
pub const TileShape: u32 = 1;
pub const StippleShape: u32 = 2;
pub const AutoRepeatModeOff: u32 = 0;
pub const AutoRepeatModeOn: u32 = 1;
pub const AutoRepeatModeDefault: u32 = 2;
pub const LedModeOff: u32 = 0;
pub const LedModeOn: u32 = 1;
pub const KBKeyClickPercent: u32 = 1;
pub const KBBellPercent: u32 = 2;
pub const KBBellPitch: u32 = 4;
pub const KBBellDuration: u32 = 8;
pub const KBLed: u32 = 16;
pub const KBLedMode: u32 = 32;
pub const KBKey: u32 = 64;
pub const KBAutoRepeatMode: u32 = 128;
pub const MappingSuccess: u32 = 0;
pub const MappingBusy: u32 = 1;
pub const MappingFailed: u32 = 2;
pub const MappingModifier: u32 = 0;
pub const MappingKeyboard: u32 = 1;
pub const MappingPointer: u32 = 2;
pub const DontPreferBlanking: u32 = 0;
pub const PreferBlanking: u32 = 1;
pub const DefaultBlanking: u32 = 2;
pub const DisableScreenSaver: u32 = 0;
pub const DisableScreenInterval: u32 = 0;
pub const DontAllowExposures: u32 = 0;
pub const AllowExposures: u32 = 1;
pub const DefaultExposures: u32 = 2;
pub const ScreenSaverReset: u32 = 0;
pub const ScreenSaverActive: u32 = 1;
pub const HostInsert: u32 = 0;
pub const HostDelete: u32 = 1;
pub const EnableAccess: u32 = 1;
pub const DisableAccess: u32 = 0;
pub const StaticGray: u32 = 0;
pub const GrayScale: u32 = 1;
pub const StaticColor: u32 = 2;
pub const PseudoColor: u32 = 3;
pub const TrueColor: u32 = 4;
pub const DirectColor: u32 = 5;
pub const LSBFirst: u32 = 0;
pub const MSBFirst: u32 = 1;
pub const NeedFunctionPrototypes: u32 = 1;
pub const NeedVarargsPrototypes: u32 = 1;
pub const NeedNestedPrototypes: u32 = 1;
pub const FUNCPROTO: u32 = 15;
pub const NeedWidePrototypes: u32 = 0;
pub const X_HAVE_UTF8_STRING: u32 = 1;
pub const True: u32 = 1;
pub const False: u32 = 0;
pub const QueuedAlready: u32 = 0;
pub const QueuedAfterReading: u32 = 1;
pub const QueuedAfterFlush: u32 = 2;
pub const XNRequiredCharSet: &'static [u8; 16usize] = b"requiredCharSet\0";
pub const XNQueryOrientation: &'static [u8; 17usize] = b"queryOrientation\0";
pub const XNBaseFontName: &'static [u8; 13usize] = b"baseFontName\0";
pub const XNOMAutomatic: &'static [u8; 12usize] = b"omAutomatic\0";
pub const XNMissingCharSet: &'static [u8; 15usize] = b"missingCharSet\0";
pub const XNDefaultString: &'static [u8; 14usize] = b"defaultString\0";
pub const XNOrientation: &'static [u8; 12usize] = b"orientation\0";
pub const XNDirectionalDependentDrawing: &'static [u8; 28usize] = b"directionalDependentDrawing\0";
pub const XNContextualDrawing: &'static [u8; 18usize] = b"contextualDrawing\0";
pub const XNFontInfo: &'static [u8; 9usize] = b"fontInfo\0";
pub const XIMPreeditArea: u32 = 1;
pub const XIMPreeditCallbacks: u32 = 2;
pub const XIMPreeditPosition: u32 = 4;
pub const XIMPreeditNothing: u32 = 8;
pub const XIMPreeditNone: u32 = 16;
pub const XIMStatusArea: u32 = 256;
pub const XIMStatusCallbacks: u32 = 512;
pub const XIMStatusNothing: u32 = 1024;
pub const XIMStatusNone: u32 = 2048;
pub const XNVaNestedList: &'static [u8; 15usize] = b"XNVaNestedList\0";
pub const XNQueryInputStyle: &'static [u8; 16usize] = b"queryInputStyle\0";
pub const XNClientWindow: &'static [u8; 13usize] = b"clientWindow\0";
pub const XNInputStyle: &'static [u8; 11usize] = b"inputStyle\0";
pub const XNFocusWindow: &'static [u8; 12usize] = b"focusWindow\0";
pub const XNResourceName: &'static [u8; 13usize] = b"resourceName\0";
pub const XNResourceClass: &'static [u8; 14usize] = b"resourceClass\0";
pub const XNGeometryCallback: &'static [u8; 17usize] = b"geometryCallback\0";
pub const XNDestroyCallback: &'static [u8; 16usize] = b"destroyCallback\0";
pub const XNFilterEvents: &'static [u8; 13usize] = b"filterEvents\0";
pub const XNPreeditStartCallback: &'static [u8; 21usize] = b"preeditStartCallback\0";
pub const XNPreeditDoneCallback: &'static [u8; 20usize] = b"preeditDoneCallback\0";
pub const XNPreeditDrawCallback: &'static [u8; 20usize] = b"preeditDrawCallback\0";
pub const XNPreeditCaretCallback: &'static [u8; 21usize] = b"preeditCaretCallback\0";
pub const XNPreeditStateNotifyCallback: &'static [u8; 27usize] = b"preeditStateNotifyCallback\0";
pub const XNPreeditAttributes: &'static [u8; 18usize] = b"preeditAttributes\0";
pub const XNStatusStartCallback: &'static [u8; 20usize] = b"statusStartCallback\0";
pub const XNStatusDoneCallback: &'static [u8; 19usize] = b"statusDoneCallback\0";
pub const XNStatusDrawCallback: &'static [u8; 19usize] = b"statusDrawCallback\0";
pub const XNStatusAttributes: &'static [u8; 17usize] = b"statusAttributes\0";
pub const XNArea: &'static [u8; 5usize] = b"area\0";
pub const XNAreaNeeded: &'static [u8; 11usize] = b"areaNeeded\0";
pub const XNSpotLocation: &'static [u8; 13usize] = b"spotLocation\0";
pub const XNColormap: &'static [u8; 9usize] = b"colorMap\0";
pub const XNStdColormap: &'static [u8; 12usize] = b"stdColorMap\0";
pub const XNForeground: &'static [u8; 11usize] = b"foreground\0";
pub const XNBackground: &'static [u8; 11usize] = b"background\0";
pub const XNBackgroundPixmap: &'static [u8; 17usize] = b"backgroundPixmap\0";
pub const XNFontSet: &'static [u8; 8usize] = b"fontSet\0";
pub const XNLineSpace: &'static [u8; 10usize] = b"lineSpace\0";
pub const XNCursor: &'static [u8; 7usize] = b"cursor\0";
pub const XNQueryIMValuesList: &'static [u8; 18usize] = b"queryIMValuesList\0";
pub const XNQueryICValuesList: &'static [u8; 18usize] = b"queryICValuesList\0";
pub const XNVisiblePosition: &'static [u8; 16usize] = b"visiblePosition\0";
pub const XNR6PreeditCallback: &'static [u8; 18usize] = b"r6PreeditCallback\0";
pub const XNStringConversionCallback: &'static [u8; 25usize] = b"stringConversionCallback\0";
pub const XNStringConversion: &'static [u8; 17usize] = b"stringConversion\0";
pub const XNResetState: &'static [u8; 11usize] = b"resetState\0";
pub const XNHotKey: &'static [u8; 7usize] = b"hotKey\0";
pub const XNHotKeyState: &'static [u8; 12usize] = b"hotKeyState\0";
pub const XNPreeditState: &'static [u8; 13usize] = b"preeditState\0";
pub const XNSeparatorofNestedList: &'static [u8; 22usize] = b"separatorofNestedList\0";
pub const XBufferOverflow: i32 = -1;
pub const XLookupNone: u32 = 1;
pub const XLookupChars: u32 = 2;
pub const XLookupKeySym: u32 = 3;
pub const XLookupBoth: u32 = 4;
pub const XIMReverse: u32 = 1;
pub const XIMUnderline: u32 = 2;
pub const XIMHighlight: u32 = 4;
pub const XIMPrimary: u32 = 32;
pub const XIMSecondary: u32 = 64;
pub const XIMTertiary: u32 = 128;
pub const XIMVisibleToForward: u32 = 256;
pub const XIMVisibleToBackword: u32 = 512;
pub const XIMVisibleToCenter: u32 = 1024;
pub const XIMPreeditUnKnown: u32 = 0;
pub const XIMPreeditEnable: u32 = 1;
pub const XIMPreeditDisable: u32 = 2;
pub const XIMInitialState: u32 = 1;
pub const XIMPreserveState: u32 = 2;
pub const XIMStringConversionLeftEdge: u32 = 1;
pub const XIMStringConversionRightEdge: u32 = 2;
pub const XIMStringConversionTopEdge: u32 = 4;
pub const XIMStringConversionBottomEdge: u32 = 8;
pub const XIMStringConversionConcealed: u32 = 16;
pub const XIMStringConversionWrapped: u32 = 32;
pub const XIMStringConversionBuffer: u32 = 1;
pub const XIMStringConversionLine: u32 = 2;
pub const XIMStringConversionWord: u32 = 3;
pub const XIMStringConversionChar: u32 = 4;
pub const XIMStringConversionSubstitution: u32 = 1;
pub const XIMStringConversionRetrieval: u32 = 2;
pub const XIMHotKeyStateON: u32 = 1;
pub const XIMHotKeyStateOFF: u32 = 2;
pub const XATOM_H: u32 = 1;
extern "C" {
    ///  \brief Gets the name of the platform.
    pub fn SDL_GetPlatform() -> *const ::std::os::raw::c_char;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
}
pub type fpos_t = __fpos_t;
extern "C" {
    #[link_name = "\u{1}stdin"]
    pub static mut stdin: *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}stdout"]
    pub static mut stdout: *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}stderr"]
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gets(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __s: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum idtype_t {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2,
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = f64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub const _ISupper: _bindgen_ty_1 = _bindgen_ty_1::_ISupper;
pub const _ISlower: _bindgen_ty_1 = _bindgen_ty_1::_ISlower;
pub const _ISalpha: _bindgen_ty_1 = _bindgen_ty_1::_ISalpha;
pub const _ISdigit: _bindgen_ty_1 = _bindgen_ty_1::_ISdigit;
pub const _ISxdigit: _bindgen_ty_1 = _bindgen_ty_1::_ISxdigit;
pub const _ISspace: _bindgen_ty_1 = _bindgen_ty_1::_ISspace;
pub const _ISprint: _bindgen_ty_1 = _bindgen_ty_1::_ISprint;
pub const _ISgraph: _bindgen_ty_1 = _bindgen_ty_1::_ISgraph;
pub const _ISblank: _bindgen_ty_1 = _bindgen_ty_1::_ISblank;
pub const _IScntrl: _bindgen_ty_1 = _bindgen_ty_1::_IScntrl;
pub const _ISpunct: _bindgen_ty_1 = _bindgen_ty_1::_ISpunct;
pub const _ISalnum: _bindgen_ty_1 = _bindgen_ty_1::_ISalnum;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8,
}
extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinfl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn expl(__x: f64) -> f64;
}
extern "C" {
    pub fn __expl(__x: f64) -> f64;
}
extern "C" {
    pub fn frexpl(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexpl(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexpl(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexpl(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn logl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logl(__x: f64) -> f64;
}
extern "C" {
    pub fn log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn __floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinfl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn __significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnanl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgammal_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbnl(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbnl(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogbl(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnl(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalblnl(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn __roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn __truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn remquol(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquol(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrintl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}signgam"]
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: _bindgen_ty_2 = _bindgen_ty_2::FP_NAN;
pub const FP_INFINITE: _bindgen_ty_2 = _bindgen_ty_2::FP_INFINITE;
pub const FP_ZERO: _bindgen_ty_2 = _bindgen_ty_2::FP_ZERO;
pub const FP_SUBNORMAL: _bindgen_ty_2 = _bindgen_ty_2::FP_SUBNORMAL;
pub const FP_NORMAL: _bindgen_ty_2 = _bindgen_ty_2::FP_NORMAL;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4,
}
pub type iconv_t = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn iconv_open(
        __tocode: *const ::std::os::raw::c_char,
        __fromcode: *const ::std::os::raw::c_char,
    ) -> iconv_t;
}
extern "C" {
    pub fn iconv(
        __cd: iconv_t,
        __inbuf: *mut *mut ::std::os::raw::c_char,
        __inbytesleft: *mut usize,
        __outbuf: *mut *mut ::std::os::raw::c_char,
        __outbytesleft: *mut usize,
    ) -> usize;
}
extern "C" {
    pub fn iconv_close(__cd: iconv_t) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_bool {
    SDL_FALSE = 0,
    SDL_TRUE = 1,
}
/// \brief A signed 8-bit integer type.
pub type Sint8 = i8;
/// \brief An unsigned 8-bit integer type.
pub type Uint8 = u8;
/// \brief A signed 16-bit integer type.
pub type Sint16 = i16;
/// \brief An unsigned 16-bit integer type.
pub type Uint16 = u16;
/// \brief A signed 32-bit integer type.
pub type Sint32 = i32;
/// \brief An unsigned 32-bit integer type.
pub type Uint32 = u32;
/// \brief A signed 64-bit integer type.
pub type Sint64 = i64;
/// \brief An unsigned 64-bit integer type.
pub type Uint64 = u64;
pub type SDL_dummy_uint8 = [::std::os::raw::c_int; 1usize];
pub type SDL_dummy_sint8 = [::std::os::raw::c_int; 1usize];
pub type SDL_dummy_uint16 = [::std::os::raw::c_int; 1usize];
pub type SDL_dummy_sint16 = [::std::os::raw::c_int; 1usize];
pub type SDL_dummy_uint32 = [::std::os::raw::c_int; 1usize];
pub type SDL_dummy_sint32 = [::std::os::raw::c_int; 1usize];
pub type SDL_dummy_uint64 = [::std::os::raw::c_int; 1usize];
pub type SDL_dummy_sint64 = [::std::os::raw::c_int; 1usize];
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_DUMMY_ENUM {
    DUMMY_ENUM_VALUE = 0,
}
pub type SDL_dummy_enum = [::std::os::raw::c_int; 1usize];
extern "C" {
    pub fn SDL_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_calloc(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_realloc(
        mem: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_free(mem: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn SDL_getenv(name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_setenv(
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_qsort(
        base: *mut ::std::os::raw::c_void,
        nmemb: usize,
        size: usize,
        compare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn SDL_abs(x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_isdigit(x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_isspace(x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_toupper(x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_tolower(x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_memset(
        dst: *mut ::std::os::raw::c_void,
        c: ::std::os::raw::c_int,
        len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_memcpy(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_memmove(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_memcmp(
        s1: *const ::std::os::raw::c_void,
        s2: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_wcslen(wstr: *const wchar_t) -> usize;
}
extern "C" {
    pub fn SDL_wcslcpy(dst: *mut wchar_t, src: *const wchar_t, maxlen: usize) -> usize;
}
extern "C" {
    pub fn SDL_wcslcat(dst: *mut wchar_t, src: *const wchar_t, maxlen: usize) -> usize;
}
extern "C" {
    pub fn SDL_strlen(str: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn SDL_strlcpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        maxlen: usize,
    ) -> usize;
}
extern "C" {
    pub fn SDL_utf8strlcpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dst_bytes: usize,
    ) -> usize;
}
extern "C" {
    pub fn SDL_strlcat(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        maxlen: usize,
    ) -> usize;
}
extern "C" {
    pub fn SDL_strdup(str: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_strrev(str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_strupr(str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_strlwr(str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_strchr(
        str: *const ::std::os::raw::c_char,
        c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_strrchr(
        str: *const ::std::os::raw::c_char,
        c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_strstr(
        haystack: *const ::std::os::raw::c_char,
        needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_itoa(
        value: ::std::os::raw::c_int,
        str: *mut ::std::os::raw::c_char,
        radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_uitoa(
        value: ::std::os::raw::c_uint,
        str: *mut ::std::os::raw::c_char,
        radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_ltoa(
        value: ::std::os::raw::c_long,
        str: *mut ::std::os::raw::c_char,
        radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_ultoa(
        value: ::std::os::raw::c_ulong,
        str: *mut ::std::os::raw::c_char,
        radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_lltoa(
        value: Sint64,
        str: *mut ::std::os::raw::c_char,
        radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_ulltoa(
        value: Uint64,
        str: *mut ::std::os::raw::c_char,
        radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_atoi(str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_atof(str: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn SDL_strtol(
        str: *const ::std::os::raw::c_char,
        endp: *mut *mut ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SDL_strtoul(
        str: *const ::std::os::raw::c_char,
        endp: *mut *mut ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn SDL_strtoll(
        str: *const ::std::os::raw::c_char,
        endp: *mut *mut ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> Sint64;
}
extern "C" {
    pub fn SDL_strtoull(
        str: *const ::std::os::raw::c_char,
        endp: *mut *mut ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> Uint64;
}
extern "C" {
    pub fn SDL_strtod(
        str: *const ::std::os::raw::c_char,
        endp: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn SDL_strcmp(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_strncmp(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
        maxlen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_strcasecmp(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_strncasecmp(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_sscanf(
        text: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_vsscanf(
        text: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_snprintf(
        text: *mut ::std::os::raw::c_char,
        maxlen: usize,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_vsnprintf(
        text: *mut ::std::os::raw::c_char,
        maxlen: usize,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_acos(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_asin(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_atan(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_atan2(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn SDL_ceil(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_copysign(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn SDL_cos(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_cosf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_fabs(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_floor(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_log(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_pow(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn SDL_scalbn(x: f64, n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn SDL_sin(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_sinf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_sqrt(x: f64) -> f64;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SDL_iconv_t {
    _unused: [u8; 0],
}
pub type SDL_iconv_t = *mut _SDL_iconv_t;
extern "C" {
    pub fn SDL_iconv_open(
        tocode: *const ::std::os::raw::c_char,
        fromcode: *const ::std::os::raw::c_char,
    ) -> SDL_iconv_t;
}
extern "C" {
    pub fn SDL_iconv_close(cd: SDL_iconv_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_iconv(
        cd: SDL_iconv_t,
        inbuf: *mut *const ::std::os::raw::c_char,
        inbytesleft: *mut usize,
        outbuf: *mut *mut ::std::os::raw::c_char,
        outbytesleft: *mut usize,
    ) -> usize;
}
extern "C" {
    ///  This function converts a string between encodings in one pass, returning a
    ///  string that must be freed with SDL_free() or NULL on error.
    pub fn SDL_iconv_string(
        tocode: *const ::std::os::raw::c_char,
        fromcode: *const ::std::os::raw::c_char,
        inbuf: *const ::std::os::raw::c_char,
        inbytesleft: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    ///  The prototype for the application's main() function
    pub fn SDL_main(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  This is called by the real SDL main function to let the rest of the
    ///  library know that initialization was done properly.
    ///
    ///  Calling this yourself without knowing what you're doing can cause
    ///  crashes and hard to diagnose problems with your application.
    pub fn SDL_SetMainReady();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_assert_state {
    ///< Retry the assert immediately.
    SDL_ASSERTION_RETRY = 0,
    ///< Make the debugger trigger a breakpoint.
    SDL_ASSERTION_BREAK = 1,
    ///< Terminate the program.
    SDL_ASSERTION_ABORT = 2,
    ///< Ignore the assert.
    SDL_ASSERTION_IGNORE = 3,
    ///< Ignore the assert from now on.
    SDL_ASSERTION_ALWAYS_IGNORE = 4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_assert_data {
    pub always_ignore: ::std::os::raw::c_int,
    pub trigger_count: ::std::os::raw::c_uint,
    pub condition: *const ::std::os::raw::c_char,
    pub filename: *const ::std::os::raw::c_char,
    pub linenum: ::std::os::raw::c_int,
    pub function: *const ::std::os::raw::c_char,
    pub next: *const SDL_assert_data,
}
#[test]
fn bindgen_test_layout_SDL_assert_data() {
    assert_eq!(
        ::std::mem::size_of::<SDL_assert_data>(),
        48usize,
        concat!("Size of: ", stringify!(SDL_assert_data))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_assert_data>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_assert_data))
    );
}
extern "C" {
    pub fn SDL_ReportAssertion(
        arg1: *mut SDL_assert_data,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
    ) -> SDL_assert_state;
}
pub type SDL_AssertionHandler = ::std::option::Option<
    unsafe extern "C" fn(
        data: *const SDL_assert_data,
        userdata: *mut ::std::os::raw::c_void,
    ) -> SDL_assert_state,
>;
extern "C" {
    ///  \brief Set an application-defined assertion handler.
    ///
    ///  This allows an app to show its own assertion UI and/or force the
    ///  response to an assertion failure. If the app doesn't provide this, SDL
    ///  will try to do the right thing, popping up a system-specific GUI dialog,
    ///  and probably minimizing any fullscreen windows.
    ///
    ///  This callback may fire from any thread, but it runs wrapped in a mutex, so
    ///  it will only fire from one thread at a time.
    ///
    ///  Setting the callback to NULL restores SDL's original internal handler.
    ///
    ///  This callback is NOT reset to SDL's internal handler upon SDL_Quit()!
    ///
    ///  \return SDL_assert_state value of how to handle the assertion failure.
    ///
    ///  \param handler Callback function, called when an assertion fails.
    ///  \param userdata A pointer passed to the callback as-is.
    pub fn SDL_SetAssertionHandler(
        handler: SDL_AssertionHandler,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    ///  \brief Get the default assertion handler.
    ///
    ///  This returns the function pointer that is called by default when an
    ///   assertion is triggered. This is an internal function provided by SDL,
    ///   that is used for assertions when SDL_SetAssertionHandler() hasn't been
    ///   used to provide a different function.
    ///
    ///  \return The default SDL_AssertionHandler that is called when an assert triggers.
    pub fn SDL_GetDefaultAssertionHandler() -> SDL_AssertionHandler;
}
extern "C" {
    ///  \brief Get the current assertion handler.
    ///
    ///  This returns the function pointer that is called when an assertion is
    ///   triggered. This is either the value last passed to
    ///   SDL_SetAssertionHandler(), or if no application-specified function is
    ///   set, is equivalent to calling SDL_GetDefaultAssertionHandler().
    ///
    ///   \param puserdata Pointer to a void*, which will store the "userdata"
    ///                    pointer that was passed to SDL_SetAssertionHandler().
    ///                    This value will always be NULL for the default handler.
    ///                    If you don't care about this data, it is safe to pass
    ///                    a NULL pointer to this function to ignore it.
    ///  \return The SDL_AssertionHandler that is called when an assert triggers.
    pub fn SDL_GetAssertionHandler(
        puserdata: *mut *mut ::std::os::raw::c_void,
    ) -> SDL_AssertionHandler;
}
extern "C" {
    ///  \brief Get a list of all assertion failures.
    ///
    ///  Get all assertions triggered since last call to SDL_ResetAssertionReport(),
    ///  or the start of the program.
    ///
    ///  The proper way to examine this data looks something like this:
    ///
    ///  <code>
    ///  const SDL_assert_data *item = SDL_GetAssertionReport();
    ///  while (item) {
    ///      printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\n",
    ///             item->condition, item->function, item->filename,
    ///             item->linenum, item->trigger_count,
    ///             item->always_ignore ? "yes" : "no");
    ///      item = item->next;
    ///  }
    ///  </code>
    ///
    ///  \return List of all assertions.
    ///  \sa SDL_ResetAssertionReport
    pub fn SDL_GetAssertionReport() -> *const SDL_assert_data;
}
extern "C" {
    ///  \brief Reset the list of all assertion failures.
    ///
    ///  Reset list of all assertions triggered.
    ///
    ///  \sa SDL_GetAssertionReport
    pub fn SDL_ResetAssertionReport();
}
pub type SDL_SpinLock = ::std::os::raw::c_int;
extern "C" {
    /// \brief Try to lock a spin lock by setting it to a non-zero value.
    ///
    /// \param lock Points to the lock.
    ///
    /// \return SDL_TRUE if the lock succeeded, SDL_FALSE if the lock is already held.
    pub fn SDL_AtomicTryLock(lock: *mut SDL_SpinLock) -> SDL_bool;
}
extern "C" {
    /// \brief Lock a spin lock by setting it to a non-zero value.
    ///
    /// \param lock Points to the lock.
    pub fn SDL_AtomicLock(lock: *mut SDL_SpinLock);
}
extern "C" {
    /// \brief Unlock a spin lock by setting it to 0. Always returns immediately
    ///
    /// \param lock Points to the lock.
    pub fn SDL_AtomicUnlock(lock: *mut SDL_SpinLock);
}
/// \brief A type representing an atomic integer value.  It is a struct
///        so people don't accidentally use numeric operations on it.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_atomic_t {
    pub value: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_atomic_t() {
    assert_eq!(
        ::std::mem::size_of::<SDL_atomic_t>(),
        4usize,
        concat!("Size of: ", stringify!(SDL_atomic_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_atomic_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_atomic_t))
    );
}
extern "C" {
    /// \brief Set an atomic variable to a new value if it is currently an old value.
    ///
    /// \return SDL_TRUE if the atomic variable was set, SDL_FALSE otherwise.
    ///
    /// \note If you don't know what this function is for, you shouldn't use it!
    pub fn SDL_AtomicCAS(
        a: *mut SDL_atomic_t,
        oldval: ::std::os::raw::c_int,
        newval: ::std::os::raw::c_int,
    ) -> SDL_bool;
}
extern "C" {
    /// \brief Set an atomic variable to a value.
    ///
    /// \return The previous value of the atomic variable.
    pub fn SDL_AtomicSet(a: *mut SDL_atomic_t, v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the value of an atomic variable
    pub fn SDL_AtomicGet(a: *mut SDL_atomic_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Add to an atomic variable.
    ///
    /// \return The previous value of the atomic variable.
    ///
    /// \note This same style can be used for any number operation
    pub fn SDL_AtomicAdd(a: *mut SDL_atomic_t, v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Set a pointer to a new value if it is currently an old value.
    ///
    /// \return SDL_TRUE if the pointer was set, SDL_FALSE otherwise.
    ///
    /// \note If you don't know what this function is for, you shouldn't use it!
    pub fn SDL_AtomicCASPtr(
        a: *mut *mut ::std::os::raw::c_void,
        oldval: *mut ::std::os::raw::c_void,
        newval: *mut ::std::os::raw::c_void,
    ) -> SDL_bool;
}
extern "C" {
    /// \brief Set a pointer to a value atomically.
    ///
    /// \return The previous value of the pointer.
    pub fn SDL_AtomicSetPtr(
        a: *mut *mut ::std::os::raw::c_void,
        v: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// \brief Get the value of a pointer atomically.
    pub fn SDL_AtomicGetPtr(a: *mut *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_SetError(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_GetError() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_ClearError();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_errorcode {
    SDL_ENOMEM = 0,
    SDL_EFREAD = 1,
    SDL_EFWRITE = 2,
    SDL_EFSEEK = 3,
    SDL_UNSUPPORTED = 4,
    SDL_LASTERROR = 5,
}
extern "C" {
    pub fn SDL_Error(code: SDL_errorcode) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_mutex {
    _unused: [u8; 0],
}
extern "C" {
    ///  Create a mutex, initialized unlocked.
    pub fn SDL_CreateMutex() -> *mut SDL_mutex;
}
extern "C" {
    pub fn SDL_LockMutex(mutex: *mut SDL_mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Try to lock the mutex
    ///
    ///  \return 0, SDL_MUTEX_TIMEDOUT, or -1 on error
    pub fn SDL_TryLockMutex(mutex: *mut SDL_mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_UnlockMutex(mutex: *mut SDL_mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Destroy a mutex.
    pub fn SDL_DestroyMutex(mutex: *mut SDL_mutex);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_semaphore {
    _unused: [u8; 0],
}
pub type SDL_sem = SDL_semaphore;
extern "C" {
    ///  Create a semaphore, initialized with value, returns NULL on failure.
    pub fn SDL_CreateSemaphore(initial_value: Uint32) -> *mut SDL_sem;
}
extern "C" {
    ///  Destroy a semaphore.
    pub fn SDL_DestroySemaphore(sem: *mut SDL_sem);
}
extern "C" {
    ///  This function suspends the calling thread until the semaphore pointed
    ///  to by \c sem has a positive count. It then atomically decreases the
    ///  semaphore count.
    pub fn SDL_SemWait(sem: *mut SDL_sem) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Non-blocking variant of SDL_SemWait().
    ///
    ///  \return 0 if the wait succeeds, ::SDL_MUTEX_TIMEDOUT if the wait would
    ///          block, and -1 on error.
    pub fn SDL_SemTryWait(sem: *mut SDL_sem) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Variant of SDL_SemWait() with a timeout in milliseconds.
    ///
    ///  \return 0 if the wait succeeds, ::SDL_MUTEX_TIMEDOUT if the wait does not
    ///          succeed in the allotted time, and -1 on error.
    ///
    ///  \warning On some platforms this function is implemented by looping with a
    ///           delay of 1 ms, and so should be avoided if possible.
    pub fn SDL_SemWaitTimeout(sem: *mut SDL_sem, ms: Uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Atomically increases the semaphore's count (not blocking).
    ///
    ///  \return 0, or -1 on error.
    pub fn SDL_SemPost(sem: *mut SDL_sem) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Returns the current count of the semaphore.
    pub fn SDL_SemValue(sem: *mut SDL_sem) -> Uint32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_cond {
    _unused: [u8; 0],
}
extern "C" {
    ///  Create a condition variable.
    ///
    ///  Typical use of condition variables:
    ///
    ///  Thread A:
    ///    SDL_LockMutex(lock);
    ///    while ( ! condition ) {
    ///        SDL_CondWait(cond, lock);
    ///    }
    ///    SDL_UnlockMutex(lock);
    ///
    ///  Thread B:
    ///    SDL_LockMutex(lock);
    ///    ...
    ///    condition = true;
    ///    ...
    ///    SDL_CondSignal(cond);
    ///    SDL_UnlockMutex(lock);
    ///
    ///  There is some discussion whether to signal the condition variable
    ///  with the mutex locked or not.  There is some potential performance
    ///  benefit to unlocking first on some platforms, but there are some
    ///  potential race conditions depending on how your code is structured.
    ///
    ///  In general it's safer to signal the condition variable while the
    ///  mutex is locked.
    pub fn SDL_CreateCond() -> *mut SDL_cond;
}
extern "C" {
    ///  Destroy a condition variable.
    pub fn SDL_DestroyCond(cond: *mut SDL_cond);
}
extern "C" {
    ///  Restart one of the threads that are waiting on the condition variable.
    ///
    ///  \return 0 or -1 on error.
    pub fn SDL_CondSignal(cond: *mut SDL_cond) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Restart all threads that are waiting on the condition variable.
    ///
    ///  \return 0 or -1 on error.
    pub fn SDL_CondBroadcast(cond: *mut SDL_cond) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Wait on the condition variable, unlocking the provided mutex.
    ///
    ///  \warning The mutex must be locked before entering this function!
    ///
    ///  The mutex is re-locked once the condition variable is signaled.
    ///
    ///  \return 0 when it is signaled, or -1 on error.
    pub fn SDL_CondWait(cond: *mut SDL_cond, mutex: *mut SDL_mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Waits for at most \c ms milliseconds, and returns 0 if the condition
    ///  variable is signaled, ::SDL_MUTEX_TIMEDOUT if the condition is not
    ///  signaled in the allotted time, and -1 on error.
    ///
    ///  \warning On some platforms this function is implemented by looping with a
    ///           delay of 1 ms, and so should be avoided if possible.
    pub fn SDL_CondWaitTimeout(
        cond: *mut SDL_cond,
        mutex: *mut SDL_mutex,
        ms: Uint32,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Thread {
    _unused: [u8; 0],
}
pub type SDL_threadID = ::std::os::raw::c_ulong;
pub type SDL_TLSID = ::std::os::raw::c_uint;
#[repr(u32)]
///  The SDL thread priority.
///
///  \note On many systems you require special privileges to set high priority.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_ThreadPriority {
    SDL_THREAD_PRIORITY_LOW = 0,
    SDL_THREAD_PRIORITY_NORMAL = 1,
    SDL_THREAD_PRIORITY_HIGH = 2,
}
///  The function passed to SDL_CreateThread().
///  It is passed a void* user context parameter and returns an int.
pub type SDL_ThreadFunction = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    ///  Create a thread.
    ///
    ///   Thread naming is a little complicated: Most systems have very small
    ///    limits for the string length (Haiku has 32 bytes, Linux currently has 16,
    ///    Visual C++ 6.0 has nine!), and possibly other arbitrary rules. You'll
    ///    have to see what happens with your system's debugger. The name should be
    ///    UTF-8 (but using the naming limits of C identifiers is a better bet).
    ///   There are no requirements for thread naming conventions, so long as the
    ///    string is null-terminated UTF-8, but these guidelines are helpful in
    ///    choosing a name:
    ///
    ///    http://stackoverflow.com/questions/149932/naming-conventions-for-threads
    ///
    ///   If a system imposes requirements, SDL will try to munge the string for
    ///    it (truncate, etc), but the original string contents will be available
    ///    from SDL_GetThreadName().
    pub fn SDL_CreateThread(
        fn_: SDL_ThreadFunction,
        name: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut SDL_Thread;
}
extern "C" {
    /// Get the thread name, as it was specified in SDL_CreateThread().
    ///  This function returns a pointer to a UTF-8 string that names the
    ///  specified thread, or NULL if it doesn't have a name. This is internal
    ///  memory, not to be free()'d by the caller, and remains valid until the
    ///  specified thread is cleaned up by SDL_WaitThread().
    pub fn SDL_GetThreadName(thread: *mut SDL_Thread) -> *const ::std::os::raw::c_char;
}
extern "C" {
    ///  Get the thread identifier for the current thread.
    pub fn SDL_ThreadID() -> SDL_threadID;
}
extern "C" {
    ///  Get the thread identifier for the specified thread.
    ///
    ///  Equivalent to SDL_ThreadID() if the specified thread is NULL.
    pub fn SDL_GetThreadID(thread: *mut SDL_Thread) -> SDL_threadID;
}
extern "C" {
    ///  Set the priority for the current thread
    pub fn SDL_SetThreadPriority(priority: SDL_ThreadPriority) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Wait for a thread to finish. Threads that haven't been detached will
    ///  remain (as a "zombie") until this function cleans them up. Not doing so
    ///  is a resource leak.
    ///
    ///  Once a thread has been cleaned up through this function, the SDL_Thread
    ///  that references it becomes invalid and should not be referenced again.
    ///  As such, only one thread may call SDL_WaitThread() on another.
    ///
    ///  The return code for the thread function is placed in the area
    ///  pointed to by \c status, if \c status is not NULL.
    ///
    ///  You may not wait on a thread that has been used in a call to
    ///  SDL_DetachThread(). Use either that function or this one, but not
    ///  both, or behavior is undefined.
    ///
    ///  It is safe to pass NULL to this function; it is a no-op.
    pub fn SDL_WaitThread(thread: *mut SDL_Thread, status: *mut ::std::os::raw::c_int);
}
extern "C" {
    ///  A thread may be "detached" to signify that it should not remain until
    ///  another thread has called SDL_WaitThread() on it. Detaching a thread
    ///  is useful for long-running threads that nothing needs to synchronize
    ///  with or further manage. When a detached thread is done, it simply
    ///  goes away.
    ///
    ///  There is no way to recover the return code of a detached thread. If you
    ///  need this, don't detach the thread and instead use SDL_WaitThread().
    ///
    ///  Once a thread is detached, you should usually assume the SDL_Thread isn't
    ///  safe to reference again, as it will become invalid immediately upon
    ///  the detached thread's exit, instead of remaining until someone has called
    ///  SDL_WaitThread() to finally clean it up. As such, don't detach the same
    ///  thread more than once.
    ///
    ///  If a thread has already exited when passed to SDL_DetachThread(), it will
    ///  stop waiting for a call to SDL_WaitThread() and clean up immediately.
    ///  It is not safe to detach a thread that might be used with SDL_WaitThread().
    ///
    ///  You may not call SDL_WaitThread() on a thread that has been detached.
    ///  Use either that function or this one, but not both, or behavior is
    ///  undefined.
    ///
    ///  It is safe to pass NULL to this function; it is a no-op.
    pub fn SDL_DetachThread(thread: *mut SDL_Thread);
}
extern "C" {
    ///  \brief Create an identifier that is globally visible to all threads but refers to data that is thread-specific.
    ///
    ///  \return The newly created thread local storage identifier, or 0 on error
    ///
    ///  \code
    ///  static SDL_SpinLock tls_lock;
    ///  static SDL_TLSID thread_local_storage;
    ///
    ///  void SetMyThreadData(void *value)
    ///  {
    ///      if (!thread_local_storage) {
    ///          SDL_AtomicLock(&tls_lock);
    ///          if (!thread_local_storage) {
    ///              thread_local_storage = SDL_TLSCreate();
    ///          }
    ///          SDL_AtomicUnLock(&tls_lock);
    ///      }
    ///      SDL_TLSSet(thread_local_storage, value);
    ///  }
    ///
    ///  void *GetMyThreadData(void)
    ///  {
    ///      return SDL_TLSGet(thread_local_storage);
    ///  }
    ///  \endcode
    ///
    ///  \sa SDL_TLSGet()
    ///  \sa SDL_TLSSet()
    pub fn SDL_TLSCreate() -> SDL_TLSID;
}
extern "C" {
    ///  \brief Get the value associated with a thread local storage ID for the current thread.
    ///
    ///  \param id The thread local storage ID
    ///
    ///  \return The value associated with the ID for the current thread, or NULL if no value has been set.
    ///
    ///  \sa SDL_TLSCreate()
    ///  \sa SDL_TLSSet()
    pub fn SDL_TLSGet(id: SDL_TLSID) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    ///  \brief Set the value associated with a thread local storage ID for the current thread.
    ///
    ///  \param id The thread local storage ID
    ///  \param value The value to associate with the ID for the current thread
    ///  \param destructor A function called when the thread exits, to free the value.
    ///
    ///  \return 0 on success, -1 on error
    ///
    ///  \sa SDL_TLSCreate()
    ///  \sa SDL_TLSGet()
    pub fn SDL_TLSSet(
        id: SDL_TLSID,
        value: *const ::std::os::raw::c_void,
        destructor: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
/// This is the read/write operation structure -- very basic.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RWops {
    ///  Return the size of the file in this rwops, or -1 if unknown
    pub size: ::std::option::Option<unsafe extern "C" fn(context: *mut SDL_RWops) -> Sint64>,
    ///  Seek to \c offset relative to \c whence, one of stdio's whence values:
    ///  RW_SEEK_SET, RW_SEEK_CUR, RW_SEEK_END
    ///
    ///  \return the final offset in the data stream, or -1 on error.
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut SDL_RWops,
            offset: Sint64,
            whence: ::std::os::raw::c_int,
        ) -> Sint64,
    >,
    ///  Read up to \c maxnum objects each of size \c size from the data
    ///  stream to the area pointed at by \c ptr.
    ///
    ///  \return the number of objects read, or 0 at error or end of file.
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut SDL_RWops,
            ptr: *mut ::std::os::raw::c_void,
            size: usize,
            maxnum: usize,
        ) -> usize,
    >,
    ///  Write exactly \c num objects each of size \c size from the area
    ///  pointed at by \c ptr to data stream.
    ///
    ///  \return the number of objects written, or 0 at error or end of file.
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut SDL_RWops,
            ptr: *const ::std::os::raw::c_void,
            size: usize,
            num: usize,
        ) -> usize,
    >,
    ///  Close and free an allocated SDL_RWops structure.
    ///
    ///  \return 0 if successful or -1 on write error when flushing data.
    pub close: ::std::option::Option<
        unsafe extern "C" fn(context: *mut SDL_RWops) -> ::std::os::raw::c_int,
    >,
    pub type_: Uint32,
    pub hidden: SDL_RWops__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_RWops__bindgen_ty_1 {
    pub stdio: SDL_RWops__bindgen_ty_1__bindgen_ty_1,
    pub mem: SDL_RWops__bindgen_ty_1__bindgen_ty_2,
    pub unknown: SDL_RWops__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_1 {
    pub autoclose: SDL_bool,
    pub fp: *mut FILE,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_2 {
    pub base: *mut Uint8,
    pub here: *mut Uint8,
    pub stop: *mut Uint8,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_3 {
    pub data1: *mut ::std::os::raw::c_void,
    pub data2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SDL_RWops__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_RWops__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_RWops__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_RWops__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout_SDL_RWops() {
    assert_eq!(
        ::std::mem::size_of::<SDL_RWops>(),
        72usize,
        concat!("Size of: ", stringify!(SDL_RWops))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_RWops>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_RWops))
    );
}
extern "C" {
    pub fn SDL_RWFromFile(
        file: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_RWFromFP(fp: *mut FILE, autoclose: SDL_bool) -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_RWFromMem(
        mem: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
    ) -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_RWFromConstMem(
        mem: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
    ) -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_AllocRW() -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_FreeRW(area: *mut SDL_RWops);
}
extern "C" {
    pub fn SDL_ReadU8(src: *mut SDL_RWops) -> Uint8;
}
extern "C" {
    pub fn SDL_ReadLE16(src: *mut SDL_RWops) -> Uint16;
}
extern "C" {
    pub fn SDL_ReadBE16(src: *mut SDL_RWops) -> Uint16;
}
extern "C" {
    pub fn SDL_ReadLE32(src: *mut SDL_RWops) -> Uint32;
}
extern "C" {
    pub fn SDL_ReadBE32(src: *mut SDL_RWops) -> Uint32;
}
extern "C" {
    pub fn SDL_ReadLE64(src: *mut SDL_RWops) -> Uint64;
}
extern "C" {
    pub fn SDL_ReadBE64(src: *mut SDL_RWops) -> Uint64;
}
extern "C" {
    pub fn SDL_WriteU8(dst: *mut SDL_RWops, value: Uint8) -> usize;
}
extern "C" {
    pub fn SDL_WriteLE16(dst: *mut SDL_RWops, value: Uint16) -> usize;
}
extern "C" {
    pub fn SDL_WriteBE16(dst: *mut SDL_RWops, value: Uint16) -> usize;
}
extern "C" {
    pub fn SDL_WriteLE32(dst: *mut SDL_RWops, value: Uint32) -> usize;
}
extern "C" {
    pub fn SDL_WriteBE32(dst: *mut SDL_RWops, value: Uint32) -> usize;
}
extern "C" {
    pub fn SDL_WriteLE64(dst: *mut SDL_RWops, value: Uint64) -> usize;
}
extern "C" {
    pub fn SDL_WriteBE64(dst: *mut SDL_RWops, value: Uint64) -> usize;
}
///  \brief Audio format flags.
///
///  These are what the 16 bits in SDL_AudioFormat currently mean...
///  (Unspecified bits are always zero).
///
///  \verbatim
///++-----------------------sample is signed if set
///||
///||       ++-----------sample is bigendian if set
///||       ||
///||       ||          ++---sample is float if set
///||       ||          ||
///||       ||          || +---sample bit size---+
///||       ||          || |                     |
///15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
///\endverbatim
///
///  There are macros in SDL 2.0 and later to query these bits.
pub type SDL_AudioFormat = Uint16;
///  This function is called when the audio device needs more data.
///
///  \param userdata An application-specific parameter saved in
///                  the SDL_AudioSpec structure
///  \param stream A pointer to the audio data buffer.
///  \param len    The length of that buffer in bytes.
///
///  Once the callback returns, the buffer will no longer be valid.
///  Stereo samples are stored in a LRLRLR ordering.
pub type SDL_AudioCallback = ::std::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::std::os::raw::c_void,
        stream: *mut Uint8,
        len: ::std::os::raw::c_int,
    ),
>;
///  The calculated values in this structure are calculated by SDL_OpenAudio().
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_AudioSpec {
    ///< DSP frequency -- samples per second
    pub freq: ::std::os::raw::c_int,
    ///< Audio data format
    pub format: SDL_AudioFormat,
    ///< Number of channels: 1 mono, 2 stereo
    pub channels: Uint8,
    ///< Audio buffer silence value (calculated)
    pub silence: Uint8,
    ///< Audio buffer size in samples (power of 2)
    pub samples: Uint16,
    ///< Necessary for some compile environments
    pub padding: Uint16,
    ///< Audio buffer size in bytes (calculated)
    pub size: Uint32,
    pub callback: SDL_AudioCallback,
    pub userdata: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SDL_AudioSpec() {
    assert_eq!(
        ::std::mem::size_of::<SDL_AudioSpec>(),
        32usize,
        concat!("Size of: ", stringify!(SDL_AudioSpec))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_AudioSpec>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_AudioSpec))
    );
}
pub type SDL_AudioFilter =
    ::std::option::Option<unsafe extern "C" fn(cvt: *mut SDL_AudioCVT, format: SDL_AudioFormat)>;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SDL_AudioCVT {
    ///< Set to 1 if conversion possible
    pub needed: ::std::os::raw::c_int,
    ///< Source audio format
    pub src_format: SDL_AudioFormat,
    ///< Target audio format
    pub dst_format: SDL_AudioFormat,
    ///< Rate conversion increment
    pub rate_incr: f64,
    ///< Buffer to hold entire audio data
    pub buf: *mut Uint8,
    ///< Length of original audio buffer
    pub len: ::std::os::raw::c_int,
    ///< Length of converted audio buffer
    pub len_cvt: ::std::os::raw::c_int,
    ///< buffer must be len*len_mult big
    pub len_mult: ::std::os::raw::c_int,
    ///< Given len, final size is len*len_ratio
    pub len_ratio: f64,
    ///< Filter list
    pub filters: [SDL_AudioFilter; 10usize],
    ///< Current audio conversion function
    pub filter_index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_AudioCVT() {
    assert_eq!(
        ::std::mem::size_of::<SDL_AudioCVT>(),
        128usize,
        concat!("Size of: ", stringify!(SDL_AudioCVT))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_AudioCVT>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_AudioCVT))
    );
}
extern "C" {
    pub fn SDL_GetNumAudioDrivers() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_GetAudioDriver(index: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_AudioInit(driver_name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_AudioQuit();
}
extern "C" {
    ///  This function returns the name of the current audio driver, or NULL
    ///  if no driver has been initialized.
    pub fn SDL_GetCurrentAudioDriver() -> *const ::std::os::raw::c_char;
}
extern "C" {
    ///  This function opens the audio device with the desired parameters, and
    ///  returns 0 if successful, placing the actual hardware parameters in the
    ///  structure pointed to by \c obtained.  If \c obtained is NULL, the audio
    ///  data passed to the callback function will be guaranteed to be in the
    ///  requested format, and will be automatically converted to the hardware
    ///  audio format if necessary.  This function returns -1 if it failed
    ///  to open the audio device, or couldn't set up the audio thread.
    ///
    ///  When filling in the desired audio spec structure,
    ///    - \c desired->freq should be the desired audio frequency in samples-per-
    ///      second.
    ///    - \c desired->format should be the desired audio format.
    ///    - \c desired->samples is the desired size of the audio buffer, in
    ///      samples.  This number should be a power of two, and may be adjusted by
    ///      the audio driver to a value more suitable for the hardware.  Good values
    ///      seem to range between 512 and 8096 inclusive, depending on the
    ///      application and CPU speed.  Smaller values yield faster response time,
    ///      but can lead to underflow if the application is doing heavy processing
    ///      and cannot fill the audio buffer in time.  A stereo sample consists of
    ///      both right and left channels in LR ordering.
    ///      Note that the number of samples is directly related to time by the
    ///      following formula:  \code ms = (samples*1000)/freq \endcode
    ///    - \c desired->size is the size in bytes of the audio buffer, and is
    ///      calculated by SDL_OpenAudio().
    ///    - \c desired->silence is the value used to set the buffer to silence,
    ///      and is calculated by SDL_OpenAudio().
    ///    - \c desired->callback should be set to a function that will be called
    ///      when the audio device is ready for more data.  It is passed a pointer
    ///      to the audio buffer, and the length in bytes of the audio buffer.
    ///      This function usually runs in a separate thread, and so you should
    ///      protect data structures that it accesses by calling SDL_LockAudio()
    ///      and SDL_UnlockAudio() in your code.
    ///    - \c desired->userdata is passed as the first parameter to your callback
    ///      function.
    ///
    ///  The audio device starts out playing silence when it's opened, and should
    ///  be enabled for playing by calling \c SDL_PauseAudio(0) when you are ready
    ///  for your audio callback function to be called.  Since the audio driver
    ///  may modify the requested size of the audio buffer, you should allocate
    ///  any local mixing buffers after you open the audio device.
    pub fn SDL_OpenAudio(
        desired: *mut SDL_AudioSpec,
        obtained: *mut SDL_AudioSpec,
    ) -> ::std::os::raw::c_int;
}
///  SDL Audio Device IDs.
///
///  A successful call to SDL_OpenAudio() is always device id 1, and legacy
///  SDL audio APIs assume you want this device ID. SDL_OpenAudioDevice() calls
///  always returns devices >= 2 on success. The legacy calls are good both
///  for backwards compatibility and when you don't care about multiple,
///  specific, or capture devices.
pub type SDL_AudioDeviceID = Uint32;
extern "C" {
    ///  Get the number of available devices exposed by the current driver.
    ///  Only valid after a successfully initializing the audio subsystem.
    ///  Returns -1 if an explicit list of devices can't be determined; this is
    ///  not an error. For example, if SDL is set up to talk to a remote audio
    ///  server, it can't list every one available on the Internet, but it will
    ///  still allow a specific host to be specified to SDL_OpenAudioDevice().
    ///
    ///  In many common cases, when this function returns a value <= 0, it can still
    ///  successfully open the default device (NULL for first argument of
    ///  SDL_OpenAudioDevice()).
    pub fn SDL_GetNumAudioDevices(iscapture: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Get the human-readable name of a specific audio device.
    ///  Must be a value between 0 and (number of audio devices-1).
    ///  Only valid after a successfully initializing the audio subsystem.
    ///  The values returned by this function reflect the latest call to
    ///  SDL_GetNumAudioDevices(); recall that function to redetect available
    ///  hardware.
    ///
    ///  The string returned by this function is UTF-8 encoded, read-only, and
    ///  managed internally. You are not to free it. If you need to keep the
    ///  string for any length of time, you should make your own copy of it, as it
    ///  will be invalid next time any of several other SDL functions is called.
    pub fn SDL_GetAudioDeviceName(
        index: ::std::os::raw::c_int,
        iscapture: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    ///  Open a specific audio device. Passing in a device name of NULL requests
    ///  the most reasonable default (and is equivalent to calling SDL_OpenAudio()).
    ///
    ///  The device name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but
    ///  some drivers allow arbitrary and driver-specific strings, such as a
    ///  hostname/IP address for a remote audio server, or a filename in the
    ///  diskaudio driver.
    ///
    ///  \return 0 on error, a valid device ID that is >= 2 on success.
    ///
    ///  SDL_OpenAudio(), unlike this function, always acts on device ID 1.
    pub fn SDL_OpenAudioDevice(
        device: *const ::std::os::raw::c_char,
        iscapture: ::std::os::raw::c_int,
        desired: *const SDL_AudioSpec,
        obtained: *mut SDL_AudioSpec,
        allowed_changes: ::std::os::raw::c_int,
    ) -> SDL_AudioDeviceID;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_AudioStatus {
    SDL_AUDIO_STOPPED = 0,
    SDL_AUDIO_PLAYING = 1,
    SDL_AUDIO_PAUSED = 2,
}
extern "C" {
    pub fn SDL_GetAudioStatus() -> SDL_AudioStatus;
}
extern "C" {
    pub fn SDL_GetAudioDeviceStatus(dev: SDL_AudioDeviceID) -> SDL_AudioStatus;
}
extern "C" {
    pub fn SDL_PauseAudio(pause_on: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SDL_PauseAudioDevice(dev: SDL_AudioDeviceID, pause_on: ::std::os::raw::c_int);
}
extern "C" {
    ///  This function loads a WAVE from the data source, automatically freeing
    ///  that source if \c freesrc is non-zero.  For example, to load a WAVE file,
    ///  you could do:
    ///  \code
    ///      SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, ...);
    ///  \endcode
    ///
    ///  If this function succeeds, it returns the given SDL_AudioSpec,
    ///  filled with the audio data format of the wave data, and sets
    ///  \c *audio_buf to a malloc()'d buffer containing the audio data,
    ///  and sets \c *audio_len to the length of that audio buffer, in bytes.
    ///  You need to free the audio buffer with SDL_FreeWAV() when you are
    ///  done with it.
    ///
    ///  This function returns NULL and sets the SDL error message if the
    ///  wave file cannot be opened, uses an unknown data format, or is
    ///  corrupt.  Currently raw and MS-ADPCM WAVE files are supported.
    pub fn SDL_LoadWAV_RW(
        src: *mut SDL_RWops,
        freesrc: ::std::os::raw::c_int,
        spec: *mut SDL_AudioSpec,
        audio_buf: *mut *mut Uint8,
        audio_len: *mut Uint32,
    ) -> *mut SDL_AudioSpec;
}
extern "C" {
    ///  This function frees data previously allocated with SDL_LoadWAV_RW()
    pub fn SDL_FreeWAV(audio_buf: *mut Uint8);
}
extern "C" {
    ///  This function takes a source format and rate and a destination format
    ///  and rate, and initializes the \c cvt structure with information needed
    ///  by SDL_ConvertAudio() to convert a buffer of audio data from one format
    ///  to the other.
    ///
    ///  \return -1 if the format conversion is not supported, 0 if there's
    ///  no conversion needed, or 1 if the audio filter is set up.
    pub fn SDL_BuildAudioCVT(
        cvt: *mut SDL_AudioCVT,
        src_format: SDL_AudioFormat,
        src_channels: Uint8,
        src_rate: ::std::os::raw::c_int,
        dst_format: SDL_AudioFormat,
        dst_channels: Uint8,
        dst_rate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Once you have initialized the \c cvt structure using SDL_BuildAudioCVT(),
    ///  created an audio buffer \c cvt->buf, and filled it with \c cvt->len bytes of
    ///  audio data in the source format, this function will convert it in-place
    ///  to the desired format.
    ///
    ///  The data conversion may expand the size of the audio data, so the buffer
    ///  \c cvt->buf should be allocated after the \c cvt structure is initialized by
    ///  SDL_BuildAudioCVT(), and should be \c cvt->len*cvt->len_mult bytes long.
    pub fn SDL_ConvertAudio(cvt: *mut SDL_AudioCVT) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  This takes two audio buffers of the playing audio format and mixes
    ///  them, performing addition, volume adjustment, and overflow clipping.
    ///  The volume ranges from 0 - 128, and should be set to ::SDL_MIX_MAXVOLUME
    ///  for full audio volume.  Note this does not change hardware volume.
    ///  This is provided for convenience -- you can mix your own audio data.
    pub fn SDL_MixAudio(
        dst: *mut Uint8,
        src: *const Uint8,
        len: Uint32,
        volume: ::std::os::raw::c_int,
    );
}
extern "C" {
    ///  This works like SDL_MixAudio(), but you specify the audio format instead of
    ///  using the format of audio device 1. Thus it can be used when no audio
    ///  device is open at all.
    pub fn SDL_MixAudioFormat(
        dst: *mut Uint8,
        src: *const Uint8,
        format: SDL_AudioFormat,
        len: Uint32,
        volume: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SDL_LockAudio();
}
extern "C" {
    pub fn SDL_LockAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
    pub fn SDL_UnlockAudio();
}
extern "C" {
    pub fn SDL_UnlockAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
    ///  This function shuts down audio processing and closes the audio device.
    pub fn SDL_CloseAudio();
}
extern "C" {
    pub fn SDL_CloseAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
    /// \brief Put UTF-8 text into the clipboard
    ///
    /// \sa SDL_GetClipboardText()
    pub fn SDL_SetClipboardText(text: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get UTF-8 text from the clipboard, which must be freed with SDL_free()
    ///
    /// \sa SDL_SetClipboardText()
    pub fn SDL_GetClipboardText() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// \brief Returns a flag indicating whether the clipboard exists and contains a text string that is non-empty
    ///
    /// \sa SDL_GetClipboardText()
    pub fn SDL_HasClipboardText() -> SDL_bool;
}
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
extern "C" {
    ///  This function returns the number of CPU cores available.
    pub fn SDL_GetCPUCount() -> ::std::os::raw::c_int;
}
extern "C" {
    ///  This function returns the L1 cache line size of the CPU
    ///
    ///  This is useful for determining multi-threaded structure padding
    ///  or SIMD prefetch sizes.
    pub fn SDL_GetCPUCacheLineSize() -> ::std::os::raw::c_int;
}
extern "C" {
    ///  This function returns true if the CPU has the RDTSC instruction.
    pub fn SDL_HasRDTSC() -> SDL_bool;
}
extern "C" {
    ///  This function returns true if the CPU has AltiVec features.
    pub fn SDL_HasAltiVec() -> SDL_bool;
}
extern "C" {
    ///  This function returns true if the CPU has MMX features.
    pub fn SDL_HasMMX() -> SDL_bool;
}
extern "C" {
    ///  This function returns true if the CPU has 3DNow! features.
    pub fn SDL_Has3DNow() -> SDL_bool;
}
extern "C" {
    ///  This function returns true if the CPU has SSE features.
    pub fn SDL_HasSSE() -> SDL_bool;
}
extern "C" {
    ///  This function returns true if the CPU has SSE2 features.
    pub fn SDL_HasSSE2() -> SDL_bool;
}
extern "C" {
    ///  This function returns true if the CPU has SSE3 features.
    pub fn SDL_HasSSE3() -> SDL_bool;
}
extern "C" {
    ///  This function returns true if the CPU has SSE4.1 features.
    pub fn SDL_HasSSE41() -> SDL_bool;
}
extern "C" {
    ///  This function returns true if the CPU has SSE4.2 features.
    pub fn SDL_HasSSE42() -> SDL_bool;
}
extern "C" {
    ///  This function returns true if the CPU has AVX features.
    pub fn SDL_HasAVX() -> SDL_bool;
}
extern "C" {
    ///  This function returns the amount of RAM configured in the system, in MB.
    pub fn SDL_GetSystemRAM() -> ::std::os::raw::c_int;
}
pub const SDL_PIXELTYPE_UNKNOWN: _bindgen_ty_3 = _bindgen_ty_3::SDL_PIXELTYPE_UNKNOWN;
pub const SDL_PIXELTYPE_INDEX1: _bindgen_ty_3 = _bindgen_ty_3::SDL_PIXELTYPE_INDEX1;
pub const SDL_PIXELTYPE_INDEX4: _bindgen_ty_3 = _bindgen_ty_3::SDL_PIXELTYPE_INDEX4;
pub const SDL_PIXELTYPE_INDEX8: _bindgen_ty_3 = _bindgen_ty_3::SDL_PIXELTYPE_INDEX8;
pub const SDL_PIXELTYPE_PACKED8: _bindgen_ty_3 = _bindgen_ty_3::SDL_PIXELTYPE_PACKED8;
pub const SDL_PIXELTYPE_PACKED16: _bindgen_ty_3 = _bindgen_ty_3::SDL_PIXELTYPE_PACKED16;
pub const SDL_PIXELTYPE_PACKED32: _bindgen_ty_3 = _bindgen_ty_3::SDL_PIXELTYPE_PACKED32;
pub const SDL_PIXELTYPE_ARRAYU8: _bindgen_ty_3 = _bindgen_ty_3::SDL_PIXELTYPE_ARRAYU8;
pub const SDL_PIXELTYPE_ARRAYU16: _bindgen_ty_3 = _bindgen_ty_3::SDL_PIXELTYPE_ARRAYU16;
pub const SDL_PIXELTYPE_ARRAYU32: _bindgen_ty_3 = _bindgen_ty_3::SDL_PIXELTYPE_ARRAYU32;
pub const SDL_PIXELTYPE_ARRAYF16: _bindgen_ty_3 = _bindgen_ty_3::SDL_PIXELTYPE_ARRAYF16;
pub const SDL_PIXELTYPE_ARRAYF32: _bindgen_ty_3 = _bindgen_ty_3::SDL_PIXELTYPE_ARRAYF32;
#[repr(u32)]
/// Pixel type.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 {
    SDL_PIXELTYPE_UNKNOWN = 0,
    SDL_PIXELTYPE_INDEX1 = 1,
    SDL_PIXELTYPE_INDEX4 = 2,
    SDL_PIXELTYPE_INDEX8 = 3,
    SDL_PIXELTYPE_PACKED8 = 4,
    SDL_PIXELTYPE_PACKED16 = 5,
    SDL_PIXELTYPE_PACKED32 = 6,
    SDL_PIXELTYPE_ARRAYU8 = 7,
    SDL_PIXELTYPE_ARRAYU16 = 8,
    SDL_PIXELTYPE_ARRAYU32 = 9,
    SDL_PIXELTYPE_ARRAYF16 = 10,
    SDL_PIXELTYPE_ARRAYF32 = 11,
}
pub const SDL_BITMAPORDER_NONE: _bindgen_ty_4 = _bindgen_ty_4::SDL_BITMAPORDER_NONE;
pub const SDL_BITMAPORDER_4321: _bindgen_ty_4 = _bindgen_ty_4::SDL_BITMAPORDER_4321;
pub const SDL_BITMAPORDER_1234: _bindgen_ty_4 = _bindgen_ty_4::SDL_BITMAPORDER_1234;
#[repr(u32)]
/// Bitmap pixel order, high bit -> low bit.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 {
    SDL_BITMAPORDER_NONE = 0,
    SDL_BITMAPORDER_4321 = 1,
    SDL_BITMAPORDER_1234 = 2,
}
pub const SDL_PACKEDORDER_NONE: _bindgen_ty_5 = _bindgen_ty_5::SDL_PACKEDORDER_NONE;
pub const SDL_PACKEDORDER_XRGB: _bindgen_ty_5 = _bindgen_ty_5::SDL_PACKEDORDER_XRGB;
pub const SDL_PACKEDORDER_RGBX: _bindgen_ty_5 = _bindgen_ty_5::SDL_PACKEDORDER_RGBX;
pub const SDL_PACKEDORDER_ARGB: _bindgen_ty_5 = _bindgen_ty_5::SDL_PACKEDORDER_ARGB;
pub const SDL_PACKEDORDER_RGBA: _bindgen_ty_5 = _bindgen_ty_5::SDL_PACKEDORDER_RGBA;
pub const SDL_PACKEDORDER_XBGR: _bindgen_ty_5 = _bindgen_ty_5::SDL_PACKEDORDER_XBGR;
pub const SDL_PACKEDORDER_BGRX: _bindgen_ty_5 = _bindgen_ty_5::SDL_PACKEDORDER_BGRX;
pub const SDL_PACKEDORDER_ABGR: _bindgen_ty_5 = _bindgen_ty_5::SDL_PACKEDORDER_ABGR;
pub const SDL_PACKEDORDER_BGRA: _bindgen_ty_5 = _bindgen_ty_5::SDL_PACKEDORDER_BGRA;
#[repr(u32)]
/// Packed component order, high bit -> low bit.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 {
    SDL_PACKEDORDER_NONE = 0,
    SDL_PACKEDORDER_XRGB = 1,
    SDL_PACKEDORDER_RGBX = 2,
    SDL_PACKEDORDER_ARGB = 3,
    SDL_PACKEDORDER_RGBA = 4,
    SDL_PACKEDORDER_XBGR = 5,
    SDL_PACKEDORDER_BGRX = 6,
    SDL_PACKEDORDER_ABGR = 7,
    SDL_PACKEDORDER_BGRA = 8,
}
pub const SDL_ARRAYORDER_NONE: _bindgen_ty_6 = _bindgen_ty_6::SDL_ARRAYORDER_NONE;
pub const SDL_ARRAYORDER_RGB: _bindgen_ty_6 = _bindgen_ty_6::SDL_ARRAYORDER_RGB;
pub const SDL_ARRAYORDER_RGBA: _bindgen_ty_6 = _bindgen_ty_6::SDL_ARRAYORDER_RGBA;
pub const SDL_ARRAYORDER_ARGB: _bindgen_ty_6 = _bindgen_ty_6::SDL_ARRAYORDER_ARGB;
pub const SDL_ARRAYORDER_BGR: _bindgen_ty_6 = _bindgen_ty_6::SDL_ARRAYORDER_BGR;
pub const SDL_ARRAYORDER_BGRA: _bindgen_ty_6 = _bindgen_ty_6::SDL_ARRAYORDER_BGRA;
pub const SDL_ARRAYORDER_ABGR: _bindgen_ty_6 = _bindgen_ty_6::SDL_ARRAYORDER_ABGR;
#[repr(u32)]
/// Array component order, low byte -> high byte.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_6 {
    SDL_ARRAYORDER_NONE = 0,
    SDL_ARRAYORDER_RGB = 1,
    SDL_ARRAYORDER_RGBA = 2,
    SDL_ARRAYORDER_ARGB = 3,
    SDL_ARRAYORDER_BGR = 4,
    SDL_ARRAYORDER_BGRA = 5,
    SDL_ARRAYORDER_ABGR = 6,
}
pub const SDL_PACKEDLAYOUT_NONE: _bindgen_ty_7 = _bindgen_ty_7::SDL_PACKEDLAYOUT_NONE;
pub const SDL_PACKEDLAYOUT_332: _bindgen_ty_7 = _bindgen_ty_7::SDL_PACKEDLAYOUT_332;
pub const SDL_PACKEDLAYOUT_4444: _bindgen_ty_7 = _bindgen_ty_7::SDL_PACKEDLAYOUT_4444;
pub const SDL_PACKEDLAYOUT_1555: _bindgen_ty_7 = _bindgen_ty_7::SDL_PACKEDLAYOUT_1555;
pub const SDL_PACKEDLAYOUT_5551: _bindgen_ty_7 = _bindgen_ty_7::SDL_PACKEDLAYOUT_5551;
pub const SDL_PACKEDLAYOUT_565: _bindgen_ty_7 = _bindgen_ty_7::SDL_PACKEDLAYOUT_565;
pub const SDL_PACKEDLAYOUT_8888: _bindgen_ty_7 = _bindgen_ty_7::SDL_PACKEDLAYOUT_8888;
pub const SDL_PACKEDLAYOUT_2101010: _bindgen_ty_7 = _bindgen_ty_7::SDL_PACKEDLAYOUT_2101010;
pub const SDL_PACKEDLAYOUT_1010102: _bindgen_ty_7 = _bindgen_ty_7::SDL_PACKEDLAYOUT_1010102;
#[repr(u32)]
/// Packed component layout.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_7 {
    SDL_PACKEDLAYOUT_NONE = 0,
    SDL_PACKEDLAYOUT_332 = 1,
    SDL_PACKEDLAYOUT_4444 = 2,
    SDL_PACKEDLAYOUT_1555 = 3,
    SDL_PACKEDLAYOUT_5551 = 4,
    SDL_PACKEDLAYOUT_565 = 5,
    SDL_PACKEDLAYOUT_8888 = 6,
    SDL_PACKEDLAYOUT_2101010 = 7,
    SDL_PACKEDLAYOUT_1010102 = 8,
}
pub const SDL_PIXELFORMAT_UNKNOWN: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_UNKNOWN;
pub const SDL_PIXELFORMAT_INDEX1LSB: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_INDEX1LSB;
pub const SDL_PIXELFORMAT_INDEX1MSB: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_INDEX1MSB;
pub const SDL_PIXELFORMAT_INDEX4LSB: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_INDEX4LSB;
pub const SDL_PIXELFORMAT_INDEX4MSB: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_INDEX4MSB;
pub const SDL_PIXELFORMAT_INDEX8: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_INDEX8;
pub const SDL_PIXELFORMAT_RGB332: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_RGB332;
pub const SDL_PIXELFORMAT_RGB444: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_RGB444;
pub const SDL_PIXELFORMAT_RGB555: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_RGB555;
pub const SDL_PIXELFORMAT_BGR555: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_BGR555;
pub const SDL_PIXELFORMAT_ARGB4444: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_ARGB4444;
pub const SDL_PIXELFORMAT_RGBA4444: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_RGBA4444;
pub const SDL_PIXELFORMAT_ABGR4444: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_ABGR4444;
pub const SDL_PIXELFORMAT_BGRA4444: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_BGRA4444;
pub const SDL_PIXELFORMAT_ARGB1555: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_ARGB1555;
pub const SDL_PIXELFORMAT_RGBA5551: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_RGBA5551;
pub const SDL_PIXELFORMAT_ABGR1555: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_ABGR1555;
pub const SDL_PIXELFORMAT_BGRA5551: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_BGRA5551;
pub const SDL_PIXELFORMAT_RGB565: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_RGB565;
pub const SDL_PIXELFORMAT_BGR565: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_BGR565;
pub const SDL_PIXELFORMAT_RGB24: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_RGB24;
pub const SDL_PIXELFORMAT_BGR24: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_BGR24;
pub const SDL_PIXELFORMAT_RGB888: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_RGB888;
pub const SDL_PIXELFORMAT_RGBX8888: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_RGBX8888;
pub const SDL_PIXELFORMAT_BGR888: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_BGR888;
pub const SDL_PIXELFORMAT_BGRX8888: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_BGRX8888;
pub const SDL_PIXELFORMAT_ARGB8888: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_ARGB8888;
pub const SDL_PIXELFORMAT_RGBA8888: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_RGBA8888;
pub const SDL_PIXELFORMAT_ABGR8888: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_ABGR8888;
pub const SDL_PIXELFORMAT_BGRA8888: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_BGRA8888;
pub const SDL_PIXELFORMAT_ARGB2101010: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_ARGB2101010;
pub const SDL_PIXELFORMAT_YV12: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_YV12;
pub const SDL_PIXELFORMAT_IYUV: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_IYUV;
pub const SDL_PIXELFORMAT_YUY2: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_YUY2;
pub const SDL_PIXELFORMAT_UYVY: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_UYVY;
pub const SDL_PIXELFORMAT_YVYU: _bindgen_ty_8 = _bindgen_ty_8::SDL_PIXELFORMAT_YVYU;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_8 {
    SDL_PIXELFORMAT_UNKNOWN = 0,
    SDL_PIXELFORMAT_INDEX1LSB = 286261504,
    SDL_PIXELFORMAT_INDEX1MSB = 287310080,
    SDL_PIXELFORMAT_INDEX4LSB = 303039488,
    SDL_PIXELFORMAT_INDEX4MSB = 304088064,
    SDL_PIXELFORMAT_INDEX8 = 318769153,
    SDL_PIXELFORMAT_RGB332 = 336660481,
    SDL_PIXELFORMAT_RGB444 = 353504258,
    SDL_PIXELFORMAT_RGB555 = 353570562,
    SDL_PIXELFORMAT_BGR555 = 357764866,
    SDL_PIXELFORMAT_ARGB4444 = 355602434,
    SDL_PIXELFORMAT_RGBA4444 = 356651010,
    SDL_PIXELFORMAT_ABGR4444 = 359796738,
    SDL_PIXELFORMAT_BGRA4444 = 360845314,
    SDL_PIXELFORMAT_ARGB1555 = 355667970,
    SDL_PIXELFORMAT_RGBA5551 = 356782082,
    SDL_PIXELFORMAT_ABGR1555 = 359862274,
    SDL_PIXELFORMAT_BGRA5551 = 360976386,
    SDL_PIXELFORMAT_RGB565 = 353701890,
    SDL_PIXELFORMAT_BGR565 = 357896194,
    SDL_PIXELFORMAT_RGB24 = 386930691,
    SDL_PIXELFORMAT_BGR24 = 390076419,
    SDL_PIXELFORMAT_RGB888 = 370546692,
    SDL_PIXELFORMAT_RGBX8888 = 371595268,
    SDL_PIXELFORMAT_BGR888 = 374740996,
    SDL_PIXELFORMAT_BGRX8888 = 375789572,
    SDL_PIXELFORMAT_ARGB8888 = 372645892,
    SDL_PIXELFORMAT_RGBA8888 = 373694468,
    SDL_PIXELFORMAT_ABGR8888 = 376840196,
    SDL_PIXELFORMAT_BGRA8888 = 377888772,
    SDL_PIXELFORMAT_ARGB2101010 = 372711428,
    ///< Planar mode: Y + V + U  (3 planes)
    SDL_PIXELFORMAT_YV12 = 842094169,
    ///< Planar mode: Y + U + V  (3 planes)
    SDL_PIXELFORMAT_IYUV = 1448433993,
    ///< Packed mode: Y0+U0+Y1+V0 (1 plane)
    SDL_PIXELFORMAT_YUY2 = 844715353,
    ///< Packed mode: U0+Y0+V0+Y1 (1 plane)
    SDL_PIXELFORMAT_UYVY = 1498831189,
    ///< Packed mode: Y0+V0+Y1+U0 (1 plane)
    SDL_PIXELFORMAT_YVYU = 1431918169,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Color {
    pub r: Uint8,
    pub g: Uint8,
    pub b: Uint8,
    pub a: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_Color() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Color>(),
        4usize,
        concat!("Size of: ", stringify!(SDL_Color))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Color>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_Color))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Palette {
    pub ncolors: ::std::os::raw::c_int,
    pub colors: *mut SDL_Color,
    pub version: Uint32,
    pub refcount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Palette() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Palette>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_Palette))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Palette>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Palette))
    );
}
///  \note Everything in the pixel format structure is read-only.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_PixelFormat {
    pub format: Uint32,
    pub palette: *mut SDL_Palette,
    pub BitsPerPixel: Uint8,
    pub BytesPerPixel: Uint8,
    pub padding: [Uint8; 2usize],
    pub Rmask: Uint32,
    pub Gmask: Uint32,
    pub Bmask: Uint32,
    pub Amask: Uint32,
    pub Rloss: Uint8,
    pub Gloss: Uint8,
    pub Bloss: Uint8,
    pub Aloss: Uint8,
    pub Rshift: Uint8,
    pub Gshift: Uint8,
    pub Bshift: Uint8,
    pub Ashift: Uint8,
    pub refcount: ::std::os::raw::c_int,
    pub next: *mut SDL_PixelFormat,
}
#[test]
fn bindgen_test_layout_SDL_PixelFormat() {
    assert_eq!(
        ::std::mem::size_of::<SDL_PixelFormat>(),
        56usize,
        concat!("Size of: ", stringify!(SDL_PixelFormat))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_PixelFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_PixelFormat))
    );
}
extern "C" {
    /// \brief Get the human readable name of a pixel format
    pub fn SDL_GetPixelFormatName(format: Uint32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    ///  \brief Convert one of the enumerated pixel formats to a bpp and RGBA masks.
    ///
    ///  \return SDL_TRUE, or SDL_FALSE if the conversion wasn't possible.
    ///
    ///  \sa SDL_MasksToPixelFormatEnum()
    pub fn SDL_PixelFormatEnumToMasks(
        format: Uint32,
        bpp: *mut ::std::os::raw::c_int,
        Rmask: *mut Uint32,
        Gmask: *mut Uint32,
        Bmask: *mut Uint32,
        Amask: *mut Uint32,
    ) -> SDL_bool;
}
extern "C" {
    ///  \brief Convert a bpp and RGBA masks to an enumerated pixel format.
    ///
    ///  \return The pixel format, or ::SDL_PIXELFORMAT_UNKNOWN if the conversion
    ///          wasn't possible.
    ///
    ///  \sa SDL_PixelFormatEnumToMasks()
    pub fn SDL_MasksToPixelFormatEnum(
        bpp: ::std::os::raw::c_int,
        Rmask: Uint32,
        Gmask: Uint32,
        Bmask: Uint32,
        Amask: Uint32,
    ) -> Uint32;
}
extern "C" {
    ///  \brief Create an SDL_PixelFormat structure from a pixel format enum.
    pub fn SDL_AllocFormat(pixel_format: Uint32) -> *mut SDL_PixelFormat;
}
extern "C" {
    ///  \brief Free an SDL_PixelFormat structure.
    pub fn SDL_FreeFormat(format: *mut SDL_PixelFormat);
}
extern "C" {
    ///  \brief Create a palette structure with the specified number of color
    ///         entries.
    ///
    ///  \return A new palette, or NULL if there wasn't enough memory.
    ///
    ///  \note The palette entries are initialized to white.
    ///
    ///  \sa SDL_FreePalette()
    pub fn SDL_AllocPalette(ncolors: ::std::os::raw::c_int) -> *mut SDL_Palette;
}
extern "C" {
    ///  \brief Set the palette for a pixel format structure.
    pub fn SDL_SetPixelFormatPalette(
        format: *mut SDL_PixelFormat,
        palette: *mut SDL_Palette,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Set a range of colors in a palette.
    ///
    ///  \param palette    The palette to modify.
    ///  \param colors     An array of colors to copy into the palette.
    ///  \param firstcolor The index of the first palette entry to modify.
    ///  \param ncolors    The number of entries to modify.
    ///
    ///  \return 0 on success, or -1 if not all of the colors could be set.
    pub fn SDL_SetPaletteColors(
        palette: *mut SDL_Palette,
        colors: *const SDL_Color,
        firstcolor: ::std::os::raw::c_int,
        ncolors: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Free a palette created with SDL_AllocPalette().
    ///
    ///  \sa SDL_AllocPalette()
    pub fn SDL_FreePalette(palette: *mut SDL_Palette);
}
extern "C" {
    ///  \brief Maps an RGB triple to an opaque pixel value for a given pixel format.
    ///
    ///  \sa SDL_MapRGBA
    pub fn SDL_MapRGB(format: *const SDL_PixelFormat, r: Uint8, g: Uint8, b: Uint8) -> Uint32;
}
extern "C" {
    ///  \brief Maps an RGBA quadruple to a pixel value for a given pixel format.
    ///
    ///  \sa SDL_MapRGB
    pub fn SDL_MapRGBA(
        format: *const SDL_PixelFormat,
        r: Uint8,
        g: Uint8,
        b: Uint8,
        a: Uint8,
    ) -> Uint32;
}
extern "C" {
    ///  \brief Get the RGB components from a pixel of the specified format.
    ///
    ///  \sa SDL_GetRGBA
    pub fn SDL_GetRGB(
        pixel: Uint32,
        format: *const SDL_PixelFormat,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
    );
}
extern "C" {
    ///  \brief Get the RGBA components from a pixel of the specified format.
    ///
    ///  \sa SDL_GetRGB
    pub fn SDL_GetRGBA(
        pixel: Uint32,
        format: *const SDL_PixelFormat,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
        a: *mut Uint8,
    );
}
extern "C" {
    ///  \brief Calculate a 256 entry gamma ramp for a gamma value.
    pub fn SDL_CalculateGammaRamp(gamma: f32, ramp: *mut Uint16);
}
///  \brief  The structure that defines a point
///
///  \sa SDL_EnclosePoints
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Point {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Point() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Point>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_Point))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Point>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_Point))
    );
}
///  \brief A rectangle, with the origin at the upper left.
///
///  \sa SDL_RectEmpty
///  \sa SDL_RectEquals
///  \sa SDL_HasIntersection
///  \sa SDL_IntersectRect
///  \sa SDL_UnionRect
///  \sa SDL_EnclosePoints
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Rect {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
    pub h: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Rect() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Rect>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_Rect))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Rect>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_Rect))
    );
}
extern "C" {
    ///  \brief Determine whether two rectangles intersect.
    ///
    ///  \return SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
    pub fn SDL_HasIntersection(A: *const SDL_Rect, B: *const SDL_Rect) -> SDL_bool;
}
extern "C" {
    ///  \brief Calculate the intersection of two rectangles.
    ///
    ///  \return SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
    pub fn SDL_IntersectRect(
        A: *const SDL_Rect,
        B: *const SDL_Rect,
        result: *mut SDL_Rect,
    ) -> SDL_bool;
}
extern "C" {
    ///  \brief Calculate the union of two rectangles.
    pub fn SDL_UnionRect(A: *const SDL_Rect, B: *const SDL_Rect, result: *mut SDL_Rect);
}
extern "C" {
    ///  \brief Calculate a minimal rectangle enclosing a set of points
    ///
    ///  \return SDL_TRUE if any points were within the clipping rect
    pub fn SDL_EnclosePoints(
        points: *const SDL_Point,
        count: ::std::os::raw::c_int,
        clip: *const SDL_Rect,
        result: *mut SDL_Rect,
    ) -> SDL_bool;
}
extern "C" {
    ///  \brief Calculate the intersection of a rectangle and line segment.
    ///
    ///  \return SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
    pub fn SDL_IntersectRectAndLine(
        rect: *const SDL_Rect,
        X1: *mut ::std::os::raw::c_int,
        Y1: *mut ::std::os::raw::c_int,
        X2: *mut ::std::os::raw::c_int,
        Y2: *mut ::std::os::raw::c_int,
    ) -> SDL_bool;
}
#[repr(u32)]
///  \brief The blend mode used in SDL_RenderCopy() and drawing operations.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_BlendMode {
    ///< no blending
    ///dstRGBA = srcRGBA
    SDL_BLENDMODE_NONE = 0,
    ///< alpha blending
    ///dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA))
    ///dstA = srcA + (dstA * (1-srcA))
    SDL_BLENDMODE_BLEND = 1,
    ///< additive blending
    ///dstRGB = (srcRGB * srcA) + dstRGB
    ///dstA = dstA
    SDL_BLENDMODE_ADD = 2,
    ///< color modulate
    ///dstRGB = srcRGB * dstRGB
    ///dstA = dstA
    SDL_BLENDMODE_MOD = 4,
}
/// \brief A collection of pixels used in software blitting.
///
/// \note  This structure should be treated as read-only, except for \c pixels,
///        which, if not NULL, contains the raw pixel data for the surface.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Surface {
    ///< Read-only
    pub flags: Uint32,
    ///< Read-only
    pub format: *mut SDL_PixelFormat,
    ///< Read-only
    pub w: ::std::os::raw::c_int,
    ///< Read-only
    pub h: ::std::os::raw::c_int,
    ///< Read-only
    pub pitch: ::std::os::raw::c_int,
    ///< Read-write
    pub pixels: *mut ::std::os::raw::c_void,
    ///< Read-write
    pub userdata: *mut ::std::os::raw::c_void,
    ///< Read-only
    pub locked: ::std::os::raw::c_int,
    ///< Read-only
    pub lock_data: *mut ::std::os::raw::c_void,
    ///< Read-only
    pub clip_rect: SDL_Rect,
    ///< Private
    pub map: *mut SDL_BlitMap,
    ///< Read-mostly
    pub refcount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Surface() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Surface>(),
        96usize,
        concat!("Size of: ", stringify!(SDL_Surface))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Surface>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Surface))
    );
}
/// \brief The type of function used for surface blitting functions.
pub type SDL_blit = ::std::option::Option<
    unsafe extern "C" fn(
        src: *mut SDL_Surface,
        srcrect: *mut SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    ///  Allocate and free an RGB surface.
    ///
    ///  If the depth is 4 or 8 bits, an empty palette is allocated for the surface.
    ///  If the depth is greater than 8 bits, the pixel format is set using the
    ///  flags '[RGB]mask'.
    ///
    ///  If the function runs out of memory, it will return NULL.
    ///
    ///  \param flags The \c flags are obsolete and should be set to 0.
    ///  \param width The width in pixels of the surface to create.
    ///  \param height The height in pixels of the surface to create.
    ///  \param depth The depth in bits of the surface to create.
    ///  \param Rmask The red mask of the surface to create.
    ///  \param Gmask The green mask of the surface to create.
    ///  \param Bmask The blue mask of the surface to create.
    ///  \param Amask The alpha mask of the surface to create.
    pub fn SDL_CreateRGBSurface(
        flags: Uint32,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
        Rmask: Uint32,
        Gmask: Uint32,
        Bmask: Uint32,
        Amask: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_CreateRGBSurfaceFrom(
        pixels: *mut ::std::os::raw::c_void,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        Rmask: Uint32,
        Gmask: Uint32,
        Bmask: Uint32,
        Amask: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_FreeSurface(surface: *mut SDL_Surface);
}
extern "C" {
    ///  \brief Set the palette used by a surface.
    ///
    ///  \return 0, or -1 if the surface format doesn't use a palette.
    ///
    ///  \note A single palette can be shared with many surfaces.
    pub fn SDL_SetSurfacePalette(
        surface: *mut SDL_Surface,
        palette: *mut SDL_Palette,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Sets up a surface for directly accessing the pixels.
    ///
    ///  Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write
    ///  to and read from \c surface->pixels, using the pixel format stored in
    ///  \c surface->format.  Once you are done accessing the surface, you should
    ///  use SDL_UnlockSurface() to release it.
    ///
    ///  Not all surfaces require locking.  If SDL_MUSTLOCK(surface) evaluates
    ///  to 0, then you can read and write to the surface at any time, and the
    ///  pixel format of the surface will not change.
    ///
    ///  No operating system or library calls should be made between lock/unlock
    ///  pairs, as critical system locks may be held during this time.
    ///
    ///  SDL_LockSurface() returns 0, or -1 if the surface couldn't be locked.
    ///
    ///  \sa SDL_UnlockSurface()
    pub fn SDL_LockSurface(surface: *mut SDL_Surface) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \sa SDL_LockSurface()
    pub fn SDL_UnlockSurface(surface: *mut SDL_Surface);
}
extern "C" {
    ///  Load a surface from a seekable SDL data stream (memory or file).
    ///
    ///  If \c freesrc is non-zero, the stream will be closed after being read.
    ///
    ///  The new surface should be freed with SDL_FreeSurface().
    ///
    ///  \return the new surface, or NULL if there was an error.
    pub fn SDL_LoadBMP_RW(src: *mut SDL_RWops, freesrc: ::std::os::raw::c_int) -> *mut SDL_Surface;
}
extern "C" {
    ///  Save a surface to a seekable SDL data stream (memory or file).
    ///
    ///  If \c freedst is non-zero, the stream will be closed after being written.
    ///
    ///  \return 0 if successful or -1 if there was an error.
    pub fn SDL_SaveBMP_RW(
        surface: *mut SDL_Surface,
        dst: *mut SDL_RWops,
        freedst: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Sets the RLE acceleration hint for a surface.
    ///
    ///  \return 0 on success, or -1 if the surface is not valid
    ///
    ///  \note If RLE is enabled, colorkey and alpha blending blits are much faster,
    ///        but the surface must be locked before directly accessing the pixels.
    pub fn SDL_SetSurfaceRLE(
        surface: *mut SDL_Surface,
        flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Sets the color key (transparent pixel) in a blittable surface.
    ///
    ///  \param surface The surface to update
    ///  \param flag Non-zero to enable colorkey and 0 to disable colorkey
    ///  \param key The transparent pixel in the native surface format
    ///
    ///  \return 0 on success, or -1 if the surface is not valid
    ///
    ///  You can pass SDL_RLEACCEL to enable RLE accelerated blits.
    pub fn SDL_SetColorKey(
        surface: *mut SDL_Surface,
        flag: ::std::os::raw::c_int,
        key: Uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Gets the color key (transparent pixel) in a blittable surface.
    ///
    ///  \param surface The surface to update
    ///  \param key A pointer filled in with the transparent pixel in the native
    ///             surface format
    ///
    ///  \return 0 on success, or -1 if the surface is not valid or colorkey is not
    ///          enabled.
    pub fn SDL_GetColorKey(surface: *mut SDL_Surface, key: *mut Uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Set an additional color value used in blit operations.
    ///
    ///  \param surface The surface to update.
    ///  \param r The red color value multiplied into blit operations.
    ///  \param g The green color value multiplied into blit operations.
    ///  \param b The blue color value multiplied into blit operations.
    ///
    ///  \return 0 on success, or -1 if the surface is not valid.
    ///
    ///  \sa SDL_GetSurfaceColorMod()
    pub fn SDL_SetSurfaceColorMod(
        surface: *mut SDL_Surface,
        r: Uint8,
        g: Uint8,
        b: Uint8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the additional color value used in blit operations.
    ///
    ///  \param surface The surface to query.
    ///  \param r A pointer filled in with the current red color value.
    ///  \param g A pointer filled in with the current green color value.
    ///  \param b A pointer filled in with the current blue color value.
    ///
    ///  \return 0 on success, or -1 if the surface is not valid.
    ///
    ///  \sa SDL_SetSurfaceColorMod()
    pub fn SDL_GetSurfaceColorMod(
        surface: *mut SDL_Surface,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Set an additional alpha value used in blit operations.
    ///
    ///  \param surface The surface to update.
    ///  \param alpha The alpha value multiplied into blit operations.
    ///
    ///  \return 0 on success, or -1 if the surface is not valid.
    ///
    ///  \sa SDL_GetSurfaceAlphaMod()
    pub fn SDL_SetSurfaceAlphaMod(surface: *mut SDL_Surface, alpha: Uint8)
        -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the additional alpha value used in blit operations.
    ///
    ///  \param surface The surface to query.
    ///  \param alpha A pointer filled in with the current alpha value.
    ///
    ///  \return 0 on success, or -1 if the surface is not valid.
    ///
    ///  \sa SDL_SetSurfaceAlphaMod()
    pub fn SDL_GetSurfaceAlphaMod(
        surface: *mut SDL_Surface,
        alpha: *mut Uint8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Set the blend mode used for blit operations.
    ///
    ///  \param surface The surface to update.
    ///  \param blendMode ::SDL_BlendMode to use for blit blending.
    ///
    ///  \return 0 on success, or -1 if the parameters are not valid.
    ///
    ///  \sa SDL_GetSurfaceBlendMode()
    pub fn SDL_SetSurfaceBlendMode(
        surface: *mut SDL_Surface,
        blendMode: SDL_BlendMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the blend mode used for blit operations.
    ///
    ///  \param surface   The surface to query.
    ///  \param blendMode A pointer filled in with the current blend mode.
    ///
    ///  \return 0 on success, or -1 if the surface is not valid.
    ///
    ///  \sa SDL_SetSurfaceBlendMode()
    pub fn SDL_GetSurfaceBlendMode(
        surface: *mut SDL_Surface,
        blendMode: *mut SDL_BlendMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Sets the clipping rectangle for the destination surface in a blit.
    ///
    ///  If the clip rectangle is NULL, clipping will be disabled.
    ///
    ///  If the clip rectangle doesn't intersect the surface, the function will
    ///  return SDL_FALSE and blits will be completely clipped.  Otherwise the
    ///  function returns SDL_TRUE and blits to the surface will be clipped to
    ///  the intersection of the surface area and the clipping rectangle.
    ///
    ///  Note that blits are automatically clipped to the edges of the source
    ///  and destination surfaces.
    pub fn SDL_SetClipRect(surface: *mut SDL_Surface, rect: *const SDL_Rect) -> SDL_bool;
}
extern "C" {
    ///  Gets the clipping rectangle for the destination surface in a blit.
    ///
    ///  \c rect must be a pointer to a valid rectangle which will be filled
    ///  with the correct values.
    pub fn SDL_GetClipRect(surface: *mut SDL_Surface, rect: *mut SDL_Rect);
}
extern "C" {
    ///  Creates a new surface of the specified format, and then copies and maps
    ///  the given surface to it so the blit of the converted surface will be as
    ///  fast as possible.  If this function fails, it returns NULL.
    ///
    ///  The \c flags parameter is passed to SDL_CreateRGBSurface() and has those
    ///  semantics.  You can also pass ::SDL_RLEACCEL in the flags parameter and
    ///  SDL will try to RLE accelerate colorkey and alpha blits in the resulting
    ///  surface.
    pub fn SDL_ConvertSurface(
        src: *mut SDL_Surface,
        fmt: *const SDL_PixelFormat,
        flags: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_ConvertSurfaceFormat(
        src: *mut SDL_Surface,
        pixel_format: Uint32,
        flags: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    /// \brief Copy a block of pixels of one format to another format
    ///
    ///  \return 0 on success, or -1 if there was an error
    pub fn SDL_ConvertPixels(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        src_format: Uint32,
        src: *const ::std::os::raw::c_void,
        src_pitch: ::std::os::raw::c_int,
        dst_format: Uint32,
        dst: *mut ::std::os::raw::c_void,
        dst_pitch: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Performs a fast fill of the given rectangle with \c color.
    ///
    ///  If \c rect is NULL, the whole surface will be filled with \c color.
    ///
    ///  The color should be a pixel of the format used by the surface, and
    ///  can be generated by the SDL_MapRGB() function.
    ///
    ///  \return 0 on success, or -1 on error.
    pub fn SDL_FillRect(
        dst: *mut SDL_Surface,
        rect: *const SDL_Rect,
        color: Uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_FillRects(
        dst: *mut SDL_Surface,
        rects: *const SDL_Rect,
        count: ::std::os::raw::c_int,
        color: Uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  This is the public blit function, SDL_BlitSurface(), and it performs
    ///  rectangle validation and clipping before passing it to SDL_LowerBlit()
    pub fn SDL_UpperBlit(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  This is a semi-private blit function and it performs low-level surface
    ///  blitting only.
    pub fn SDL_LowerBlit(
        src: *mut SDL_Surface,
        srcrect: *mut SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Perform a fast, low quality, stretch blit between two surfaces of the
    ///         same pixel format.
    ///
    ///  \note This function uses a static buffer, and is not thread-safe.
    pub fn SDL_SoftStretch(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  This is the public scaled blit function, SDL_BlitScaled(), and it performs
    ///  rectangle validation and clipping before passing it to SDL_LowerBlitScaled()
    pub fn SDL_UpperBlitScaled(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  This is a semi-private blit function and it performs low-level surface
    ///  scaled blitting only.
    pub fn SDL_LowerBlitScaled(
        src: *mut SDL_Surface,
        srcrect: *mut SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
///  \brief  The structure that defines a display mode
///
///  \sa SDL_GetNumDisplayModes()
///  \sa SDL_GetDisplayMode()
///  \sa SDL_GetDesktopDisplayMode()
///  \sa SDL_GetCurrentDisplayMode()
///  \sa SDL_GetClosestDisplayMode()
///  \sa SDL_SetWindowDisplayMode()
///  \sa SDL_GetWindowDisplayMode()
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_DisplayMode {
    ///< pixel format
    pub format: Uint32,
    ///< width
    pub w: ::std::os::raw::c_int,
    ///< height
    pub h: ::std::os::raw::c_int,
    ///< refresh rate (or zero for unspecified)
    pub refresh_rate: ::std::os::raw::c_int,
    ///< driver-specific data, initialize to 0
    pub driverdata: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SDL_DisplayMode() {
    assert_eq!(
        ::std::mem::size_of::<SDL_DisplayMode>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_DisplayMode))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_DisplayMode>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_DisplayMode))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Window {
    _unused: [u8; 0],
}
#[repr(u32)]
///  \brief The flags on a window
///
///  \sa SDL_GetWindowFlags()
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_WindowFlags {
    ///< fullscreen window
    SDL_WINDOW_FULLSCREEN = 1,
    ///< window usable with OpenGL context
    SDL_WINDOW_OPENGL = 2,
    ///< window is visible
    SDL_WINDOW_SHOWN = 4,
    ///< window is not visible
    SDL_WINDOW_HIDDEN = 8,
    ///< no window decoration
    SDL_WINDOW_BORDERLESS = 16,
    ///< window can be resized
    SDL_WINDOW_RESIZABLE = 32,
    ///< window is minimized
    SDL_WINDOW_MINIMIZED = 64,
    ///< window is maximized
    SDL_WINDOW_MAXIMIZED = 128,
    ///< window has grabbed input focus
    SDL_WINDOW_INPUT_GRABBED = 256,
    ///< window has input focus
    SDL_WINDOW_INPUT_FOCUS = 512,
    ///< window has mouse focus
    SDL_WINDOW_MOUSE_FOCUS = 1024,
    SDL_WINDOW_FULLSCREEN_DESKTOP = 4097,
    ///< window not created by SDL
    SDL_WINDOW_FOREIGN = 2048,
    ///< window should be created in high-DPI mode if supported
    SDL_WINDOW_ALLOW_HIGHDPI = 8192,
}
#[repr(u32)]
///  \brief Event subtype for window events
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_WindowEventID {
    ///< Never used
    SDL_WINDOWEVENT_NONE = 0,
    ///< Window has been shown
    SDL_WINDOWEVENT_SHOWN = 1,
    ///< Window has been hidden
    SDL_WINDOWEVENT_HIDDEN = 2,
    ///< Window has been exposed and should be
    ///redrawn
    SDL_WINDOWEVENT_EXPOSED = 3,
    ///< Window has been moved to data1, data2
    SDL_WINDOWEVENT_MOVED = 4,
    ///< Window has been resized to data1xdata2
    SDL_WINDOWEVENT_RESIZED = 5,
    ///< The window size has changed, either as a result of an API call or through the system or user changing the window size.
    SDL_WINDOWEVENT_SIZE_CHANGED = 6,
    ///< Window has been minimized
    SDL_WINDOWEVENT_MINIMIZED = 7,
    ///< Window has been maximized
    SDL_WINDOWEVENT_MAXIMIZED = 8,
    ///< Window has been restored to normal size
    ///and position
    SDL_WINDOWEVENT_RESTORED = 9,
    ///< Window has gained mouse focus
    SDL_WINDOWEVENT_ENTER = 10,
    ///< Window has lost mouse focus
    SDL_WINDOWEVENT_LEAVE = 11,
    ///< Window has gained keyboard focus
    SDL_WINDOWEVENT_FOCUS_GAINED = 12,
    ///< Window has lost keyboard focus
    SDL_WINDOWEVENT_FOCUS_LOST = 13,
    ///< The window manager requests that the
    ///window be closed
    SDL_WINDOWEVENT_CLOSE = 14,
}
///  \brief An opaque handle to an OpenGL context.
pub type SDL_GLContext = *mut ::std::os::raw::c_void;
#[repr(u32)]
///  \brief OpenGL configuration attributes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GLattr {
    SDL_GL_RED_SIZE = 0,
    SDL_GL_GREEN_SIZE = 1,
    SDL_GL_BLUE_SIZE = 2,
    SDL_GL_ALPHA_SIZE = 3,
    SDL_GL_BUFFER_SIZE = 4,
    SDL_GL_DOUBLEBUFFER = 5,
    SDL_GL_DEPTH_SIZE = 6,
    SDL_GL_STENCIL_SIZE = 7,
    SDL_GL_ACCUM_RED_SIZE = 8,
    SDL_GL_ACCUM_GREEN_SIZE = 9,
    SDL_GL_ACCUM_BLUE_SIZE = 10,
    SDL_GL_ACCUM_ALPHA_SIZE = 11,
    SDL_GL_STEREO = 12,
    SDL_GL_MULTISAMPLEBUFFERS = 13,
    SDL_GL_MULTISAMPLESAMPLES = 14,
    SDL_GL_ACCELERATED_VISUAL = 15,
    SDL_GL_RETAINED_BACKING = 16,
    SDL_GL_CONTEXT_MAJOR_VERSION = 17,
    SDL_GL_CONTEXT_MINOR_VERSION = 18,
    SDL_GL_CONTEXT_EGL = 19,
    SDL_GL_CONTEXT_FLAGS = 20,
    SDL_GL_CONTEXT_PROFILE_MASK = 21,
    SDL_GL_SHARE_WITH_CURRENT_CONTEXT = 22,
    SDL_GL_FRAMEBUFFER_SRGB_CAPABLE = 23,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GLprofile {
    SDL_GL_CONTEXT_PROFILE_CORE = 1,
    SDL_GL_CONTEXT_PROFILE_COMPATIBILITY = 2,
    SDL_GL_CONTEXT_PROFILE_ES = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GLcontextFlag {
    SDL_GL_CONTEXT_DEBUG_FLAG = 1,
    SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG = 2,
    SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG = 4,
    SDL_GL_CONTEXT_RESET_ISOLATION_FLAG = 8,
}
extern "C" {
    ///  \brief Get the number of video drivers compiled into SDL
    ///
    ///  \sa SDL_GetVideoDriver()
    pub fn SDL_GetNumVideoDrivers() -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the name of a built in video driver.
    ///
    ///  \note The video drivers are presented in the order in which they are
    ///        normally checked during initialization.
    ///
    ///  \sa SDL_GetNumVideoDrivers()
    pub fn SDL_GetVideoDriver(index: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    ///  \brief Initialize the video subsystem, optionally specifying a video driver.
    ///
    ///  \param driver_name Initialize a specific driver by name, or NULL for the
    ///                     default video driver.
    ///
    ///  \return 0 on success, -1 on error
    ///
    ///  This function initializes the video subsystem; setting up a connection
    ///  to the window manager, etc, and determines the available display modes
    ///  and pixel formats, but does not initialize a window or graphics mode.
    ///
    ///  \sa SDL_VideoQuit()
    pub fn SDL_VideoInit(driver_name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Shuts down the video subsystem.
    ///
    ///  This function closes all windows, and restores the original video mode.
    ///
    ///  \sa SDL_VideoInit()
    pub fn SDL_VideoQuit();
}
extern "C" {
    ///  \brief Returns the name of the currently initialized video driver.
    ///
    ///  \return The name of the current video driver or NULL if no driver
    ///          has been initialized
    ///
    ///  \sa SDL_GetNumVideoDrivers()
    ///  \sa SDL_GetVideoDriver()
    pub fn SDL_GetCurrentVideoDriver() -> *const ::std::os::raw::c_char;
}
extern "C" {
    ///  \brief Returns the number of available video displays.
    ///
    ///  \sa SDL_GetDisplayBounds()
    pub fn SDL_GetNumVideoDisplays() -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the name of a display in UTF-8 encoding
    ///
    ///  \return The name of a display, or NULL for an invalid display index.
    ///
    ///  \sa SDL_GetNumVideoDisplays()
    pub fn SDL_GetDisplayName(displayIndex: ::std::os::raw::c_int)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    ///  \brief Get the desktop area represented by a display, with the primary
    ///         display located at 0,0
    ///
    ///  \return 0 on success, or -1 if the index is out of range.
    ///
    ///  \sa SDL_GetNumVideoDisplays()
    pub fn SDL_GetDisplayBounds(
        displayIndex: ::std::os::raw::c_int,
        rect: *mut SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Returns the number of available display modes.
    ///
    ///  \sa SDL_GetDisplayMode()
    pub fn SDL_GetNumDisplayModes(displayIndex: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Fill in information about a specific display mode.
    ///
    ///  \note The display modes are sorted in this priority:
    ///        \li bits per pixel -> more colors to fewer colors
    ///        \li width -> largest to smallest
    ///        \li height -> largest to smallest
    ///        \li refresh rate -> highest to lowest
    ///
    ///  \sa SDL_GetNumDisplayModes()
    pub fn SDL_GetDisplayMode(
        displayIndex: ::std::os::raw::c_int,
        modeIndex: ::std::os::raw::c_int,
        mode: *mut SDL_DisplayMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Fill in information about the desktop display mode.
    pub fn SDL_GetDesktopDisplayMode(
        displayIndex: ::std::os::raw::c_int,
        mode: *mut SDL_DisplayMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Fill in information about the current display mode.
    pub fn SDL_GetCurrentDisplayMode(
        displayIndex: ::std::os::raw::c_int,
        mode: *mut SDL_DisplayMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the closest match to the requested display mode.
    ///
    ///  \param displayIndex The index of display from which mode should be queried.
    ///  \param mode The desired display mode
    ///  \param closest A pointer to a display mode to be filled in with the closest
    ///                 match of the available display modes.
    ///
    ///  \return The passed in value \c closest, or NULL if no matching video mode
    ///          was available.
    ///
    ///  The available display modes are scanned, and \c closest is filled in with the
    ///  closest mode matching the requested mode and returned.  The mode format and
    ///  refresh_rate default to the desktop mode if they are 0.  The modes are
    ///  scanned with size being first priority, format being second priority, and
    ///  finally checking the refresh_rate.  If all the available modes are too
    ///  small, then NULL is returned.
    ///
    ///  \sa SDL_GetNumDisplayModes()
    ///  \sa SDL_GetDisplayMode()
    pub fn SDL_GetClosestDisplayMode(
        displayIndex: ::std::os::raw::c_int,
        mode: *const SDL_DisplayMode,
        closest: *mut SDL_DisplayMode,
    ) -> *mut SDL_DisplayMode;
}
extern "C" {
    ///  \brief Get the display index associated with a window.
    ///
    ///  \return the display index of the display containing the center of the
    ///          window, or -1 on error.
    pub fn SDL_GetWindowDisplayIndex(window: *mut SDL_Window) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Set the display mode used when a fullscreen window is visible.
    ///
    ///  By default the window's dimensions and the desktop format and refresh rate
    ///  are used.
    ///
    ///  \param window The window for which the display mode should be set.
    ///  \param mode The mode to use, or NULL for the default mode.
    ///
    ///  \return 0 on success, or -1 if setting the display mode failed.
    ///
    ///  \sa SDL_GetWindowDisplayMode()
    ///  \sa SDL_SetWindowFullscreen()
    pub fn SDL_SetWindowDisplayMode(
        window: *mut SDL_Window,
        mode: *const SDL_DisplayMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Fill in information about the display mode used when a fullscreen
    ///         window is visible.
    ///
    ///  \sa SDL_SetWindowDisplayMode()
    ///  \sa SDL_SetWindowFullscreen()
    pub fn SDL_GetWindowDisplayMode(
        window: *mut SDL_Window,
        mode: *mut SDL_DisplayMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the pixel format associated with the window.
    pub fn SDL_GetWindowPixelFormat(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
    ///  \brief Create a window with the specified position, dimensions, and flags.
    ///
    ///  \param title The title of the window, in UTF-8 encoding.
    ///  \param x     The x position of the window, ::SDL_WINDOWPOS_CENTERED, or
    ///               ::SDL_WINDOWPOS_UNDEFINED.
    ///  \param y     The y position of the window, ::SDL_WINDOWPOS_CENTERED, or
    ///               ::SDL_WINDOWPOS_UNDEFINED.
    ///  \param w     The width of the window.
    ///  \param h     The height of the window.
    ///  \param flags The flags for the window, a mask of any of the following:
    ///               ::SDL_WINDOW_FULLSCREEN,    ::SDL_WINDOW_OPENGL,
    ///               ::SDL_WINDOW_HIDDEN,        ::SDL_WINDOW_BORDERLESS,
    ///               ::SDL_WINDOW_RESIZABLE,     ::SDL_WINDOW_MAXIMIZED,
    ///               ::SDL_WINDOW_MINIMIZED,     ::SDL_WINDOW_INPUT_GRABBED,
    ///               ::SDL_WINDOW_ALLOW_HIGHDPI.
    ///
    ///  \return The id of the window created, or zero if window creation failed.
    ///
    ///  \sa SDL_DestroyWindow()
    pub fn SDL_CreateWindow(
        title: *const ::std::os::raw::c_char,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        flags: Uint32,
    ) -> *mut SDL_Window;
}
extern "C" {
    ///  \brief Create an SDL window from an existing native window.
    ///
    ///  \param data A pointer to driver-dependent window creation data
    ///
    ///  \return The id of the window created, or zero if window creation failed.
    ///
    ///  \sa SDL_DestroyWindow()
    pub fn SDL_CreateWindowFrom(data: *const ::std::os::raw::c_void) -> *mut SDL_Window;
}
extern "C" {
    ///  \brief Get the numeric ID of a window, for logging purposes.
    pub fn SDL_GetWindowID(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
    ///  \brief Get a window from a stored ID, or NULL if it doesn't exist.
    pub fn SDL_GetWindowFromID(id: Uint32) -> *mut SDL_Window;
}
extern "C" {
    ///  \brief Get the window flags.
    pub fn SDL_GetWindowFlags(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
    ///  \brief Set the title of a window, in UTF-8 format.
    ///
    ///  \sa SDL_GetWindowTitle()
    pub fn SDL_SetWindowTitle(window: *mut SDL_Window, title: *const ::std::os::raw::c_char);
}
extern "C" {
    ///  \brief Get the title of a window, in UTF-8 format.
    ///
    ///  \sa SDL_SetWindowTitle()
    pub fn SDL_GetWindowTitle(window: *mut SDL_Window) -> *const ::std::os::raw::c_char;
}
extern "C" {
    ///  \brief Set the icon for a window.
    ///
    ///  \param window The window for which the icon should be set.
    ///  \param icon The icon for the window.
    pub fn SDL_SetWindowIcon(window: *mut SDL_Window, icon: *mut SDL_Surface);
}
extern "C" {
    ///  \brief Associate an arbitrary named pointer with a window.
    ///
    ///  \param window   The window to associate with the pointer.
    ///  \param name     The name of the pointer.
    ///  \param userdata The associated pointer.
    ///
    ///  \return The previous value associated with 'name'
    ///
    ///  \note The name is case-sensitive.
    ///
    ///  \sa SDL_GetWindowData()
    pub fn SDL_SetWindowData(
        window: *mut SDL_Window,
        name: *const ::std::os::raw::c_char,
        userdata: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    ///  \brief Retrieve the data pointer associated with a window.
    ///
    ///  \param window   The window to query.
    ///  \param name     The name of the pointer.
    ///
    ///  \return The value associated with 'name'
    ///
    ///  \sa SDL_SetWindowData()
    pub fn SDL_GetWindowData(
        window: *mut SDL_Window,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    ///  \brief Set the position of a window.
    ///
    ///  \param window   The window to reposition.
    ///  \param x        The x coordinate of the window, ::SDL_WINDOWPOS_CENTERED, or
    ///::SDL_WINDOWPOS_UNDEFINED.
    ///  \param y        The y coordinate of the window, ::SDL_WINDOWPOS_CENTERED, or
    ///::SDL_WINDOWPOS_UNDEFINED.
    ///
    ///  \note The window coordinate origin is the upper left of the display.
    ///
    ///  \sa SDL_GetWindowPosition()
    pub fn SDL_SetWindowPosition(
        window: *mut SDL_Window,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
extern "C" {
    ///  \brief Get the position of a window.
    ///
    ///  \param window   The window to query.
    ///  \param x        Pointer to variable for storing the x position, may be NULL
    ///  \param y        Pointer to variable for storing the y position, may be NULL
    ///
    ///  \sa SDL_SetWindowPosition()
    pub fn SDL_GetWindowPosition(
        window: *mut SDL_Window,
        x: *mut ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    ///  \brief Set the size of a window's client area.
    ///
    ///  \param window   The window to resize.
    ///  \param w        The width of the window, must be >0
    ///  \param h        The height of the window, must be >0
    ///
    ///  \note You can't change the size of a fullscreen window, it automatically
    ///        matches the size of the display mode.
    ///
    ///  \sa SDL_GetWindowSize()
    pub fn SDL_SetWindowSize(
        window: *mut SDL_Window,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    );
}
extern "C" {
    ///  \brief Get the size of a window's client area.
    ///
    ///  \param window   The window to query.
    ///  \param w        Pointer to variable for storing the width, may be NULL
    ///  \param h        Pointer to variable for storing the height, may be NULL
    ///
    ///  \sa SDL_SetWindowSize()
    pub fn SDL_GetWindowSize(
        window: *mut SDL_Window,
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    ///  \brief Set the minimum size of a window's client area.
    ///
    ///  \param window    The window to set a new minimum size.
    ///  \param min_w     The minimum width of the window, must be >0
    ///  \param min_h     The minimum height of the window, must be >0
    ///
    ///  \note You can't change the minimum size of a fullscreen window, it
    ///        automatically matches the size of the display mode.
    ///
    ///  \sa SDL_GetWindowMinimumSize()
    ///  \sa SDL_SetWindowMaximumSize()
    pub fn SDL_SetWindowMinimumSize(
        window: *mut SDL_Window,
        min_w: ::std::os::raw::c_int,
        min_h: ::std::os::raw::c_int,
    );
}
extern "C" {
    ///  \brief Get the minimum size of a window's client area.
    ///
    ///  \param window   The window to query.
    ///  \param w        Pointer to variable for storing the minimum width, may be NULL
    ///  \param h        Pointer to variable for storing the minimum height, may be NULL
    ///
    ///  \sa SDL_GetWindowMaximumSize()
    ///  \sa SDL_SetWindowMinimumSize()
    pub fn SDL_GetWindowMinimumSize(
        window: *mut SDL_Window,
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    ///  \brief Set the maximum size of a window's client area.
    ///
    ///  \param window    The window to set a new maximum size.
    ///  \param max_w     The maximum width of the window, must be >0
    ///  \param max_h     The maximum height of the window, must be >0
    ///
    ///  \note You can't change the maximum size of a fullscreen window, it
    ///        automatically matches the size of the display mode.
    ///
    ///  \sa SDL_GetWindowMaximumSize()
    ///  \sa SDL_SetWindowMinimumSize()
    pub fn SDL_SetWindowMaximumSize(
        window: *mut SDL_Window,
        max_w: ::std::os::raw::c_int,
        max_h: ::std::os::raw::c_int,
    );
}
extern "C" {
    ///  \brief Get the maximum size of a window's client area.
    ///
    ///  \param window   The window to query.
    ///  \param w        Pointer to variable for storing the maximum width, may be NULL
    ///  \param h        Pointer to variable for storing the maximum height, may be NULL
    ///
    ///  \sa SDL_GetWindowMinimumSize()
    ///  \sa SDL_SetWindowMaximumSize()
    pub fn SDL_GetWindowMaximumSize(
        window: *mut SDL_Window,
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    ///  \brief Set the border state of a window.
    ///
    ///  This will add or remove the window's SDL_WINDOW_BORDERLESS flag and
    ///  add or remove the border from the actual window. This is a no-op if the
    ///  window's border already matches the requested state.
    ///
    ///  \param window The window of which to change the border state.
    ///  \param bordered SDL_FALSE to remove border, SDL_TRUE to add border.
    ///
    ///  \note You can't change the border state of a fullscreen window.
    ///
    ///  \sa SDL_GetWindowFlags()
    pub fn SDL_SetWindowBordered(window: *mut SDL_Window, bordered: SDL_bool);
}
extern "C" {
    ///  \brief Show a window.
    ///
    ///  \sa SDL_HideWindow()
    pub fn SDL_ShowWindow(window: *mut SDL_Window);
}
extern "C" {
    ///  \brief Hide a window.
    ///
    ///  \sa SDL_ShowWindow()
    pub fn SDL_HideWindow(window: *mut SDL_Window);
}
extern "C" {
    ///  \brief Raise a window above other windows and set the input focus.
    pub fn SDL_RaiseWindow(window: *mut SDL_Window);
}
extern "C" {
    ///  \brief Make a window as large as possible.
    ///
    ///  \sa SDL_RestoreWindow()
    pub fn SDL_MaximizeWindow(window: *mut SDL_Window);
}
extern "C" {
    ///  \brief Minimize a window to an iconic representation.
    ///
    ///  \sa SDL_RestoreWindow()
    pub fn SDL_MinimizeWindow(window: *mut SDL_Window);
}
extern "C" {
    ///  \brief Restore the size and position of a minimized or maximized window.
    ///
    ///  \sa SDL_MaximizeWindow()
    ///  \sa SDL_MinimizeWindow()
    pub fn SDL_RestoreWindow(window: *mut SDL_Window);
}
extern "C" {
    ///  \brief Set a window's fullscreen state.
    ///
    ///  \return 0 on success, or -1 if setting the display mode failed.
    ///
    ///  \sa SDL_SetWindowDisplayMode()
    ///  \sa SDL_GetWindowDisplayMode()
    pub fn SDL_SetWindowFullscreen(window: *mut SDL_Window, flags: Uint32)
        -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the SDL surface associated with the window.
    ///
    ///  \return The window's framebuffer surface, or NULL on error.
    ///
    ///  A new surface will be created with the optimal format for the window,
    ///  if necessary. This surface will be freed when the window is destroyed.
    ///
    ///  \note You may not combine this with 3D or the rendering API on this window.
    ///
    ///  \sa SDL_UpdateWindowSurface()
    ///  \sa SDL_UpdateWindowSurfaceRects()
    pub fn SDL_GetWindowSurface(window: *mut SDL_Window) -> *mut SDL_Surface;
}
extern "C" {
    ///  \brief Copy the window surface to the screen.
    ///
    ///  \return 0 on success, or -1 on error.
    ///
    ///  \sa SDL_GetWindowSurface()
    ///  \sa SDL_UpdateWindowSurfaceRects()
    pub fn SDL_UpdateWindowSurface(window: *mut SDL_Window) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Copy a number of rectangles on the window surface to the screen.
    ///
    ///  \return 0 on success, or -1 on error.
    ///
    ///  \sa SDL_GetWindowSurface()
    ///  \sa SDL_UpdateWindowSurfaceRect()
    pub fn SDL_UpdateWindowSurfaceRects(
        window: *mut SDL_Window,
        rects: *const SDL_Rect,
        numrects: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Set a window's input grab mode.
    ///
    ///  \param window The window for which the input grab mode should be set.
    ///  \param grabbed This is SDL_TRUE to grab input, and SDL_FALSE to release input.
    ///
    ///  \sa SDL_GetWindowGrab()
    pub fn SDL_SetWindowGrab(window: *mut SDL_Window, grabbed: SDL_bool);
}
extern "C" {
    ///  \brief Get a window's input grab mode.
    ///
    ///  \return This returns SDL_TRUE if input is grabbed, and SDL_FALSE otherwise.
    ///
    ///  \sa SDL_SetWindowGrab()
    pub fn SDL_GetWindowGrab(window: *mut SDL_Window) -> SDL_bool;
}
extern "C" {
    ///  \brief Set the brightness (gamma correction) for a window.
    ///
    ///  \return 0 on success, or -1 if setting the brightness isn't supported.
    ///
    ///  \sa SDL_GetWindowBrightness()
    ///  \sa SDL_SetWindowGammaRamp()
    pub fn SDL_SetWindowBrightness(
        window: *mut SDL_Window,
        brightness: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the brightness (gamma correction) for a window.
    ///
    ///  \return The last brightness value passed to SDL_SetWindowBrightness()
    ///
    ///  \sa SDL_SetWindowBrightness()
    pub fn SDL_GetWindowBrightness(window: *mut SDL_Window) -> f32;
}
extern "C" {
    ///  \brief Set the gamma ramp for a window.
    ///
    ///  \param window The window for which the gamma ramp should be set.
    ///  \param red The translation table for the red channel, or NULL.
    ///  \param green The translation table for the green channel, or NULL.
    ///  \param blue The translation table for the blue channel, or NULL.
    ///
    ///  \return 0 on success, or -1 if gamma ramps are unsupported.
    ///
    ///  Set the gamma translation table for the red, green, and blue channels
    ///  of the video hardware.  Each table is an array of 256 16-bit quantities,
    ///  representing a mapping between the input and output for that channel.
    ///  The input is the index into the array, and the output is the 16-bit
    ///  gamma value at that index, scaled to the output color precision.
    ///
    ///  \sa SDL_GetWindowGammaRamp()
    pub fn SDL_SetWindowGammaRamp(
        window: *mut SDL_Window,
        red: *const Uint16,
        green: *const Uint16,
        blue: *const Uint16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the gamma ramp for a window.
    ///
    ///  \param window The window from which the gamma ramp should be queried.
    ///  \param red   A pointer to a 256 element array of 16-bit quantities to hold
    ///               the translation table for the red channel, or NULL.
    ///  \param green A pointer to a 256 element array of 16-bit quantities to hold
    ///               the translation table for the green channel, or NULL.
    ///  \param blue  A pointer to a 256 element array of 16-bit quantities to hold
    ///               the translation table for the blue channel, or NULL.
    ///
    ///  \return 0 on success, or -1 if gamma ramps are unsupported.
    ///
    ///  \sa SDL_SetWindowGammaRamp()
    pub fn SDL_GetWindowGammaRamp(
        window: *mut SDL_Window,
        red: *mut Uint16,
        green: *mut Uint16,
        blue: *mut Uint16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Destroy a window.
    pub fn SDL_DestroyWindow(window: *mut SDL_Window);
}
extern "C" {
    ///  \brief Returns whether the screensaver is currently enabled (default on).
    ///
    ///  \sa SDL_EnableScreenSaver()
    ///  \sa SDL_DisableScreenSaver()
    pub fn SDL_IsScreenSaverEnabled() -> SDL_bool;
}
extern "C" {
    ///  \brief Allow the screen to be blanked by a screensaver
    ///
    ///  \sa SDL_IsScreenSaverEnabled()
    ///  \sa SDL_DisableScreenSaver()
    pub fn SDL_EnableScreenSaver();
}
extern "C" {
    ///  \brief Prevent the screen from being blanked by a screensaver
    ///
    ///  \sa SDL_IsScreenSaverEnabled()
    ///  \sa SDL_EnableScreenSaver()
    pub fn SDL_DisableScreenSaver();
}
extern "C" {
    ///  \brief Dynamically load an OpenGL library.
    ///
    ///  \param path The platform dependent OpenGL library name, or NULL to open the
    ///              default OpenGL library.
    ///
    ///  \return 0 on success, or -1 if the library couldn't be loaded.
    ///
    ///  This should be done after initializing the video driver, but before
    ///  creating any OpenGL windows.  If no OpenGL library is loaded, the default
    ///  library will be loaded upon creation of the first OpenGL window.
    ///
    ///  \note If you do this, you need to retrieve all of the GL functions used in
    ///        your program from the dynamic library using SDL_GL_GetProcAddress().
    ///
    ///  \sa SDL_GL_GetProcAddress()
    ///  \sa SDL_GL_UnloadLibrary()
    pub fn SDL_GL_LoadLibrary(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the address of an OpenGL function.
    pub fn SDL_GL_GetProcAddress(
        proc_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    ///  \brief Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().
    ///
    ///  \sa SDL_GL_LoadLibrary()
    pub fn SDL_GL_UnloadLibrary();
}
extern "C" {
    ///  \brief Return true if an OpenGL extension is supported for the current
    ///         context.
    pub fn SDL_GL_ExtensionSupported(extension: *const ::std::os::raw::c_char) -> SDL_bool;
}
extern "C" {
    ///  \brief Reset all previously set OpenGL context attributes to their default values
    pub fn SDL_GL_ResetAttributes();
}
extern "C" {
    ///  \brief Set an OpenGL window attribute before window creation.
    pub fn SDL_GL_SetAttribute(
        attr: SDL_GLattr,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the actual value for an attribute from the current context.
    pub fn SDL_GL_GetAttribute(
        attr: SDL_GLattr,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Create an OpenGL context for use with an OpenGL window, and make it
    ///         current.
    ///
    ///  \sa SDL_GL_DeleteContext()
    pub fn SDL_GL_CreateContext(window: *mut SDL_Window) -> SDL_GLContext;
}
extern "C" {
    ///  \brief Set up an OpenGL context for rendering into an OpenGL window.
    ///
    ///  \note The context must have been created with a compatible window.
    pub fn SDL_GL_MakeCurrent(
        window: *mut SDL_Window,
        context: SDL_GLContext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the currently active OpenGL window.
    pub fn SDL_GL_GetCurrentWindow() -> *mut SDL_Window;
}
extern "C" {
    ///  \brief Get the currently active OpenGL context.
    pub fn SDL_GL_GetCurrentContext() -> SDL_GLContext;
}
extern "C" {
    ///  \brief Get the size of a window's underlying drawable (for use with glViewport).
    ///
    ///  \param window   Window from which the drawable size should be queried
    ///  \param w        Pointer to variable for storing the width, may be NULL
    ///  \param h        Pointer to variable for storing the height, may be NULL
    ///
    /// This may differ from SDL_GetWindowSize if we're rendering to a high-DPI
    /// drawable, i.e. the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a
    /// platform with high-DPI support (Apple calls this "Retina"), and not disabled
    /// by the SDL_HINT_VIDEO_HIGHDPI_DISABLED hint.
    ///
    ///  \sa SDL_GetWindowSize()
    ///  \sa SDL_CreateWindow()
    pub fn SDL_GL_GetDrawableSize(
        window: *mut SDL_Window,
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    ///  \brief Set the swap interval for the current OpenGL context.
    ///
    ///  \param interval 0 for immediate updates, 1 for updates synchronized with the
    ///                  vertical retrace. If the system supports it, you may
    ///                  specify -1 to allow late swaps to happen immediately
    ///                  instead of waiting for the next retrace.
    ///
    ///  \return 0 on success, or -1 if setting the swap interval is not supported.
    ///
    ///  \sa SDL_GL_GetSwapInterval()
    pub fn SDL_GL_SetSwapInterval(interval: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the swap interval for the current OpenGL context.
    ///
    ///  \return 0 if there is no vertical retrace synchronization, 1 if the buffer
    ///          swap is synchronized with the vertical retrace, and -1 if late
    ///          swaps happen immediately instead of waiting for the next retrace.
    ///          If the system can't determine the swap interval, or there isn't a
    ///          valid current context, this will return 0 as a safe default.
    ///
    ///  \sa SDL_GL_SetSwapInterval()
    pub fn SDL_GL_GetSwapInterval() -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Swap the OpenGL buffers for a window, if double-buffering is
    ///        supported.
    pub fn SDL_GL_SwapWindow(window: *mut SDL_Window);
}
extern "C" {
    ///  \brief Delete an OpenGL context.
    ///
    ///  \sa SDL_GL_CreateContext()
    pub fn SDL_GL_DeleteContext(context: SDL_GLContext);
}
#[repr(u32)]
///  \brief The SDL keyboard scancode representation.
///
///  Values of this type are used to represent keyboard keys, among other places
///  in the \link SDL_Keysym::scancode key.keysym.scancode \endlink field of the
///  SDL_Event structure.
///
///  The values in this enumeration are based on the USB usage page standard:
///  http://www.usb.org/developers/devclass_docs/Hut1_12v2.pdf
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_Scancode {
    SDL_SCANCODE_UNKNOWN = 0,
    SDL_SCANCODE_A = 4,
    SDL_SCANCODE_B = 5,
    SDL_SCANCODE_C = 6,
    SDL_SCANCODE_D = 7,
    SDL_SCANCODE_E = 8,
    SDL_SCANCODE_F = 9,
    SDL_SCANCODE_G = 10,
    SDL_SCANCODE_H = 11,
    SDL_SCANCODE_I = 12,
    SDL_SCANCODE_J = 13,
    SDL_SCANCODE_K = 14,
    SDL_SCANCODE_L = 15,
    SDL_SCANCODE_M = 16,
    SDL_SCANCODE_N = 17,
    SDL_SCANCODE_O = 18,
    SDL_SCANCODE_P = 19,
    SDL_SCANCODE_Q = 20,
    SDL_SCANCODE_R = 21,
    SDL_SCANCODE_S = 22,
    SDL_SCANCODE_T = 23,
    SDL_SCANCODE_U = 24,
    SDL_SCANCODE_V = 25,
    SDL_SCANCODE_W = 26,
    SDL_SCANCODE_X = 27,
    SDL_SCANCODE_Y = 28,
    SDL_SCANCODE_Z = 29,
    SDL_SCANCODE_1 = 30,
    SDL_SCANCODE_2 = 31,
    SDL_SCANCODE_3 = 32,
    SDL_SCANCODE_4 = 33,
    SDL_SCANCODE_5 = 34,
    SDL_SCANCODE_6 = 35,
    SDL_SCANCODE_7 = 36,
    SDL_SCANCODE_8 = 37,
    SDL_SCANCODE_9 = 38,
    SDL_SCANCODE_0 = 39,
    SDL_SCANCODE_RETURN = 40,
    SDL_SCANCODE_ESCAPE = 41,
    SDL_SCANCODE_BACKSPACE = 42,
    SDL_SCANCODE_TAB = 43,
    SDL_SCANCODE_SPACE = 44,
    SDL_SCANCODE_MINUS = 45,
    SDL_SCANCODE_EQUALS = 46,
    SDL_SCANCODE_LEFTBRACKET = 47,
    SDL_SCANCODE_RIGHTBRACKET = 48,
    ///< Located at the lower left of the return
    ///   key on ISO keyboards and at the right end
    ///   of the QWERTY row on ANSI keyboards.
    ///   Produces REVERSE SOLIDUS (backslash) and
    ///   VERTICAL LINE in a US layout, REVERSE
    ///   SOLIDUS and VERTICAL LINE in a UK Mac
    ///   layout, NUMBER SIGN and TILDE in a UK
    ///   Windows layout, DOLLAR SIGN and POUND SIGN
    ///   in a Swiss German layout, NUMBER SIGN and
    ///   APOSTROPHE in a German layout, GRAVE
    ///   ACCENT and POUND SIGN in a French Mac
    ///   layout, and ASTERISK and MICRO SIGN in a
    ///   French Windows layout.
    SDL_SCANCODE_BACKSLASH = 49,
    ///< ISO USB keyboards actually use this code
    ///   instead of 49 for the same key, but all
    ///   OSes I've seen treat the two codes
    ///   identically. So, as an implementor, unless
    ///   your keyboard generates both of those
    ///   codes and your OS treats them differently,
    ///   you should generate SDL_SCANCODE_BACKSLASH
    ///   instead of this code. As a user, you
    ///   should not rely on this code because SDL
    ///   will never generate it with most (all?)
    ///   keyboards.
    SDL_SCANCODE_NONUSHASH = 50,
    SDL_SCANCODE_SEMICOLON = 51,
    SDL_SCANCODE_APOSTROPHE = 52,
    ///< Located in the top left corner (on both ANSI
    ///   and ISO keyboards). Produces GRAVE ACCENT and
    ///   TILDE in a US Windows layout and in US and UK
    ///   Mac layouts on ANSI keyboards, GRAVE ACCENT
    ///   and NOT SIGN in a UK Windows layout, SECTION
    ///   SIGN and PLUS-MINUS SIGN in US and UK Mac
    ///   layouts on ISO keyboards, SECTION SIGN and
    ///   DEGREE SIGN in a Swiss German layout (Mac:
    ///   only on ISO keyboards), CIRCUMFLEX ACCENT and
    ///   DEGREE SIGN in a German layout (Mac: only on
    ///   ISO keyboards), SUPERSCRIPT TWO and TILDE in a
    ///   French Windows layout, COMMERCIAL AT and
    ///   NUMBER SIGN in a French Mac layout on ISO
    ///   keyboards, and LESS-THAN SIGN and GREATER-THAN
    ///   SIGN in a Swiss German, German, or French Mac
    ///   layout on ANSI keyboards.
    SDL_SCANCODE_GRAVE = 53,
    SDL_SCANCODE_COMMA = 54,
    SDL_SCANCODE_PERIOD = 55,
    SDL_SCANCODE_SLASH = 56,
    SDL_SCANCODE_CAPSLOCK = 57,
    SDL_SCANCODE_F1 = 58,
    SDL_SCANCODE_F2 = 59,
    SDL_SCANCODE_F3 = 60,
    SDL_SCANCODE_F4 = 61,
    SDL_SCANCODE_F5 = 62,
    SDL_SCANCODE_F6 = 63,
    SDL_SCANCODE_F7 = 64,
    SDL_SCANCODE_F8 = 65,
    SDL_SCANCODE_F9 = 66,
    SDL_SCANCODE_F10 = 67,
    SDL_SCANCODE_F11 = 68,
    SDL_SCANCODE_F12 = 69,
    SDL_SCANCODE_PRINTSCREEN = 70,
    SDL_SCANCODE_SCROLLLOCK = 71,
    SDL_SCANCODE_PAUSE = 72,
    ///< insert on PC, help on some Mac keyboards (but
    ///does send code 73, not 117)
    SDL_SCANCODE_INSERT = 73,
    SDL_SCANCODE_HOME = 74,
    SDL_SCANCODE_PAGEUP = 75,
    SDL_SCANCODE_DELETE = 76,
    SDL_SCANCODE_END = 77,
    SDL_SCANCODE_PAGEDOWN = 78,
    SDL_SCANCODE_RIGHT = 79,
    SDL_SCANCODE_LEFT = 80,
    SDL_SCANCODE_DOWN = 81,
    SDL_SCANCODE_UP = 82,
    ///< num lock on PC, clear on Mac keyboards
    SDL_SCANCODE_NUMLOCKCLEAR = 83,
    SDL_SCANCODE_KP_DIVIDE = 84,
    SDL_SCANCODE_KP_MULTIPLY = 85,
    SDL_SCANCODE_KP_MINUS = 86,
    SDL_SCANCODE_KP_PLUS = 87,
    SDL_SCANCODE_KP_ENTER = 88,
    SDL_SCANCODE_KP_1 = 89,
    SDL_SCANCODE_KP_2 = 90,
    SDL_SCANCODE_KP_3 = 91,
    SDL_SCANCODE_KP_4 = 92,
    SDL_SCANCODE_KP_5 = 93,
    SDL_SCANCODE_KP_6 = 94,
    SDL_SCANCODE_KP_7 = 95,
    SDL_SCANCODE_KP_8 = 96,
    SDL_SCANCODE_KP_9 = 97,
    SDL_SCANCODE_KP_0 = 98,
    SDL_SCANCODE_KP_PERIOD = 99,
    ///< This is the additional key that ISO
    ///   keyboards have over ANSI ones,
    ///   located between left shift and Y.
    ///   Produces GRAVE ACCENT and TILDE in a
    ///   US or UK Mac layout, REVERSE SOLIDUS
    ///   (backslash) and VERTICAL LINE in a
    ///   US or UK Windows layout, and
    ///   LESS-THAN SIGN and GREATER-THAN SIGN
    ///   in a Swiss German, German, or French
    ///   layout.
    SDL_SCANCODE_NONUSBACKSLASH = 100,
    ///< windows contextual menu, compose
    SDL_SCANCODE_APPLICATION = 101,
    ///< The USB document says this is a status flag,
    ///   not a physical key - but some Mac keyboards
    ///   do have a power key.
    SDL_SCANCODE_POWER = 102,
    SDL_SCANCODE_KP_EQUALS = 103,
    SDL_SCANCODE_F13 = 104,
    SDL_SCANCODE_F14 = 105,
    SDL_SCANCODE_F15 = 106,
    SDL_SCANCODE_F16 = 107,
    SDL_SCANCODE_F17 = 108,
    SDL_SCANCODE_F18 = 109,
    SDL_SCANCODE_F19 = 110,
    SDL_SCANCODE_F20 = 111,
    SDL_SCANCODE_F21 = 112,
    SDL_SCANCODE_F22 = 113,
    SDL_SCANCODE_F23 = 114,
    SDL_SCANCODE_F24 = 115,
    SDL_SCANCODE_EXECUTE = 116,
    SDL_SCANCODE_HELP = 117,
    SDL_SCANCODE_MENU = 118,
    SDL_SCANCODE_SELECT = 119,
    SDL_SCANCODE_STOP = 120,
    ///< redo
    SDL_SCANCODE_AGAIN = 121,
    SDL_SCANCODE_UNDO = 122,
    SDL_SCANCODE_CUT = 123,
    SDL_SCANCODE_COPY = 124,
    SDL_SCANCODE_PASTE = 125,
    SDL_SCANCODE_FIND = 126,
    SDL_SCANCODE_MUTE = 127,
    SDL_SCANCODE_VOLUMEUP = 128,
    SDL_SCANCODE_VOLUMEDOWN = 129,
    SDL_SCANCODE_KP_COMMA = 133,
    SDL_SCANCODE_KP_EQUALSAS400 = 134,
    ///< used on Asian keyboards, see
    ///footnotes in USB doc
    SDL_SCANCODE_INTERNATIONAL1 = 135,
    SDL_SCANCODE_INTERNATIONAL2 = 136,
    ///< Yen
    SDL_SCANCODE_INTERNATIONAL3 = 137,
    SDL_SCANCODE_INTERNATIONAL4 = 138,
    SDL_SCANCODE_INTERNATIONAL5 = 139,
    SDL_SCANCODE_INTERNATIONAL6 = 140,
    SDL_SCANCODE_INTERNATIONAL7 = 141,
    SDL_SCANCODE_INTERNATIONAL8 = 142,
    SDL_SCANCODE_INTERNATIONAL9 = 143,
    ///< Hangul/English toggle
    SDL_SCANCODE_LANG1 = 144,
    ///< Hanja conversion
    SDL_SCANCODE_LANG2 = 145,
    ///< Katakana
    SDL_SCANCODE_LANG3 = 146,
    ///< Hiragana
    SDL_SCANCODE_LANG4 = 147,
    ///< Zenkaku/Hankaku
    SDL_SCANCODE_LANG5 = 148,
    ///< reserved
    SDL_SCANCODE_LANG6 = 149,
    ///< reserved
    SDL_SCANCODE_LANG7 = 150,
    ///< reserved
    SDL_SCANCODE_LANG8 = 151,
    ///< reserved
    SDL_SCANCODE_LANG9 = 152,
    ///< Erase-Eaze
    SDL_SCANCODE_ALTERASE = 153,
    SDL_SCANCODE_SYSREQ = 154,
    SDL_SCANCODE_CANCEL = 155,
    SDL_SCANCODE_CLEAR = 156,
    SDL_SCANCODE_PRIOR = 157,
    SDL_SCANCODE_RETURN2 = 158,
    SDL_SCANCODE_SEPARATOR = 159,
    SDL_SCANCODE_OUT = 160,
    SDL_SCANCODE_OPER = 161,
    SDL_SCANCODE_CLEARAGAIN = 162,
    SDL_SCANCODE_CRSEL = 163,
    SDL_SCANCODE_EXSEL = 164,
    SDL_SCANCODE_KP_00 = 176,
    SDL_SCANCODE_KP_000 = 177,
    SDL_SCANCODE_THOUSANDSSEPARATOR = 178,
    SDL_SCANCODE_DECIMALSEPARATOR = 179,
    SDL_SCANCODE_CURRENCYUNIT = 180,
    SDL_SCANCODE_CURRENCYSUBUNIT = 181,
    SDL_SCANCODE_KP_LEFTPAREN = 182,
    SDL_SCANCODE_KP_RIGHTPAREN = 183,
    SDL_SCANCODE_KP_LEFTBRACE = 184,
    SDL_SCANCODE_KP_RIGHTBRACE = 185,
    SDL_SCANCODE_KP_TAB = 186,
    SDL_SCANCODE_KP_BACKSPACE = 187,
    SDL_SCANCODE_KP_A = 188,
    SDL_SCANCODE_KP_B = 189,
    SDL_SCANCODE_KP_C = 190,
    SDL_SCANCODE_KP_D = 191,
    SDL_SCANCODE_KP_E = 192,
    SDL_SCANCODE_KP_F = 193,
    SDL_SCANCODE_KP_XOR = 194,
    SDL_SCANCODE_KP_POWER = 195,
    SDL_SCANCODE_KP_PERCENT = 196,
    SDL_SCANCODE_KP_LESS = 197,
    SDL_SCANCODE_KP_GREATER = 198,
    SDL_SCANCODE_KP_AMPERSAND = 199,
    SDL_SCANCODE_KP_DBLAMPERSAND = 200,
    SDL_SCANCODE_KP_VERTICALBAR = 201,
    SDL_SCANCODE_KP_DBLVERTICALBAR = 202,
    SDL_SCANCODE_KP_COLON = 203,
    SDL_SCANCODE_KP_HASH = 204,
    SDL_SCANCODE_KP_SPACE = 205,
    SDL_SCANCODE_KP_AT = 206,
    SDL_SCANCODE_KP_EXCLAM = 207,
    SDL_SCANCODE_KP_MEMSTORE = 208,
    SDL_SCANCODE_KP_MEMRECALL = 209,
    SDL_SCANCODE_KP_MEMCLEAR = 210,
    SDL_SCANCODE_KP_MEMADD = 211,
    SDL_SCANCODE_KP_MEMSUBTRACT = 212,
    SDL_SCANCODE_KP_MEMMULTIPLY = 213,
    SDL_SCANCODE_KP_MEMDIVIDE = 214,
    SDL_SCANCODE_KP_PLUSMINUS = 215,
    SDL_SCANCODE_KP_CLEAR = 216,
    SDL_SCANCODE_KP_CLEARENTRY = 217,
    SDL_SCANCODE_KP_BINARY = 218,
    SDL_SCANCODE_KP_OCTAL = 219,
    SDL_SCANCODE_KP_DECIMAL = 220,
    SDL_SCANCODE_KP_HEXADECIMAL = 221,
    SDL_SCANCODE_LCTRL = 224,
    SDL_SCANCODE_LSHIFT = 225,
    ///< alt, option
    SDL_SCANCODE_LALT = 226,
    ///< windows, command (apple), meta
    SDL_SCANCODE_LGUI = 227,
    SDL_SCANCODE_RCTRL = 228,
    SDL_SCANCODE_RSHIFT = 229,
    ///< alt gr, option
    SDL_SCANCODE_RALT = 230,
    ///< windows, command (apple), meta
    SDL_SCANCODE_RGUI = 231,
    ///< I'm not sure if this is really not covered
    ///   by any of the above, but since there's a
    ///   special KMOD_MODE for it I'm adding it here
    SDL_SCANCODE_MODE = 257,
    SDL_SCANCODE_AUDIONEXT = 258,
    SDL_SCANCODE_AUDIOPREV = 259,
    SDL_SCANCODE_AUDIOSTOP = 260,
    SDL_SCANCODE_AUDIOPLAY = 261,
    SDL_SCANCODE_AUDIOMUTE = 262,
    SDL_SCANCODE_MEDIASELECT = 263,
    SDL_SCANCODE_WWW = 264,
    SDL_SCANCODE_MAIL = 265,
    SDL_SCANCODE_CALCULATOR = 266,
    SDL_SCANCODE_COMPUTER = 267,
    SDL_SCANCODE_AC_SEARCH = 268,
    SDL_SCANCODE_AC_HOME = 269,
    SDL_SCANCODE_AC_BACK = 270,
    SDL_SCANCODE_AC_FORWARD = 271,
    SDL_SCANCODE_AC_STOP = 272,
    SDL_SCANCODE_AC_REFRESH = 273,
    SDL_SCANCODE_AC_BOOKMARKS = 274,
    SDL_SCANCODE_BRIGHTNESSDOWN = 275,
    SDL_SCANCODE_BRIGHTNESSUP = 276,
    ///< display mirroring/dual display
    ///switch, video mode switch
    SDL_SCANCODE_DISPLAYSWITCH = 277,
    SDL_SCANCODE_KBDILLUMTOGGLE = 278,
    SDL_SCANCODE_KBDILLUMDOWN = 279,
    SDL_SCANCODE_KBDILLUMUP = 280,
    SDL_SCANCODE_EJECT = 281,
    SDL_SCANCODE_SLEEP = 282,
    SDL_SCANCODE_APP1 = 283,
    SDL_SCANCODE_APP2 = 284,
    ///< not a key, just marks the number of scancodes
    ///for array bounds
    SDL_NUM_SCANCODES = 512,
}
///  \brief The SDL virtual key representation.
///
///  Values of this type are used to represent keyboard keys using the current
///  layout of the keyboard.  These values include Unicode values representing
///  the unmodified character that would be generated by pressing the key, or
///  an SDLK_* constant for those keys that do not generate characters.
pub type SDL_Keycode = Sint32;
pub const SDLK_UNKNOWN: _bindgen_ty_9 = _bindgen_ty_9::SDLK_UNKNOWN;
pub const SDLK_RETURN: _bindgen_ty_9 = _bindgen_ty_9::SDLK_RETURN;
pub const SDLK_ESCAPE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_ESCAPE;
pub const SDLK_BACKSPACE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_BACKSPACE;
pub const SDLK_TAB: _bindgen_ty_9 = _bindgen_ty_9::SDLK_TAB;
pub const SDLK_SPACE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_SPACE;
pub const SDLK_EXCLAIM: _bindgen_ty_9 = _bindgen_ty_9::SDLK_EXCLAIM;
pub const SDLK_QUOTEDBL: _bindgen_ty_9 = _bindgen_ty_9::SDLK_QUOTEDBL;
pub const SDLK_HASH: _bindgen_ty_9 = _bindgen_ty_9::SDLK_HASH;
pub const SDLK_PERCENT: _bindgen_ty_9 = _bindgen_ty_9::SDLK_PERCENT;
pub const SDLK_DOLLAR: _bindgen_ty_9 = _bindgen_ty_9::SDLK_DOLLAR;
pub const SDLK_AMPERSAND: _bindgen_ty_9 = _bindgen_ty_9::SDLK_AMPERSAND;
pub const SDLK_QUOTE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_QUOTE;
pub const SDLK_LEFTPAREN: _bindgen_ty_9 = _bindgen_ty_9::SDLK_LEFTPAREN;
pub const SDLK_RIGHTPAREN: _bindgen_ty_9 = _bindgen_ty_9::SDLK_RIGHTPAREN;
pub const SDLK_ASTERISK: _bindgen_ty_9 = _bindgen_ty_9::SDLK_ASTERISK;
pub const SDLK_PLUS: _bindgen_ty_9 = _bindgen_ty_9::SDLK_PLUS;
pub const SDLK_COMMA: _bindgen_ty_9 = _bindgen_ty_9::SDLK_COMMA;
pub const SDLK_MINUS: _bindgen_ty_9 = _bindgen_ty_9::SDLK_MINUS;
pub const SDLK_PERIOD: _bindgen_ty_9 = _bindgen_ty_9::SDLK_PERIOD;
pub const SDLK_SLASH: _bindgen_ty_9 = _bindgen_ty_9::SDLK_SLASH;
pub const SDLK_0: _bindgen_ty_9 = _bindgen_ty_9::SDLK_0;
pub const SDLK_1: _bindgen_ty_9 = _bindgen_ty_9::SDLK_1;
pub const SDLK_2: _bindgen_ty_9 = _bindgen_ty_9::SDLK_2;
pub const SDLK_3: _bindgen_ty_9 = _bindgen_ty_9::SDLK_3;
pub const SDLK_4: _bindgen_ty_9 = _bindgen_ty_9::SDLK_4;
pub const SDLK_5: _bindgen_ty_9 = _bindgen_ty_9::SDLK_5;
pub const SDLK_6: _bindgen_ty_9 = _bindgen_ty_9::SDLK_6;
pub const SDLK_7: _bindgen_ty_9 = _bindgen_ty_9::SDLK_7;
pub const SDLK_8: _bindgen_ty_9 = _bindgen_ty_9::SDLK_8;
pub const SDLK_9: _bindgen_ty_9 = _bindgen_ty_9::SDLK_9;
pub const SDLK_COLON: _bindgen_ty_9 = _bindgen_ty_9::SDLK_COLON;
pub const SDLK_SEMICOLON: _bindgen_ty_9 = _bindgen_ty_9::SDLK_SEMICOLON;
pub const SDLK_LESS: _bindgen_ty_9 = _bindgen_ty_9::SDLK_LESS;
pub const SDLK_EQUALS: _bindgen_ty_9 = _bindgen_ty_9::SDLK_EQUALS;
pub const SDLK_GREATER: _bindgen_ty_9 = _bindgen_ty_9::SDLK_GREATER;
pub const SDLK_QUESTION: _bindgen_ty_9 = _bindgen_ty_9::SDLK_QUESTION;
pub const SDLK_AT: _bindgen_ty_9 = _bindgen_ty_9::SDLK_AT;
pub const SDLK_LEFTBRACKET: _bindgen_ty_9 = _bindgen_ty_9::SDLK_LEFTBRACKET;
pub const SDLK_BACKSLASH: _bindgen_ty_9 = _bindgen_ty_9::SDLK_BACKSLASH;
pub const SDLK_RIGHTBRACKET: _bindgen_ty_9 = _bindgen_ty_9::SDLK_RIGHTBRACKET;
pub const SDLK_CARET: _bindgen_ty_9 = _bindgen_ty_9::SDLK_CARET;
pub const SDLK_UNDERSCORE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_UNDERSCORE;
pub const SDLK_BACKQUOTE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_BACKQUOTE;
pub const SDLK_a: _bindgen_ty_9 = _bindgen_ty_9::SDLK_a;
pub const SDLK_b: _bindgen_ty_9 = _bindgen_ty_9::SDLK_b;
pub const SDLK_c: _bindgen_ty_9 = _bindgen_ty_9::SDLK_c;
pub const SDLK_d: _bindgen_ty_9 = _bindgen_ty_9::SDLK_d;
pub const SDLK_e: _bindgen_ty_9 = _bindgen_ty_9::SDLK_e;
pub const SDLK_f: _bindgen_ty_9 = _bindgen_ty_9::SDLK_f;
pub const SDLK_g: _bindgen_ty_9 = _bindgen_ty_9::SDLK_g;
pub const SDLK_h: _bindgen_ty_9 = _bindgen_ty_9::SDLK_h;
pub const SDLK_i: _bindgen_ty_9 = _bindgen_ty_9::SDLK_i;
pub const SDLK_j: _bindgen_ty_9 = _bindgen_ty_9::SDLK_j;
pub const SDLK_k: _bindgen_ty_9 = _bindgen_ty_9::SDLK_k;
pub const SDLK_l: _bindgen_ty_9 = _bindgen_ty_9::SDLK_l;
pub const SDLK_m: _bindgen_ty_9 = _bindgen_ty_9::SDLK_m;
pub const SDLK_n: _bindgen_ty_9 = _bindgen_ty_9::SDLK_n;
pub const SDLK_o: _bindgen_ty_9 = _bindgen_ty_9::SDLK_o;
pub const SDLK_p: _bindgen_ty_9 = _bindgen_ty_9::SDLK_p;
pub const SDLK_q: _bindgen_ty_9 = _bindgen_ty_9::SDLK_q;
pub const SDLK_r: _bindgen_ty_9 = _bindgen_ty_9::SDLK_r;
pub const SDLK_s: _bindgen_ty_9 = _bindgen_ty_9::SDLK_s;
pub const SDLK_t: _bindgen_ty_9 = _bindgen_ty_9::SDLK_t;
pub const SDLK_u: _bindgen_ty_9 = _bindgen_ty_9::SDLK_u;
pub const SDLK_v: _bindgen_ty_9 = _bindgen_ty_9::SDLK_v;
pub const SDLK_w: _bindgen_ty_9 = _bindgen_ty_9::SDLK_w;
pub const SDLK_x: _bindgen_ty_9 = _bindgen_ty_9::SDLK_x;
pub const SDLK_y: _bindgen_ty_9 = _bindgen_ty_9::SDLK_y;
pub const SDLK_z: _bindgen_ty_9 = _bindgen_ty_9::SDLK_z;
pub const SDLK_CAPSLOCK: _bindgen_ty_9 = _bindgen_ty_9::SDLK_CAPSLOCK;
pub const SDLK_F1: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F1;
pub const SDLK_F2: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F2;
pub const SDLK_F3: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F3;
pub const SDLK_F4: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F4;
pub const SDLK_F5: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F5;
pub const SDLK_F6: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F6;
pub const SDLK_F7: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F7;
pub const SDLK_F8: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F8;
pub const SDLK_F9: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F9;
pub const SDLK_F10: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F10;
pub const SDLK_F11: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F11;
pub const SDLK_F12: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F12;
pub const SDLK_PRINTSCREEN: _bindgen_ty_9 = _bindgen_ty_9::SDLK_PRINTSCREEN;
pub const SDLK_SCROLLLOCK: _bindgen_ty_9 = _bindgen_ty_9::SDLK_SCROLLLOCK;
pub const SDLK_PAUSE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_PAUSE;
pub const SDLK_INSERT: _bindgen_ty_9 = _bindgen_ty_9::SDLK_INSERT;
pub const SDLK_HOME: _bindgen_ty_9 = _bindgen_ty_9::SDLK_HOME;
pub const SDLK_PAGEUP: _bindgen_ty_9 = _bindgen_ty_9::SDLK_PAGEUP;
pub const SDLK_DELETE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_DELETE;
pub const SDLK_END: _bindgen_ty_9 = _bindgen_ty_9::SDLK_END;
pub const SDLK_PAGEDOWN: _bindgen_ty_9 = _bindgen_ty_9::SDLK_PAGEDOWN;
pub const SDLK_RIGHT: _bindgen_ty_9 = _bindgen_ty_9::SDLK_RIGHT;
pub const SDLK_LEFT: _bindgen_ty_9 = _bindgen_ty_9::SDLK_LEFT;
pub const SDLK_DOWN: _bindgen_ty_9 = _bindgen_ty_9::SDLK_DOWN;
pub const SDLK_UP: _bindgen_ty_9 = _bindgen_ty_9::SDLK_UP;
pub const SDLK_NUMLOCKCLEAR: _bindgen_ty_9 = _bindgen_ty_9::SDLK_NUMLOCKCLEAR;
pub const SDLK_KP_DIVIDE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_DIVIDE;
pub const SDLK_KP_MULTIPLY: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_MULTIPLY;
pub const SDLK_KP_MINUS: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_MINUS;
pub const SDLK_KP_PLUS: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_PLUS;
pub const SDLK_KP_ENTER: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_ENTER;
pub const SDLK_KP_1: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_1;
pub const SDLK_KP_2: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_2;
pub const SDLK_KP_3: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_3;
pub const SDLK_KP_4: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_4;
pub const SDLK_KP_5: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_5;
pub const SDLK_KP_6: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_6;
pub const SDLK_KP_7: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_7;
pub const SDLK_KP_8: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_8;
pub const SDLK_KP_9: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_9;
pub const SDLK_KP_0: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_0;
pub const SDLK_KP_PERIOD: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_PERIOD;
pub const SDLK_APPLICATION: _bindgen_ty_9 = _bindgen_ty_9::SDLK_APPLICATION;
pub const SDLK_POWER: _bindgen_ty_9 = _bindgen_ty_9::SDLK_POWER;
pub const SDLK_KP_EQUALS: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_EQUALS;
pub const SDLK_F13: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F13;
pub const SDLK_F14: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F14;
pub const SDLK_F15: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F15;
pub const SDLK_F16: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F16;
pub const SDLK_F17: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F17;
pub const SDLK_F18: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F18;
pub const SDLK_F19: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F19;
pub const SDLK_F20: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F20;
pub const SDLK_F21: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F21;
pub const SDLK_F22: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F22;
pub const SDLK_F23: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F23;
pub const SDLK_F24: _bindgen_ty_9 = _bindgen_ty_9::SDLK_F24;
pub const SDLK_EXECUTE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_EXECUTE;
pub const SDLK_HELP: _bindgen_ty_9 = _bindgen_ty_9::SDLK_HELP;
pub const SDLK_MENU: _bindgen_ty_9 = _bindgen_ty_9::SDLK_MENU;
pub const SDLK_SELECT: _bindgen_ty_9 = _bindgen_ty_9::SDLK_SELECT;
pub const SDLK_STOP: _bindgen_ty_9 = _bindgen_ty_9::SDLK_STOP;
pub const SDLK_AGAIN: _bindgen_ty_9 = _bindgen_ty_9::SDLK_AGAIN;
pub const SDLK_UNDO: _bindgen_ty_9 = _bindgen_ty_9::SDLK_UNDO;
pub const SDLK_CUT: _bindgen_ty_9 = _bindgen_ty_9::SDLK_CUT;
pub const SDLK_COPY: _bindgen_ty_9 = _bindgen_ty_9::SDLK_COPY;
pub const SDLK_PASTE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_PASTE;
pub const SDLK_FIND: _bindgen_ty_9 = _bindgen_ty_9::SDLK_FIND;
pub const SDLK_MUTE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_MUTE;
pub const SDLK_VOLUMEUP: _bindgen_ty_9 = _bindgen_ty_9::SDLK_VOLUMEUP;
pub const SDLK_VOLUMEDOWN: _bindgen_ty_9 = _bindgen_ty_9::SDLK_VOLUMEDOWN;
pub const SDLK_KP_COMMA: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_COMMA;
pub const SDLK_KP_EQUALSAS400: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_EQUALSAS400;
pub const SDLK_ALTERASE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_ALTERASE;
pub const SDLK_SYSREQ: _bindgen_ty_9 = _bindgen_ty_9::SDLK_SYSREQ;
pub const SDLK_CANCEL: _bindgen_ty_9 = _bindgen_ty_9::SDLK_CANCEL;
pub const SDLK_CLEAR: _bindgen_ty_9 = _bindgen_ty_9::SDLK_CLEAR;
pub const SDLK_PRIOR: _bindgen_ty_9 = _bindgen_ty_9::SDLK_PRIOR;
pub const SDLK_RETURN2: _bindgen_ty_9 = _bindgen_ty_9::SDLK_RETURN2;
pub const SDLK_SEPARATOR: _bindgen_ty_9 = _bindgen_ty_9::SDLK_SEPARATOR;
pub const SDLK_OUT: _bindgen_ty_9 = _bindgen_ty_9::SDLK_OUT;
pub const SDLK_OPER: _bindgen_ty_9 = _bindgen_ty_9::SDLK_OPER;
pub const SDLK_CLEARAGAIN: _bindgen_ty_9 = _bindgen_ty_9::SDLK_CLEARAGAIN;
pub const SDLK_CRSEL: _bindgen_ty_9 = _bindgen_ty_9::SDLK_CRSEL;
pub const SDLK_EXSEL: _bindgen_ty_9 = _bindgen_ty_9::SDLK_EXSEL;
pub const SDLK_KP_00: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_00;
pub const SDLK_KP_000: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_000;
pub const SDLK_THOUSANDSSEPARATOR: _bindgen_ty_9 = _bindgen_ty_9::SDLK_THOUSANDSSEPARATOR;
pub const SDLK_DECIMALSEPARATOR: _bindgen_ty_9 = _bindgen_ty_9::SDLK_DECIMALSEPARATOR;
pub const SDLK_CURRENCYUNIT: _bindgen_ty_9 = _bindgen_ty_9::SDLK_CURRENCYUNIT;
pub const SDLK_CURRENCYSUBUNIT: _bindgen_ty_9 = _bindgen_ty_9::SDLK_CURRENCYSUBUNIT;
pub const SDLK_KP_LEFTPAREN: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_LEFTPAREN;
pub const SDLK_KP_RIGHTPAREN: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_RIGHTPAREN;
pub const SDLK_KP_LEFTBRACE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_LEFTBRACE;
pub const SDLK_KP_RIGHTBRACE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_RIGHTBRACE;
pub const SDLK_KP_TAB: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_TAB;
pub const SDLK_KP_BACKSPACE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_BACKSPACE;
pub const SDLK_KP_A: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_A;
pub const SDLK_KP_B: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_B;
pub const SDLK_KP_C: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_C;
pub const SDLK_KP_D: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_D;
pub const SDLK_KP_E: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_E;
pub const SDLK_KP_F: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_F;
pub const SDLK_KP_XOR: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_XOR;
pub const SDLK_KP_POWER: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_POWER;
pub const SDLK_KP_PERCENT: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_PERCENT;
pub const SDLK_KP_LESS: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_LESS;
pub const SDLK_KP_GREATER: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_GREATER;
pub const SDLK_KP_AMPERSAND: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_AMPERSAND;
pub const SDLK_KP_DBLAMPERSAND: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_DBLAMPERSAND;
pub const SDLK_KP_VERTICALBAR: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_VERTICALBAR;
pub const SDLK_KP_DBLVERTICALBAR: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_DBLVERTICALBAR;
pub const SDLK_KP_COLON: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_COLON;
pub const SDLK_KP_HASH: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_HASH;
pub const SDLK_KP_SPACE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_SPACE;
pub const SDLK_KP_AT: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_AT;
pub const SDLK_KP_EXCLAM: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_EXCLAM;
pub const SDLK_KP_MEMSTORE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_MEMSTORE;
pub const SDLK_KP_MEMRECALL: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_MEMRECALL;
pub const SDLK_KP_MEMCLEAR: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_MEMCLEAR;
pub const SDLK_KP_MEMADD: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_MEMADD;
pub const SDLK_KP_MEMSUBTRACT: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_MEMSUBTRACT;
pub const SDLK_KP_MEMMULTIPLY: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_MEMMULTIPLY;
pub const SDLK_KP_MEMDIVIDE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_MEMDIVIDE;
pub const SDLK_KP_PLUSMINUS: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_PLUSMINUS;
pub const SDLK_KP_CLEAR: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_CLEAR;
pub const SDLK_KP_CLEARENTRY: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_CLEARENTRY;
pub const SDLK_KP_BINARY: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_BINARY;
pub const SDLK_KP_OCTAL: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_OCTAL;
pub const SDLK_KP_DECIMAL: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_DECIMAL;
pub const SDLK_KP_HEXADECIMAL: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KP_HEXADECIMAL;
pub const SDLK_LCTRL: _bindgen_ty_9 = _bindgen_ty_9::SDLK_LCTRL;
pub const SDLK_LSHIFT: _bindgen_ty_9 = _bindgen_ty_9::SDLK_LSHIFT;
pub const SDLK_LALT: _bindgen_ty_9 = _bindgen_ty_9::SDLK_LALT;
pub const SDLK_LGUI: _bindgen_ty_9 = _bindgen_ty_9::SDLK_LGUI;
pub const SDLK_RCTRL: _bindgen_ty_9 = _bindgen_ty_9::SDLK_RCTRL;
pub const SDLK_RSHIFT: _bindgen_ty_9 = _bindgen_ty_9::SDLK_RSHIFT;
pub const SDLK_RALT: _bindgen_ty_9 = _bindgen_ty_9::SDLK_RALT;
pub const SDLK_RGUI: _bindgen_ty_9 = _bindgen_ty_9::SDLK_RGUI;
pub const SDLK_MODE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_MODE;
pub const SDLK_AUDIONEXT: _bindgen_ty_9 = _bindgen_ty_9::SDLK_AUDIONEXT;
pub const SDLK_AUDIOPREV: _bindgen_ty_9 = _bindgen_ty_9::SDLK_AUDIOPREV;
pub const SDLK_AUDIOSTOP: _bindgen_ty_9 = _bindgen_ty_9::SDLK_AUDIOSTOP;
pub const SDLK_AUDIOPLAY: _bindgen_ty_9 = _bindgen_ty_9::SDLK_AUDIOPLAY;
pub const SDLK_AUDIOMUTE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_AUDIOMUTE;
pub const SDLK_MEDIASELECT: _bindgen_ty_9 = _bindgen_ty_9::SDLK_MEDIASELECT;
pub const SDLK_WWW: _bindgen_ty_9 = _bindgen_ty_9::SDLK_WWW;
pub const SDLK_MAIL: _bindgen_ty_9 = _bindgen_ty_9::SDLK_MAIL;
pub const SDLK_CALCULATOR: _bindgen_ty_9 = _bindgen_ty_9::SDLK_CALCULATOR;
pub const SDLK_COMPUTER: _bindgen_ty_9 = _bindgen_ty_9::SDLK_COMPUTER;
pub const SDLK_AC_SEARCH: _bindgen_ty_9 = _bindgen_ty_9::SDLK_AC_SEARCH;
pub const SDLK_AC_HOME: _bindgen_ty_9 = _bindgen_ty_9::SDLK_AC_HOME;
pub const SDLK_AC_BACK: _bindgen_ty_9 = _bindgen_ty_9::SDLK_AC_BACK;
pub const SDLK_AC_FORWARD: _bindgen_ty_9 = _bindgen_ty_9::SDLK_AC_FORWARD;
pub const SDLK_AC_STOP: _bindgen_ty_9 = _bindgen_ty_9::SDLK_AC_STOP;
pub const SDLK_AC_REFRESH: _bindgen_ty_9 = _bindgen_ty_9::SDLK_AC_REFRESH;
pub const SDLK_AC_BOOKMARKS: _bindgen_ty_9 = _bindgen_ty_9::SDLK_AC_BOOKMARKS;
pub const SDLK_BRIGHTNESSDOWN: _bindgen_ty_9 = _bindgen_ty_9::SDLK_BRIGHTNESSDOWN;
pub const SDLK_BRIGHTNESSUP: _bindgen_ty_9 = _bindgen_ty_9::SDLK_BRIGHTNESSUP;
pub const SDLK_DISPLAYSWITCH: _bindgen_ty_9 = _bindgen_ty_9::SDLK_DISPLAYSWITCH;
pub const SDLK_KBDILLUMTOGGLE: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KBDILLUMTOGGLE;
pub const SDLK_KBDILLUMDOWN: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KBDILLUMDOWN;
pub const SDLK_KBDILLUMUP: _bindgen_ty_9 = _bindgen_ty_9::SDLK_KBDILLUMUP;
pub const SDLK_EJECT: _bindgen_ty_9 = _bindgen_ty_9::SDLK_EJECT;
pub const SDLK_SLEEP: _bindgen_ty_9 = _bindgen_ty_9::SDLK_SLEEP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_9 {
    SDLK_UNKNOWN = 0,
    SDLK_RETURN = 13,
    SDLK_ESCAPE = 27,
    SDLK_BACKSPACE = 8,
    SDLK_TAB = 9,
    SDLK_SPACE = 32,
    SDLK_EXCLAIM = 33,
    SDLK_QUOTEDBL = 34,
    SDLK_HASH = 35,
    SDLK_PERCENT = 37,
    SDLK_DOLLAR = 36,
    SDLK_AMPERSAND = 38,
    SDLK_QUOTE = 39,
    SDLK_LEFTPAREN = 40,
    SDLK_RIGHTPAREN = 41,
    SDLK_ASTERISK = 42,
    SDLK_PLUS = 43,
    SDLK_COMMA = 44,
    SDLK_MINUS = 45,
    SDLK_PERIOD = 46,
    SDLK_SLASH = 47,
    SDLK_0 = 48,
    SDLK_1 = 49,
    SDLK_2 = 50,
    SDLK_3 = 51,
    SDLK_4 = 52,
    SDLK_5 = 53,
    SDLK_6 = 54,
    SDLK_7 = 55,
    SDLK_8 = 56,
    SDLK_9 = 57,
    SDLK_COLON = 58,
    SDLK_SEMICOLON = 59,
    SDLK_LESS = 60,
    SDLK_EQUALS = 61,
    SDLK_GREATER = 62,
    SDLK_QUESTION = 63,
    SDLK_AT = 64,
    SDLK_LEFTBRACKET = 91,
    SDLK_BACKSLASH = 92,
    SDLK_RIGHTBRACKET = 93,
    SDLK_CARET = 94,
    SDLK_UNDERSCORE = 95,
    SDLK_BACKQUOTE = 96,
    SDLK_a = 97,
    SDLK_b = 98,
    SDLK_c = 99,
    SDLK_d = 100,
    SDLK_e = 101,
    SDLK_f = 102,
    SDLK_g = 103,
    SDLK_h = 104,
    SDLK_i = 105,
    SDLK_j = 106,
    SDLK_k = 107,
    SDLK_l = 108,
    SDLK_m = 109,
    SDLK_n = 110,
    SDLK_o = 111,
    SDLK_p = 112,
    SDLK_q = 113,
    SDLK_r = 114,
    SDLK_s = 115,
    SDLK_t = 116,
    SDLK_u = 117,
    SDLK_v = 118,
    SDLK_w = 119,
    SDLK_x = 120,
    SDLK_y = 121,
    SDLK_z = 122,
    SDLK_CAPSLOCK = 1073741881,
    SDLK_F1 = 1073741882,
    SDLK_F2 = 1073741883,
    SDLK_F3 = 1073741884,
    SDLK_F4 = 1073741885,
    SDLK_F5 = 1073741886,
    SDLK_F6 = 1073741887,
    SDLK_F7 = 1073741888,
    SDLK_F8 = 1073741889,
    SDLK_F9 = 1073741890,
    SDLK_F10 = 1073741891,
    SDLK_F11 = 1073741892,
    SDLK_F12 = 1073741893,
    SDLK_PRINTSCREEN = 1073741894,
    SDLK_SCROLLLOCK = 1073741895,
    SDLK_PAUSE = 1073741896,
    SDLK_INSERT = 1073741897,
    SDLK_HOME = 1073741898,
    SDLK_PAGEUP = 1073741899,
    SDLK_DELETE = 127,
    SDLK_END = 1073741901,
    SDLK_PAGEDOWN = 1073741902,
    SDLK_RIGHT = 1073741903,
    SDLK_LEFT = 1073741904,
    SDLK_DOWN = 1073741905,
    SDLK_UP = 1073741906,
    SDLK_NUMLOCKCLEAR = 1073741907,
    SDLK_KP_DIVIDE = 1073741908,
    SDLK_KP_MULTIPLY = 1073741909,
    SDLK_KP_MINUS = 1073741910,
    SDLK_KP_PLUS = 1073741911,
    SDLK_KP_ENTER = 1073741912,
    SDLK_KP_1 = 1073741913,
    SDLK_KP_2 = 1073741914,
    SDLK_KP_3 = 1073741915,
    SDLK_KP_4 = 1073741916,
    SDLK_KP_5 = 1073741917,
    SDLK_KP_6 = 1073741918,
    SDLK_KP_7 = 1073741919,
    SDLK_KP_8 = 1073741920,
    SDLK_KP_9 = 1073741921,
    SDLK_KP_0 = 1073741922,
    SDLK_KP_PERIOD = 1073741923,
    SDLK_APPLICATION = 1073741925,
    SDLK_POWER = 1073741926,
    SDLK_KP_EQUALS = 1073741927,
    SDLK_F13 = 1073741928,
    SDLK_F14 = 1073741929,
    SDLK_F15 = 1073741930,
    SDLK_F16 = 1073741931,
    SDLK_F17 = 1073741932,
    SDLK_F18 = 1073741933,
    SDLK_F19 = 1073741934,
    SDLK_F20 = 1073741935,
    SDLK_F21 = 1073741936,
    SDLK_F22 = 1073741937,
    SDLK_F23 = 1073741938,
    SDLK_F24 = 1073741939,
    SDLK_EXECUTE = 1073741940,
    SDLK_HELP = 1073741941,
    SDLK_MENU = 1073741942,
    SDLK_SELECT = 1073741943,
    SDLK_STOP = 1073741944,
    SDLK_AGAIN = 1073741945,
    SDLK_UNDO = 1073741946,
    SDLK_CUT = 1073741947,
    SDLK_COPY = 1073741948,
    SDLK_PASTE = 1073741949,
    SDLK_FIND = 1073741950,
    SDLK_MUTE = 1073741951,
    SDLK_VOLUMEUP = 1073741952,
    SDLK_VOLUMEDOWN = 1073741953,
    SDLK_KP_COMMA = 1073741957,
    SDLK_KP_EQUALSAS400 = 1073741958,
    SDLK_ALTERASE = 1073741977,
    SDLK_SYSREQ = 1073741978,
    SDLK_CANCEL = 1073741979,
    SDLK_CLEAR = 1073741980,
    SDLK_PRIOR = 1073741981,
    SDLK_RETURN2 = 1073741982,
    SDLK_SEPARATOR = 1073741983,
    SDLK_OUT = 1073741984,
    SDLK_OPER = 1073741985,
    SDLK_CLEARAGAIN = 1073741986,
    SDLK_CRSEL = 1073741987,
    SDLK_EXSEL = 1073741988,
    SDLK_KP_00 = 1073742000,
    SDLK_KP_000 = 1073742001,
    SDLK_THOUSANDSSEPARATOR = 1073742002,
    SDLK_DECIMALSEPARATOR = 1073742003,
    SDLK_CURRENCYUNIT = 1073742004,
    SDLK_CURRENCYSUBUNIT = 1073742005,
    SDLK_KP_LEFTPAREN = 1073742006,
    SDLK_KP_RIGHTPAREN = 1073742007,
    SDLK_KP_LEFTBRACE = 1073742008,
    SDLK_KP_RIGHTBRACE = 1073742009,
    SDLK_KP_TAB = 1073742010,
    SDLK_KP_BACKSPACE = 1073742011,
    SDLK_KP_A = 1073742012,
    SDLK_KP_B = 1073742013,
    SDLK_KP_C = 1073742014,
    SDLK_KP_D = 1073742015,
    SDLK_KP_E = 1073742016,
    SDLK_KP_F = 1073742017,
    SDLK_KP_XOR = 1073742018,
    SDLK_KP_POWER = 1073742019,
    SDLK_KP_PERCENT = 1073742020,
    SDLK_KP_LESS = 1073742021,
    SDLK_KP_GREATER = 1073742022,
    SDLK_KP_AMPERSAND = 1073742023,
    SDLK_KP_DBLAMPERSAND = 1073742024,
    SDLK_KP_VERTICALBAR = 1073742025,
    SDLK_KP_DBLVERTICALBAR = 1073742026,
    SDLK_KP_COLON = 1073742027,
    SDLK_KP_HASH = 1073742028,
    SDLK_KP_SPACE = 1073742029,
    SDLK_KP_AT = 1073742030,
    SDLK_KP_EXCLAM = 1073742031,
    SDLK_KP_MEMSTORE = 1073742032,
    SDLK_KP_MEMRECALL = 1073742033,
    SDLK_KP_MEMCLEAR = 1073742034,
    SDLK_KP_MEMADD = 1073742035,
    SDLK_KP_MEMSUBTRACT = 1073742036,
    SDLK_KP_MEMMULTIPLY = 1073742037,
    SDLK_KP_MEMDIVIDE = 1073742038,
    SDLK_KP_PLUSMINUS = 1073742039,
    SDLK_KP_CLEAR = 1073742040,
    SDLK_KP_CLEARENTRY = 1073742041,
    SDLK_KP_BINARY = 1073742042,
    SDLK_KP_OCTAL = 1073742043,
    SDLK_KP_DECIMAL = 1073742044,
    SDLK_KP_HEXADECIMAL = 1073742045,
    SDLK_LCTRL = 1073742048,
    SDLK_LSHIFT = 1073742049,
    SDLK_LALT = 1073742050,
    SDLK_LGUI = 1073742051,
    SDLK_RCTRL = 1073742052,
    SDLK_RSHIFT = 1073742053,
    SDLK_RALT = 1073742054,
    SDLK_RGUI = 1073742055,
    SDLK_MODE = 1073742081,
    SDLK_AUDIONEXT = 1073742082,
    SDLK_AUDIOPREV = 1073742083,
    SDLK_AUDIOSTOP = 1073742084,
    SDLK_AUDIOPLAY = 1073742085,
    SDLK_AUDIOMUTE = 1073742086,
    SDLK_MEDIASELECT = 1073742087,
    SDLK_WWW = 1073742088,
    SDLK_MAIL = 1073742089,
    SDLK_CALCULATOR = 1073742090,
    SDLK_COMPUTER = 1073742091,
    SDLK_AC_SEARCH = 1073742092,
    SDLK_AC_HOME = 1073742093,
    SDLK_AC_BACK = 1073742094,
    SDLK_AC_FORWARD = 1073742095,
    SDLK_AC_STOP = 1073742096,
    SDLK_AC_REFRESH = 1073742097,
    SDLK_AC_BOOKMARKS = 1073742098,
    SDLK_BRIGHTNESSDOWN = 1073742099,
    SDLK_BRIGHTNESSUP = 1073742100,
    SDLK_DISPLAYSWITCH = 1073742101,
    SDLK_KBDILLUMTOGGLE = 1073742102,
    SDLK_KBDILLUMDOWN = 1073742103,
    SDLK_KBDILLUMUP = 1073742104,
    SDLK_EJECT = 1073742105,
    SDLK_SLEEP = 1073742106,
}
#[repr(u32)]
/// \brief Enumeration of valid key mods (possibly OR'd together).
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_Keymod {
    KMOD_NONE = 0,
    KMOD_LSHIFT = 1,
    KMOD_RSHIFT = 2,
    KMOD_LCTRL = 64,
    KMOD_RCTRL = 128,
    KMOD_LALT = 256,
    KMOD_RALT = 512,
    KMOD_LGUI = 1024,
    KMOD_RGUI = 2048,
    KMOD_NUM = 4096,
    KMOD_CAPS = 8192,
    KMOD_MODE = 16384,
    KMOD_RESERVED = 32768,
}
///  \brief The SDL keysym structure, used in key events.
///
///  \note  If you are looking for translated character input, see the ::SDL_TEXTINPUT event.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Keysym {
    ///< SDL physical key code - see ::SDL_Scancode for details
    pub scancode: SDL_Scancode,
    ///< SDL virtual key code - see ::SDL_Keycode for details
    pub sym: SDL_Keycode,
    ///< current key modifiers
    pub mod_: Uint16,
    pub unused: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_Keysym() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Keysym>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_Keysym))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Keysym>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_Keysym))
    );
}
extern "C" {
    ///  \brief Get the window which currently has keyboard focus.
    pub fn SDL_GetKeyboardFocus() -> *mut SDL_Window;
}
extern "C" {
    ///  \brief Get a snapshot of the current state of the keyboard.
    ///
    ///  \param numkeys if non-NULL, receives the length of the returned array.
    ///
    ///  \return An array of key states. Indexes into this array are obtained by using ::SDL_Scancode values.
    ///
    ///  \b Example:
    ///  \code
    ///  const Uint8 *state = SDL_GetKeyboardState(NULL);
    ///  if ( state[SDL_SCANCODE_RETURN] )   {
    ///      printf("<RETURN> is pressed.\n");
    ///  }
    ///  \endcode
    pub fn SDL_GetKeyboardState(numkeys: *mut ::std::os::raw::c_int) -> *const Uint8;
}
extern "C" {
    ///  \brief Get the current key modifier state for the keyboard.
    pub fn SDL_GetModState() -> SDL_Keymod;
}
extern "C" {
    ///  \brief Set the current key modifier state for the keyboard.
    ///
    ///  \note This does not change the keyboard state, only the key modifier flags.
    pub fn SDL_SetModState(modstate: SDL_Keymod);
}
extern "C" {
    ///  \brief Get the key code corresponding to the given scancode according
    ///         to the current keyboard layout.
    ///
    ///  See ::SDL_Keycode for details.
    ///
    ///  \sa SDL_GetKeyName()
    pub fn SDL_GetKeyFromScancode(scancode: SDL_Scancode) -> SDL_Keycode;
}
extern "C" {
    ///  \brief Get the scancode corresponding to the given key code according to the
    ///         current keyboard layout.
    ///
    ///  See ::SDL_Scancode for details.
    ///
    ///  \sa SDL_GetScancodeName()
    pub fn SDL_GetScancodeFromKey(key: SDL_Keycode) -> SDL_Scancode;
}
extern "C" {
    ///  \brief Get a human-readable name for a scancode.
    ///
    ///  \return A pointer to the name for the scancode.
    ///          If the scancode doesn't have a name, this function returns
    ///          an empty string ("").
    ///
    ///  \sa SDL_Scancode
    pub fn SDL_GetScancodeName(scancode: SDL_Scancode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    ///  \brief Get a scancode from a human-readable name
    ///
    ///  \return scancode, or SDL_SCANCODE_UNKNOWN if the name wasn't recognized
    ///
    ///  \sa SDL_Scancode
    pub fn SDL_GetScancodeFromName(name: *const ::std::os::raw::c_char) -> SDL_Scancode;
}
extern "C" {
    ///  \brief Get a human-readable name for a key.
    ///
    ///  \return A pointer to a UTF-8 string that stays valid at least until the next
    ///          call to this function. If you need it around any longer, you must
    ///          copy it.  If the key doesn't have a name, this function returns an
    ///          empty string ("").
    ///
    ///  \sa SDL_Key
    pub fn SDL_GetKeyName(key: SDL_Keycode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    ///  \brief Get a key code from a human-readable name
    ///
    ///  \return key code, or SDLK_UNKNOWN if the name wasn't recognized
    ///
    ///  \sa SDL_Keycode
    pub fn SDL_GetKeyFromName(name: *const ::std::os::raw::c_char) -> SDL_Keycode;
}
extern "C" {
    ///  \brief Start accepting Unicode text input events.
    ///         This function will show the on-screen keyboard if supported.
    ///
    ///  \sa SDL_StopTextInput()
    ///  \sa SDL_SetTextInputRect()
    ///  \sa SDL_HasScreenKeyboardSupport()
    pub fn SDL_StartTextInput();
}
extern "C" {
    ///  \brief Return whether or not Unicode text input events are enabled.
    ///
    ///  \sa SDL_StartTextInput()
    ///  \sa SDL_StopTextInput()
    pub fn SDL_IsTextInputActive() -> SDL_bool;
}
extern "C" {
    ///  \brief Stop receiving any text input events.
    ///         This function will hide the on-screen keyboard if supported.
    ///
    ///  \sa SDL_StartTextInput()
    ///  \sa SDL_HasScreenKeyboardSupport()
    pub fn SDL_StopTextInput();
}
extern "C" {
    ///  \brief Set the rectangle used to type Unicode text inputs.
    ///         This is used as a hint for IME and on-screen keyboard placement.
    ///
    ///  \sa SDL_StartTextInput()
    pub fn SDL_SetTextInputRect(rect: *mut SDL_Rect);
}
extern "C" {
    ///  \brief Returns whether the platform has some screen keyboard support.
    ///
    ///  \return SDL_TRUE if some keyboard support is available else SDL_FALSE.
    ///
    ///  \note Not all screen keyboard functions are supported on all platforms.
    ///
    ///  \sa SDL_IsScreenKeyboardShown()
    pub fn SDL_HasScreenKeyboardSupport() -> SDL_bool;
}
extern "C" {
    ///  \brief Returns whether the screen keyboard is shown for given window.
    ///
    ///  \param window The window for which screen keyboard should be queried.
    ///
    ///  \return SDL_TRUE if screen keyboard is shown else SDL_FALSE.
    ///
    ///  \sa SDL_HasScreenKeyboardSupport()
    pub fn SDL_IsScreenKeyboardShown(window: *mut SDL_Window) -> SDL_bool;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Cursor {
    _unused: [u8; 0],
}
#[repr(u32)]
/// \brief Cursor types for SDL_CreateSystemCursor.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_SystemCursor {
    ///< Arrow
    SDL_SYSTEM_CURSOR_ARROW = 0,
    ///< I-beam
    SDL_SYSTEM_CURSOR_IBEAM = 1,
    ///< Wait
    SDL_SYSTEM_CURSOR_WAIT = 2,
    ///< Crosshair
    SDL_SYSTEM_CURSOR_CROSSHAIR = 3,
    ///< Small wait cursor (or Wait if not available)
    SDL_SYSTEM_CURSOR_WAITARROW = 4,
    ///< Double arrow pointing northwest and southeast
    SDL_SYSTEM_CURSOR_SIZENWSE = 5,
    ///< Double arrow pointing northeast and southwest
    SDL_SYSTEM_CURSOR_SIZENESW = 6,
    ///< Double arrow pointing west and east
    SDL_SYSTEM_CURSOR_SIZEWE = 7,
    ///< Double arrow pointing north and south
    SDL_SYSTEM_CURSOR_SIZENS = 8,
    ///< Four pointed arrow pointing north, south, east, and west
    SDL_SYSTEM_CURSOR_SIZEALL = 9,
    ///< Slashed circle or crossbones
    SDL_SYSTEM_CURSOR_NO = 10,
    ///< Hand
    SDL_SYSTEM_CURSOR_HAND = 11,
    SDL_NUM_SYSTEM_CURSORS = 12,
}
extern "C" {
    ///  \brief Get the window which currently has mouse focus.
    pub fn SDL_GetMouseFocus() -> *mut SDL_Window;
}
extern "C" {
    ///  \brief Retrieve the current state of the mouse.
    ///
    ///  The current button state is returned as a button bitmask, which can
    ///  be tested using the SDL_BUTTON(X) macros, and x and y are set to the
    ///  mouse cursor position relative to the focus window for the currently
    ///  selected mouse.  You can pass NULL for either x or y.
    pub fn SDL_GetMouseState(
        x: *mut ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_int,
    ) -> Uint32;
}
extern "C" {
    ///  \brief Retrieve the relative state of the mouse.
    ///
    ///  The current button state is returned as a button bitmask, which can
    ///  be tested using the SDL_BUTTON(X) macros, and x and y are set to the
    ///  mouse deltas since the last call to SDL_GetRelativeMouseState().
    pub fn SDL_GetRelativeMouseState(
        x: *mut ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_int,
    ) -> Uint32;
}
extern "C" {
    ///  \brief Moves the mouse to the given position within the window.
    ///
    ///  \param window The window to move the mouse into, or NULL for the current mouse focus
    ///  \param x The x coordinate within the window
    ///  \param y The y coordinate within the window
    ///
    ///  \note This function generates a mouse motion event
    pub fn SDL_WarpMouseInWindow(
        window: *mut SDL_Window,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
extern "C" {
    ///  \brief Set relative mouse mode.
    ///
    ///  \param enabled Whether or not to enable relative mode
    ///
    ///  \return 0 on success, or -1 if relative mode is not supported.
    ///
    ///  While the mouse is in relative mode, the cursor is hidden, and the
    ///  driver will try to report continuous motion in the current window.
    ///  Only relative motion events will be delivered, the mouse position
    ///  will not change.
    ///
    ///  \note This function will flush any pending mouse motion.
    ///
    ///  \sa SDL_GetRelativeMouseMode()
    pub fn SDL_SetRelativeMouseMode(enabled: SDL_bool) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Query whether relative mouse mode is enabled.
    ///
    ///  \sa SDL_SetRelativeMouseMode()
    pub fn SDL_GetRelativeMouseMode() -> SDL_bool;
}
extern "C" {
    ///  \brief Create a cursor, using the specified bitmap data and
    ///         mask (in MSB format).
    ///
    ///  The cursor width must be a multiple of 8 bits.
    ///
    ///  The cursor is created in black and white according to the following:
    ///  <table>
    ///  <tr><td> data </td><td> mask </td><td> resulting pixel on screen </td></tr>
    ///  <tr><td>  0   </td><td>  1   </td><td> White </td></tr>
    ///  <tr><td>  1   </td><td>  1   </td><td> Black </td></tr>
    ///  <tr><td>  0   </td><td>  0   </td><td> Transparent </td></tr>
    ///  <tr><td>  1   </td><td>  0   </td><td> Inverted color if possible, black
    ///                                         if not. </td></tr>
    ///  </table>
    ///
    ///  \sa SDL_FreeCursor()
    pub fn SDL_CreateCursor(
        data: *const Uint8,
        mask: *const Uint8,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        hot_x: ::std::os::raw::c_int,
        hot_y: ::std::os::raw::c_int,
    ) -> *mut SDL_Cursor;
}
extern "C" {
    ///  \brief Create a color cursor.
    ///
    ///  \sa SDL_FreeCursor()
    pub fn SDL_CreateColorCursor(
        surface: *mut SDL_Surface,
        hot_x: ::std::os::raw::c_int,
        hot_y: ::std::os::raw::c_int,
    ) -> *mut SDL_Cursor;
}
extern "C" {
    ///  \brief Create a system cursor.
    ///
    ///  \sa SDL_FreeCursor()
    pub fn SDL_CreateSystemCursor(id: SDL_SystemCursor) -> *mut SDL_Cursor;
}
extern "C" {
    ///  \brief Set the active cursor.
    pub fn SDL_SetCursor(cursor: *mut SDL_Cursor);
}
extern "C" {
    ///  \brief Return the active cursor.
    pub fn SDL_GetCursor() -> *mut SDL_Cursor;
}
extern "C" {
    ///  \brief Return the default cursor.
    pub fn SDL_GetDefaultCursor() -> *mut SDL_Cursor;
}
extern "C" {
    ///  \brief Frees a cursor created with SDL_CreateCursor().
    ///
    ///  \sa SDL_CreateCursor()
    pub fn SDL_FreeCursor(cursor: *mut SDL_Cursor);
}
extern "C" {
    ///  \brief Toggle whether or not the cursor is shown.
    ///
    ///  \param toggle 1 to show the cursor, 0 to hide it, -1 to query the current
    ///                state.
    ///
    ///  \return 1 if the cursor is shown, or 0 if the cursor is hidden.
    pub fn SDL_ShowCursor(toggle: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
///  \file SDL_joystick.h
///
///  In order to use these functions, SDL_Init() must have been called
///  with the ::SDL_INIT_JOYSTICK flag.  This causes SDL to scan the system
///  for joysticks, and load appropriate drivers.
///
///  If you would like to receive joystick updates while the application
///  is in the background, you should set the following hint before calling
///  SDL_Init(): SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SDL_Joystick {
    _unused: [u8; 0],
}
pub type SDL_Joystick = _SDL_Joystick;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_JoystickGUID {
    pub data: [Uint8; 16usize],
}
#[test]
fn bindgen_test_layout_SDL_JoystickGUID() {
    assert_eq!(
        ::std::mem::size_of::<SDL_JoystickGUID>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_JoystickGUID))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_JoystickGUID>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_JoystickGUID))
    );
}
pub type SDL_JoystickID = Sint32;
extern "C" {
    ///  Count the number of joysticks attached to the system right now
    pub fn SDL_NumJoysticks() -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Get the implementation dependent name of a joystick.
    ///  This can be called before any joysticks are opened.
    ///  If no name can be found, this function returns NULL.
    pub fn SDL_JoystickNameForIndex(
        device_index: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    ///  Open a joystick for use.
    ///  The index passed as an argument refers tothe N'th joystick on the system.
    ///  This index is the value which will identify this joystick in future joystick
    ///  events.
    ///
    ///  \return A joystick identifier, or NULL if an error occurred.
    pub fn SDL_JoystickOpen(device_index: ::std::os::raw::c_int) -> *mut SDL_Joystick;
}
extern "C" {
    ///  Return the name for this currently opened joystick.
    ///  If no name can be found, this function returns NULL.
    pub fn SDL_JoystickName(joystick: *mut SDL_Joystick) -> *const ::std::os::raw::c_char;
}
extern "C" {
    ///  Return the GUID for the joystick at this index
    pub fn SDL_JoystickGetDeviceGUID(device_index: ::std::os::raw::c_int) -> SDL_JoystickGUID;
}
extern "C" {
    ///  Return the GUID for this opened joystick
    pub fn SDL_JoystickGetGUID(joystick: *mut SDL_Joystick) -> SDL_JoystickGUID;
}
extern "C" {
    ///  Return a string representation for this guid. pszGUID must point to at least 33 bytes
    ///  (32 for the string plus a NULL terminator).
    pub fn SDL_JoystickGetGUIDString(
        guid: SDL_JoystickGUID,
        pszGUID: *mut ::std::os::raw::c_char,
        cbGUID: ::std::os::raw::c_int,
    );
}
extern "C" {
    ///  convert a string into a joystick formatted guid
    pub fn SDL_JoystickGetGUIDFromString(
        pchGUID: *const ::std::os::raw::c_char,
    ) -> SDL_JoystickGUID;
}
extern "C" {
    ///  Returns SDL_TRUE if the joystick has been opened and currently connected, or SDL_FALSE if it has not.
    pub fn SDL_JoystickGetAttached(joystick: *mut SDL_Joystick) -> SDL_bool;
}
extern "C" {
    ///  Get the instance ID of an opened joystick or -1 if the joystick is invalid.
    pub fn SDL_JoystickInstanceID(joystick: *mut SDL_Joystick) -> SDL_JoystickID;
}
extern "C" {
    ///  Get the number of general axis controls on a joystick.
    pub fn SDL_JoystickNumAxes(joystick: *mut SDL_Joystick) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Get the number of trackballs on a joystick.
    ///
    ///  Joystick trackballs have only relative motion events associated
    ///  with them and their state cannot be polled.
    pub fn SDL_JoystickNumBalls(joystick: *mut SDL_Joystick) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Get the number of POV hats on a joystick.
    pub fn SDL_JoystickNumHats(joystick: *mut SDL_Joystick) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Get the number of buttons on a joystick.
    pub fn SDL_JoystickNumButtons(joystick: *mut SDL_Joystick) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Update the current state of the open joysticks.
    ///
    ///  This is called automatically by the event loop if any joystick
    ///  events are enabled.
    pub fn SDL_JoystickUpdate();
}
extern "C" {
    ///  Enable/disable joystick event polling.
    ///
    ///  If joystick events are disabled, you must call SDL_JoystickUpdate()
    ///  yourself and check the state of the joystick when you want joystick
    ///  information.
    ///
    ///  The state can be one of ::SDL_QUERY, ::SDL_ENABLE or ::SDL_IGNORE.
    pub fn SDL_JoystickEventState(state: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Get the current state of an axis control on a joystick.
    ///
    ///  The state is a value ranging from -32768 to 32767.
    ///
    ///  The axis indices start at index 0.
    pub fn SDL_JoystickGetAxis(joystick: *mut SDL_Joystick, axis: ::std::os::raw::c_int) -> Sint16;
}
extern "C" {
    ///  Get the current state of a POV hat on a joystick.
    ///
    ///  The hat indices start at index 0.
    ///
    ///  \return The return value is one of the following positions:
    ///           - ::SDL_HAT_CENTERED
    ///           - ::SDL_HAT_UP
    ///           - ::SDL_HAT_RIGHT
    ///           - ::SDL_HAT_DOWN
    ///           - ::SDL_HAT_LEFT
    ///           - ::SDL_HAT_RIGHTUP
    ///           - ::SDL_HAT_RIGHTDOWN
    ///           - ::SDL_HAT_LEFTUP
    ///           - ::SDL_HAT_LEFTDOWN
    pub fn SDL_JoystickGetHat(joystick: *mut SDL_Joystick, hat: ::std::os::raw::c_int) -> Uint8;
}
extern "C" {
    ///  Get the ball axis change since the last poll.
    ///
    ///  \return 0, or -1 if you passed it invalid parameters.
    ///
    ///  The ball indices start at index 0.
    pub fn SDL_JoystickGetBall(
        joystick: *mut SDL_Joystick,
        ball: ::std::os::raw::c_int,
        dx: *mut ::std::os::raw::c_int,
        dy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Get the current state of a button on a joystick.
    ///
    ///  The button indices start at index 0.
    pub fn SDL_JoystickGetButton(
        joystick: *mut SDL_Joystick,
        button: ::std::os::raw::c_int,
    ) -> Uint8;
}
extern "C" {
    ///  Close a joystick previously opened with SDL_JoystickOpen().
    pub fn SDL_JoystickClose(joystick: *mut SDL_Joystick);
}
///  \file SDL_gamecontroller.h
///
///  In order to use these functions, SDL_Init() must have been called
///  with the ::SDL_INIT_JOYSTICK flag.  This causes SDL to scan the system
///  for game controllers, and load appropriate drivers.
///
///  If you would like to receive controller updates while the application
///  is in the background, you should set the following hint before calling
///  SDL_Init(): SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SDL_GameController {
    _unused: [u8; 0],
}
pub type SDL_GameController = _SDL_GameController;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GameControllerBindType {
    SDL_CONTROLLER_BINDTYPE_NONE = 0,
    SDL_CONTROLLER_BINDTYPE_BUTTON = 1,
    SDL_CONTROLLER_BINDTYPE_AXIS = 2,
    SDL_CONTROLLER_BINDTYPE_HAT = 3,
}
///  Get the SDL joystick layer binding for this controller button/axis mapping
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_GameControllerButtonBind {
    pub bindType: SDL_GameControllerBindType,
    pub value: SDL_GameControllerButtonBind__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_GameControllerButtonBind__bindgen_ty_1 {
    pub button: ::std::os::raw::c_int,
    pub axis: ::std::os::raw::c_int,
    pub hat: SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 {
    pub hat: ::std::os::raw::c_int,
    pub hat_mask: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SDL_GameControllerButtonBind__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_GameControllerButtonBind__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind() {
    assert_eq!(
        ::std::mem::size_of::<SDL_GameControllerButtonBind>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_GameControllerButtonBind))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_GameControllerButtonBind>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_GameControllerButtonBind))
    );
}
extern "C" {
    ///  Load a set of mappings from a seekable SDL data stream (memory or file), filtered by the current SDL_GetPlatform()
    ///  A community sourced database of controllers is available at https://raw.github.com/gabomdq/SDL_GameControllerDB/master/gamecontrollerdb.txt
    ///
    ///  If \c freerw is non-zero, the stream will be closed after being read.
    ///
    /// \return number of mappings added, -1 on error
    pub fn SDL_GameControllerAddMappingsFromRW(
        rw: *mut SDL_RWops,
        freerw: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Add or update an existing mapping configuration
    ///
    /// \return 1 if mapping is added, 0 if updated, -1 on error
    pub fn SDL_GameControllerAddMapping(
        mappingString: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Get a mapping string for a GUID
    ///
    ///  \return the mapping string.  Must be freed with SDL_free.  Returns NULL if no mapping is available
    pub fn SDL_GameControllerMappingForGUID(guid: SDL_JoystickGUID) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    ///  Get a mapping string for an open GameController
    ///
    ///  \return the mapping string.  Must be freed with SDL_free.  Returns NULL if no mapping is available
    pub fn SDL_GameControllerMapping(
        gamecontroller: *mut SDL_GameController,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    ///  Is the joystick on this index supported by the game controller interface?
    pub fn SDL_IsGameController(joystick_index: ::std::os::raw::c_int) -> SDL_bool;
}
extern "C" {
    ///  Get the implementation dependent name of a game controller.
    ///  This can be called before any controllers are opened.
    ///  If no name can be found, this function returns NULL.
    pub fn SDL_GameControllerNameForIndex(
        joystick_index: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    ///  Open a game controller for use.
    ///  The index passed as an argument refers to the N'th game controller on the system.
    ///  This index is the value which will identify this controller in future controller
    ///  events.
    ///
    ///  \return A controller identifier, or NULL if an error occurred.
    pub fn SDL_GameControllerOpen(joystick_index: ::std::os::raw::c_int)
        -> *mut SDL_GameController;
}
extern "C" {
    ///  Return the name for this currently opened controller
    pub fn SDL_GameControllerName(
        gamecontroller: *mut SDL_GameController,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    ///  Returns SDL_TRUE if the controller has been opened and currently connected,
    ///  or SDL_FALSE if it has not.
    pub fn SDL_GameControllerGetAttached(gamecontroller: *mut SDL_GameController) -> SDL_bool;
}
extern "C" {
    ///  Get the underlying joystick object used by a controller
    pub fn SDL_GameControllerGetJoystick(
        gamecontroller: *mut SDL_GameController,
    ) -> *mut SDL_Joystick;
}
extern "C" {
    ///  Enable/disable controller event polling.
    ///
    ///  If controller events are disabled, you must call SDL_GameControllerUpdate()
    ///  yourself and check the state of the controller when you want controller
    ///  information.
    ///
    ///  The state can be one of ::SDL_QUERY, ::SDL_ENABLE or ::SDL_IGNORE.
    pub fn SDL_GameControllerEventState(state: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Update the current state of the open game controllers.
    ///
    ///  This is called automatically by the event loop if any game controller
    ///  events are enabled.
    pub fn SDL_GameControllerUpdate();
}
#[repr(i32)]
///  The list of axes available from a controller
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GameControllerAxis {
    SDL_CONTROLLER_AXIS_INVALID = -1,
    SDL_CONTROLLER_AXIS_LEFTX = 0,
    SDL_CONTROLLER_AXIS_LEFTY = 1,
    SDL_CONTROLLER_AXIS_RIGHTX = 2,
    SDL_CONTROLLER_AXIS_RIGHTY = 3,
    SDL_CONTROLLER_AXIS_TRIGGERLEFT = 4,
    SDL_CONTROLLER_AXIS_TRIGGERRIGHT = 5,
    SDL_CONTROLLER_AXIS_MAX = 6,
}
extern "C" {
    ///  turn this string into a axis mapping
    pub fn SDL_GameControllerGetAxisFromString(
        pchString: *const ::std::os::raw::c_char,
    ) -> SDL_GameControllerAxis;
}
extern "C" {
    ///  turn this axis enum into a string mapping
    pub fn SDL_GameControllerGetStringForAxis(
        axis: SDL_GameControllerAxis,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    ///  Get the SDL joystick layer binding for this controller button mapping
    pub fn SDL_GameControllerGetBindForAxis(
        gamecontroller: *mut SDL_GameController,
        axis: SDL_GameControllerAxis,
    ) -> SDL_GameControllerButtonBind;
}
extern "C" {
    ///  Get the current state of an axis control on a game controller.
    ///
    ///  The state is a value ranging from -32768 to 32767.
    ///
    ///  The axis indices start at index 0.
    pub fn SDL_GameControllerGetAxis(
        gamecontroller: *mut SDL_GameController,
        axis: SDL_GameControllerAxis,
    ) -> Sint16;
}
#[repr(i32)]
///  The list of buttons available from a controller
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GameControllerButton {
    SDL_CONTROLLER_BUTTON_INVALID = -1,
    SDL_CONTROLLER_BUTTON_A = 0,
    SDL_CONTROLLER_BUTTON_B = 1,
    SDL_CONTROLLER_BUTTON_X = 2,
    SDL_CONTROLLER_BUTTON_Y = 3,
    SDL_CONTROLLER_BUTTON_BACK = 4,
    SDL_CONTROLLER_BUTTON_GUIDE = 5,
    SDL_CONTROLLER_BUTTON_START = 6,
    SDL_CONTROLLER_BUTTON_LEFTSTICK = 7,
    SDL_CONTROLLER_BUTTON_RIGHTSTICK = 8,
    SDL_CONTROLLER_BUTTON_LEFTSHOULDER = 9,
    SDL_CONTROLLER_BUTTON_RIGHTSHOULDER = 10,
    SDL_CONTROLLER_BUTTON_DPAD_UP = 11,
    SDL_CONTROLLER_BUTTON_DPAD_DOWN = 12,
    SDL_CONTROLLER_BUTTON_DPAD_LEFT = 13,
    SDL_CONTROLLER_BUTTON_DPAD_RIGHT = 14,
    SDL_CONTROLLER_BUTTON_MAX = 15,
}
extern "C" {
    ///  turn this string into a button mapping
    pub fn SDL_GameControllerGetButtonFromString(
        pchString: *const ::std::os::raw::c_char,
    ) -> SDL_GameControllerButton;
}
extern "C" {
    ///  turn this button enum into a string mapping
    pub fn SDL_GameControllerGetStringForButton(
        button: SDL_GameControllerButton,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    ///  Get the SDL joystick layer binding for this controller button mapping
    pub fn SDL_GameControllerGetBindForButton(
        gamecontroller: *mut SDL_GameController,
        button: SDL_GameControllerButton,
    ) -> SDL_GameControllerButtonBind;
}
extern "C" {
    ///  Get the current state of a button on a game controller.
    ///
    ///  The button indices start at index 0.
    pub fn SDL_GameControllerGetButton(
        gamecontroller: *mut SDL_GameController,
        button: SDL_GameControllerButton,
    ) -> Uint8;
}
extern "C" {
    ///  Close a controller previously opened with SDL_GameControllerOpen().
    pub fn SDL_GameControllerClose(gamecontroller: *mut SDL_GameController);
}
pub type SDL_TouchID = Sint64;
pub type SDL_FingerID = Sint64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Finger {
    pub id: SDL_FingerID,
    pub x: f32,
    pub y: f32,
    pub pressure: f32,
}
#[test]
fn bindgen_test_layout_SDL_Finger() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Finger>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_Finger))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Finger>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Finger))
    );
}
extern "C" {
    ///  \brief Get the number of registered touch devices.
    pub fn SDL_GetNumTouchDevices() -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the touch ID with the given index, or 0 if the index is invalid.
    pub fn SDL_GetTouchDevice(index: ::std::os::raw::c_int) -> SDL_TouchID;
}
extern "C" {
    ///  \brief Get the number of active fingers for a given touch device.
    pub fn SDL_GetNumTouchFingers(touchID: SDL_TouchID) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the finger object of the given touch, with the given index.
    pub fn SDL_GetTouchFinger(
        touchID: SDL_TouchID,
        index: ::std::os::raw::c_int,
    ) -> *mut SDL_Finger;
}
pub type SDL_GestureID = Sint64;
extern "C" {
    ///  \brief Begin Recording a gesture on the specified touch, or all touches (-1)
    ///
    ///
    pub fn SDL_RecordGesture(touchId: SDL_TouchID) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Save all currently loaded Dollar Gesture templates
    ///
    ///
    pub fn SDL_SaveAllDollarTemplates(dst: *mut SDL_RWops) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Save a currently loaded Dollar Gesture template
    ///
    ///
    pub fn SDL_SaveDollarTemplate(
        gestureId: SDL_GestureID,
        dst: *mut SDL_RWops,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Load Dollar Gesture templates from a file
    ///
    ///
    pub fn SDL_LoadDollarTemplates(
        touchId: SDL_TouchID,
        src: *mut SDL_RWops,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
/// \brief The types of events that can be delivered.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_EventType {
    ///< Unused (do not remove)
    SDL_FIRSTEVENT = 0,
    ///< User-requested quit
    SDL_QUIT = 256,
    ///< The application is being terminated by the OS
    ///Called on iOS in applicationWillTerminate()
    ///Called on Android in onDestroy()
    SDL_APP_TERMINATING = 257,
    ///< The application is low on memory, free memory if possible.
    ///Called on iOS in applicationDidReceiveMemoryWarning()
    ///Called on Android in onLowMemory()
    SDL_APP_LOWMEMORY = 258,
    ///< The application is about to enter the background
    ///Called on iOS in applicationWillResignActive()
    ///Called on Android in onPause()
    SDL_APP_WILLENTERBACKGROUND = 259,
    ///< The application did enter the background and may not get CPU for some time
    ///Called on iOS in applicationDidEnterBackground()
    ///Called on Android in onPause()
    SDL_APP_DIDENTERBACKGROUND = 260,
    ///< The application is about to enter the foreground
    ///Called on iOS in applicationWillEnterForeground()
    ///Called on Android in onResume()
    SDL_APP_WILLENTERFOREGROUND = 261,
    ///< The application is now interactive
    ///Called on iOS in applicationDidBecomeActive()
    ///Called on Android in onResume()
    SDL_APP_DIDENTERFOREGROUND = 262,
    ///< Window state change
    SDL_WINDOWEVENT = 512,
    ///< System specific event
    SDL_SYSWMEVENT = 513,
    ///< Key pressed
    SDL_KEYDOWN = 768,
    ///< Key released
    SDL_KEYUP = 769,
    ///< Keyboard text editing (composition)
    SDL_TEXTEDITING = 770,
    ///< Keyboard text input
    SDL_TEXTINPUT = 771,
    ///< Mouse moved
    SDL_MOUSEMOTION = 1024,
    ///< Mouse button pressed
    SDL_MOUSEBUTTONDOWN = 1025,
    ///< Mouse button released
    SDL_MOUSEBUTTONUP = 1026,
    ///< Mouse wheel motion
    SDL_MOUSEWHEEL = 1027,
    ///< Joystick axis motion
    SDL_JOYAXISMOTION = 1536,
    ///< Joystick trackball motion
    SDL_JOYBALLMOTION = 1537,
    ///< Joystick hat position change
    SDL_JOYHATMOTION = 1538,
    ///< Joystick button pressed
    SDL_JOYBUTTONDOWN = 1539,
    ///< Joystick button released
    SDL_JOYBUTTONUP = 1540,
    ///< A new joystick has been inserted into the system
    SDL_JOYDEVICEADDED = 1541,
    ///< An opened joystick has been removed
    SDL_JOYDEVICEREMOVED = 1542,
    ///< Game controller axis motion
    SDL_CONTROLLERAXISMOTION = 1616,
    ///< Game controller button pressed
    SDL_CONTROLLERBUTTONDOWN = 1617,
    ///< Game controller button released
    SDL_CONTROLLERBUTTONUP = 1618,
    ///< A new Game controller has been inserted into the system
    SDL_CONTROLLERDEVICEADDED = 1619,
    ///< An opened Game controller has been removed
    SDL_CONTROLLERDEVICEREMOVED = 1620,
    ///< The controller mapping was updated
    SDL_CONTROLLERDEVICEREMAPPED = 1621,
    SDL_FINGERDOWN = 1792,
    SDL_FINGERUP = 1793,
    SDL_FINGERMOTION = 1794,
    SDL_DOLLARGESTURE = 2048,
    SDL_DOLLARRECORD = 2049,
    SDL_MULTIGESTURE = 2050,
    ///< The clipboard changed
    SDL_CLIPBOARDUPDATE = 2304,
    ///< The system requests a file open
    SDL_DROPFILE = 4096,
    ///< The render targets have been reset
    SDL_RENDER_TARGETS_RESET = 8192,
    /// Events ::SDL_USEREVENT through ::SDL_LASTEVENT are for your use,
    ///  and should be allocated with SDL_RegisterEvents()
    SDL_USEREVENT = 32768,
    ///  This last event is only for bounding internal arrays
    SDL_LASTEVENT = 65535,
}
///  \brief Fields shared by every event
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_CommonEvent {
    pub type_: Uint32,
    pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_CommonEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_CommonEvent>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_CommonEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_CommonEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_CommonEvent))
    );
}
///  \brief Window state change event data (event.window.*)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_WindowEvent {
    ///< ::SDL_WINDOWEVENT
    pub type_: Uint32,
    pub timestamp: Uint32,
    ///< The associated window
    pub windowID: Uint32,
    ///< ::SDL_WindowEventID
    pub event: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    ///< event dependent data
    pub data1: Sint32,
    ///< event dependent data
    pub data2: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_WindowEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_WindowEvent>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_WindowEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_WindowEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_WindowEvent))
    );
}
///  \brief Keyboard button event structure (event.key.*)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_KeyboardEvent {
    ///< ::SDL_KEYDOWN or ::SDL_KEYUP
    pub type_: Uint32,
    pub timestamp: Uint32,
    ///< The window with keyboard focus, if any
    pub windowID: Uint32,
    ///< ::SDL_PRESSED or ::SDL_RELEASED
    pub state: Uint8,
    ///< Non-zero if this is a key repeat
    pub repeat: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    ///< The key that was pressed or released
    pub keysym: SDL_Keysym,
}
#[test]
fn bindgen_test_layout_SDL_KeyboardEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_KeyboardEvent>(),
        32usize,
        concat!("Size of: ", stringify!(SDL_KeyboardEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_KeyboardEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_KeyboardEvent))
    );
}
///  \brief Keyboard text editing event structure (event.edit.*)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_TextEditingEvent {
    ///< ::SDL_TEXTEDITING
    pub type_: Uint32,
    pub timestamp: Uint32,
    ///< The window with keyboard focus, if any
    pub windowID: Uint32,
    ///< The editing text
    pub text: [::std::os::raw::c_char; 32usize],
    ///< The start cursor of selected editing text
    pub start: Sint32,
    ///< The length of selected editing text
    pub length: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_TextEditingEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_TextEditingEvent>(),
        52usize,
        concat!("Size of: ", stringify!(SDL_TextEditingEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_TextEditingEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_TextEditingEvent))
    );
}
///  \brief Keyboard text input event structure (event.text.*)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_TextInputEvent {
    ///< ::SDL_TEXTINPUT
    pub type_: Uint32,
    pub timestamp: Uint32,
    ///< The window with keyboard focus, if any
    pub windowID: Uint32,
    ///< The input text
    pub text: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_SDL_TextInputEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_TextInputEvent>(),
        44usize,
        concat!("Size of: ", stringify!(SDL_TextInputEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_TextInputEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_TextInputEvent))
    );
}
///  \brief Mouse motion event structure (event.motion.*)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MouseMotionEvent {
    ///< ::SDL_MOUSEMOTION
    pub type_: Uint32,
    pub timestamp: Uint32,
    ///< The window with mouse focus, if any
    pub windowID: Uint32,
    ///< The mouse instance id, or SDL_TOUCH_MOUSEID
    pub which: Uint32,
    ///< The current button state
    pub state: Uint32,
    ///< X coordinate, relative to window
    pub x: Sint32,
    ///< Y coordinate, relative to window
    pub y: Sint32,
    ///< The relative motion in the X direction
    pub xrel: Sint32,
    ///< The relative motion in the Y direction
    pub yrel: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseMotionEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_MouseMotionEvent>(),
        36usize,
        concat!("Size of: ", stringify!(SDL_MouseMotionEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_MouseMotionEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_MouseMotionEvent))
    );
}
///  \brief Mouse button event structure (event.button.*)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MouseButtonEvent {
    ///< ::SDL_MOUSEBUTTONDOWN or ::SDL_MOUSEBUTTONUP
    pub type_: Uint32,
    pub timestamp: Uint32,
    ///< The window with mouse focus, if any
    pub windowID: Uint32,
    ///< The mouse instance id, or SDL_TOUCH_MOUSEID
    pub which: Uint32,
    ///< The mouse button index
    pub button: Uint8,
    ///< ::SDL_PRESSED or ::SDL_RELEASED
    pub state: Uint8,
    ///< 1 for single-click, 2 for double-click, etc.
    pub clicks: Uint8,
    pub padding1: Uint8,
    ///< X coordinate, relative to window
    pub x: Sint32,
    ///< Y coordinate, relative to window
    pub y: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseButtonEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_MouseButtonEvent>(),
        28usize,
        concat!("Size of: ", stringify!(SDL_MouseButtonEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_MouseButtonEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_MouseButtonEvent))
    );
}
///  \brief Mouse wheel event structure (event.wheel.*)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MouseWheelEvent {
    ///< ::SDL_MOUSEWHEEL
    pub type_: Uint32,
    pub timestamp: Uint32,
    ///< The window with mouse focus, if any
    pub windowID: Uint32,
    ///< The mouse instance id, or SDL_TOUCH_MOUSEID
    pub which: Uint32,
    ///< The amount scrolled horizontally, positive to the right and negative to the left
    pub x: Sint32,
    ///< The amount scrolled vertically, positive away from the user and negative toward the user
    pub y: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseWheelEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_MouseWheelEvent>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_MouseWheelEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_MouseWheelEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_MouseWheelEvent))
    );
}
///  \brief Joystick axis motion event structure (event.jaxis.*)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_JoyAxisEvent {
    ///< ::SDL_JOYAXISMOTION
    pub type_: Uint32,
    pub timestamp: Uint32,
    ///< The joystick instance id
    pub which: SDL_JoystickID,
    ///< The joystick axis index
    pub axis: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    ///< The axis value (range: -32768 to 32767)
    pub value: Sint16,
    pub padding4: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_JoyAxisEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_JoyAxisEvent>(),
        20usize,
        concat!("Size of: ", stringify!(SDL_JoyAxisEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_JoyAxisEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_JoyAxisEvent))
    );
}
///  \brief Joystick trackball motion event structure (event.jball.*)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_JoyBallEvent {
    ///< ::SDL_JOYBALLMOTION
    pub type_: Uint32,
    pub timestamp: Uint32,
    ///< The joystick instance id
    pub which: SDL_JoystickID,
    ///< The joystick trackball index
    pub ball: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    ///< The relative motion in the X direction
    pub xrel: Sint16,
    ///< The relative motion in the Y direction
    pub yrel: Sint16,
}
#[test]
fn bindgen_test_layout_SDL_JoyBallEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_JoyBallEvent>(),
        20usize,
        concat!("Size of: ", stringify!(SDL_JoyBallEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_JoyBallEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_JoyBallEvent))
    );
}
///  \brief Joystick hat position change event structure (event.jhat.*)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_JoyHatEvent {
    ///< ::SDL_JOYHATMOTION
    pub type_: Uint32,
    pub timestamp: Uint32,
    ///< The joystick instance id
    pub which: SDL_JoystickID,
    ///< The joystick hat index
    pub hat: Uint8,
    ///< The hat position value.
    ///   \sa ::SDL_HAT_LEFTUP ::SDL_HAT_UP ::SDL_HAT_RIGHTUP
    ///   \sa ::SDL_HAT_LEFT ::SDL_HAT_CENTERED ::SDL_HAT_RIGHT
    ///   \sa ::SDL_HAT_LEFTDOWN ::SDL_HAT_DOWN ::SDL_HAT_RIGHTDOWN
    ///
    ///   Note that zero means the POV is centered.
    pub value: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_JoyHatEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_JoyHatEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_JoyHatEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_JoyHatEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_JoyHatEvent))
    );
}
///  \brief Joystick button event structure (event.jbutton.*)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_JoyButtonEvent {
    ///< ::SDL_JOYBUTTONDOWN or ::SDL_JOYBUTTONUP
    pub type_: Uint32,
    pub timestamp: Uint32,
    ///< The joystick instance id
    pub which: SDL_JoystickID,
    ///< The joystick button index
    pub button: Uint8,
    ///< ::SDL_PRESSED or ::SDL_RELEASED
    pub state: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_JoyButtonEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_JoyButtonEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_JoyButtonEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_JoyButtonEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_JoyButtonEvent))
    );
}
///  \brief Joystick device event structure (event.jdevice.*)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_JoyDeviceEvent {
    ///< ::SDL_JOYDEVICEADDED or ::SDL_JOYDEVICEREMOVED
    pub type_: Uint32,
    pub timestamp: Uint32,
    ///< The joystick device index for the ADDED event, instance id for the REMOVED event
    pub which: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_JoyDeviceEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_JoyDeviceEvent>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_JoyDeviceEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_JoyDeviceEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_JoyDeviceEvent))
    );
}
///  \brief Game controller axis motion event structure (event.caxis.*)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_ControllerAxisEvent {
    ///< ::SDL_CONTROLLERAXISMOTION
    pub type_: Uint32,
    pub timestamp: Uint32,
    ///< The joystick instance id
    pub which: SDL_JoystickID,
    ///< The controller axis (SDL_GameControllerAxis)
    pub axis: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    ///< The axis value (range: -32768 to 32767)
    pub value: Sint16,
    pub padding4: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_ControllerAxisEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_ControllerAxisEvent>(),
        20usize,
        concat!("Size of: ", stringify!(SDL_ControllerAxisEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_ControllerAxisEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_ControllerAxisEvent))
    );
}
///  \brief Game controller button event structure (event.cbutton.*)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_ControllerButtonEvent {
    ///< ::SDL_CONTROLLERBUTTONDOWN or ::SDL_CONTROLLERBUTTONUP
    pub type_: Uint32,
    pub timestamp: Uint32,
    ///< The joystick instance id
    pub which: SDL_JoystickID,
    ///< The controller button (SDL_GameControllerButton)
    pub button: Uint8,
    ///< ::SDL_PRESSED or ::SDL_RELEASED
    pub state: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_ControllerButtonEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_ControllerButtonEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_ControllerButtonEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_ControllerButtonEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_ControllerButtonEvent))
    );
}
///  \brief Controller device event structure (event.cdevice.*)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_ControllerDeviceEvent {
    ///< ::SDL_CONTROLLERDEVICEADDED, ::SDL_CONTROLLERDEVICEREMOVED, or ::SDL_CONTROLLERDEVICEREMAPPED
    pub type_: Uint32,
    pub timestamp: Uint32,
    ///< The joystick device index for the ADDED event, instance id for the REMOVED or REMAPPED event
    pub which: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_ControllerDeviceEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_ControllerDeviceEvent>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_ControllerDeviceEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_ControllerDeviceEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_ControllerDeviceEvent))
    );
}
///  \brief Touch finger event structure (event.tfinger.*)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_TouchFingerEvent {
    ///< ::SDL_FINGERMOTION or ::SDL_FINGERDOWN or ::SDL_FINGERUP
    pub type_: Uint32,
    pub timestamp: Uint32,
    ///< The touch device id
    pub touchId: SDL_TouchID,
    pub fingerId: SDL_FingerID,
    ///< Normalized in the range 0...1
    pub x: f32,
    ///< Normalized in the range 0...1
    pub y: f32,
    ///< Normalized in the range 0...1
    pub dx: f32,
    ///< Normalized in the range 0...1
    pub dy: f32,
    ///< Normalized in the range 0...1
    pub pressure: f32,
}
#[test]
fn bindgen_test_layout_SDL_TouchFingerEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_TouchFingerEvent>(),
        48usize,
        concat!("Size of: ", stringify!(SDL_TouchFingerEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_TouchFingerEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_TouchFingerEvent))
    );
}
///  \brief Multiple Finger Gesture Event (event.mgesture.*)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MultiGestureEvent {
    ///< ::SDL_MULTIGESTURE
    pub type_: Uint32,
    pub timestamp: Uint32,
    ///< The touch device index
    pub touchId: SDL_TouchID,
    pub dTheta: f32,
    pub dDist: f32,
    pub x: f32,
    pub y: f32,
    pub numFingers: Uint16,
    pub padding: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_MultiGestureEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_MultiGestureEvent>(),
        40usize,
        concat!("Size of: ", stringify!(SDL_MultiGestureEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_MultiGestureEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_MultiGestureEvent))
    );
}
/// \brief Dollar Gesture Event (event.dgesture.*)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_DollarGestureEvent {
    ///< ::SDL_DOLLARGESTURE
    pub type_: Uint32,
    pub timestamp: Uint32,
    ///< The touch device id
    pub touchId: SDL_TouchID,
    pub gestureId: SDL_GestureID,
    pub numFingers: Uint32,
    pub error: f32,
    ///< Normalized center of gesture
    pub x: f32,
    ///< Normalized center of gesture
    pub y: f32,
}
#[test]
fn bindgen_test_layout_SDL_DollarGestureEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_DollarGestureEvent>(),
        40usize,
        concat!("Size of: ", stringify!(SDL_DollarGestureEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_DollarGestureEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_DollarGestureEvent))
    );
}
///  \brief An event used to request a file open by the system (event.drop.*)
///         This event is disabled by default, you can enable it with SDL_EventState()
///  \note If you enable this event, you must free the filename in the event.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_DropEvent {
    ///< ::SDL_DROPFILE
    pub type_: Uint32,
    pub timestamp: Uint32,
    ///< The file name, which should be freed with SDL_free()
    pub file: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_SDL_DropEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_DropEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_DropEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_DropEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_DropEvent))
    );
}
///  \brief The "quit requested" event
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_QuitEvent {
    ///< ::SDL_QUIT
    pub type_: Uint32,
    pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_QuitEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_QuitEvent>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_QuitEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_QuitEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_QuitEvent))
    );
}
///  \brief OS Specific event
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_OSEvent {
    ///< ::SDL_QUIT
    pub type_: Uint32,
    pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_OSEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_OSEvent>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_OSEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_OSEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_OSEvent))
    );
}
///  \brief A user-defined event type (event.user.*)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_UserEvent {
    ///< ::SDL_USEREVENT through ::SDL_LASTEVENT-1
    pub type_: Uint32,
    pub timestamp: Uint32,
    ///< The associated window if any
    pub windowID: Uint32,
    ///< User defined event code
    pub code: Sint32,
    ///< User defined data pointer
    pub data1: *mut ::std::os::raw::c_void,
    ///< User defined data pointer
    pub data2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SDL_UserEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_UserEvent>(),
        32usize,
        concat!("Size of: ", stringify!(SDL_UserEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_UserEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_UserEvent))
    );
}
///  \brief A video driver dependent system event (event.syswm.*)
///         This event is disabled by default, you can enable it with SDL_EventState()
///
///  \note If you want to use this event, you should include SDL_syswm.h.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMEvent {
    ///< ::SDL_SYSWMEVENT
    pub type_: Uint32,
    pub timestamp: Uint32,
    ///< driver dependent data, defined in SDL_syswm.h
    pub msg: *mut SDL_SysWMmsg,
}
#[test]
fn bindgen_test_layout_SDL_SysWMEvent() {
    assert_eq!(
        ::std::mem::size_of::<SDL_SysWMEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_SysWMEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_SysWMEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_SysWMEvent))
    );
}
///  \brief General event structure
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_Event {
    ///< Event type, shared with all events
    pub type_: Uint32,
    ///< Common event data
    pub common: SDL_CommonEvent,
    ///< Window event data
    pub window: SDL_WindowEvent,
    ///< Keyboard event data
    pub key: SDL_KeyboardEvent,
    ///< Text editing event data
    pub edit: SDL_TextEditingEvent,
    ///< Text input event data
    pub text: SDL_TextInputEvent,
    ///< Mouse motion event data
    pub motion: SDL_MouseMotionEvent,
    ///< Mouse button event data
    pub button: SDL_MouseButtonEvent,
    ///< Mouse wheel event data
    pub wheel: SDL_MouseWheelEvent,
    ///< Joystick axis event data
    pub jaxis: SDL_JoyAxisEvent,
    ///< Joystick ball event data
    pub jball: SDL_JoyBallEvent,
    ///< Joystick hat event data
    pub jhat: SDL_JoyHatEvent,
    ///< Joystick button event data
    pub jbutton: SDL_JoyButtonEvent,
    ///< Joystick device change event data
    pub jdevice: SDL_JoyDeviceEvent,
    ///< Game Controller axis event data
    pub caxis: SDL_ControllerAxisEvent,
    ///< Game Controller button event data
    pub cbutton: SDL_ControllerButtonEvent,
    ///< Game Controller device event data
    pub cdevice: SDL_ControllerDeviceEvent,
    ///< Quit request event data
    pub quit: SDL_QuitEvent,
    ///< Custom event data
    pub user: SDL_UserEvent,
    ///< System dependent window event data
    pub syswm: SDL_SysWMEvent,
    ///< Touch finger event data
    pub tfinger: SDL_TouchFingerEvent,
    ///< Gesture event data
    pub mgesture: SDL_MultiGestureEvent,
    ///< Gesture event data
    pub dgesture: SDL_DollarGestureEvent,
    ///< Drag and drop event data
    pub drop: SDL_DropEvent,
    pub padding: [Uint8; 56usize],
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_SDL_Event() {
    assert_eq!(
        ::std::mem::size_of::<SDL_Event>(),
        56usize,
        concat!("Size of: ", stringify!(SDL_Event))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_Event>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Event))
    );
}
extern "C" {
    ///  Pumps the event loop, gathering events from the input devices.
    ///
    ///  This function updates the event queue and internal input device state.
    ///
    ///  This should only be run in the thread that sets the video mode.
    pub fn SDL_PumpEvents();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_eventaction {
    SDL_ADDEVENT = 0,
    SDL_PEEKEVENT = 1,
    SDL_GETEVENT = 2,
}
extern "C" {
    ///  Checks the event queue for messages and optionally returns them.
    ///
    ///  If \c action is ::SDL_ADDEVENT, up to \c numevents events will be added to
    ///  the back of the event queue.
    ///
    ///  If \c action is ::SDL_PEEKEVENT, up to \c numevents events at the front
    ///  of the event queue, within the specified minimum and maximum type,
    ///  will be returned and will not be removed from the queue.
    ///
    ///  If \c action is ::SDL_GETEVENT, up to \c numevents events at the front
    ///  of the event queue, within the specified minimum and maximum type,
    ///  will be returned and will be removed from the queue.
    ///
    ///  \return The number of events actually stored, or -1 if there was an error.
    ///
    ///  This function is thread-safe.
    pub fn SDL_PeepEvents(
        events: *mut SDL_Event,
        numevents: ::std::os::raw::c_int,
        action: SDL_eventaction,
        minType: Uint32,
        maxType: Uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Checks to see if certain event types are in the event queue.
    pub fn SDL_HasEvent(type_: Uint32) -> SDL_bool;
}
extern "C" {
    pub fn SDL_HasEvents(minType: Uint32, maxType: Uint32) -> SDL_bool;
}
extern "C" {
    ///  This function clears events from the event queue
    pub fn SDL_FlushEvent(type_: Uint32);
}
extern "C" {
    pub fn SDL_FlushEvents(minType: Uint32, maxType: Uint32);
}
extern "C" {
    ///  \brief Polls for currently pending events.
    ///
    ///  \return 1 if there are any pending events, or 0 if there are none available.
    ///
    ///  \param event If not NULL, the next event is removed from the queue and
    ///               stored in that area.
    pub fn SDL_PollEvent(event: *mut SDL_Event) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Waits indefinitely for the next available event.
    ///
    ///  \return 1, or 0 if there was an error while waiting for events.
    ///
    ///  \param event If not NULL, the next event is removed from the queue and
    ///               stored in that area.
    pub fn SDL_WaitEvent(event: *mut SDL_Event) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Waits until the specified timeout (in milliseconds) for the next
    ///         available event.
    ///
    ///  \return 1, or 0 if there was an error while waiting for events.
    ///
    ///  \param event If not NULL, the next event is removed from the queue and
    ///               stored in that area.
    ///  \param timeout The timeout (in milliseconds) to wait for next event.
    pub fn SDL_WaitEventTimeout(
        event: *mut SDL_Event,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Add an event to the event queue.
    ///
    ///  \return 1 on success, 0 if the event was filtered, or -1 if the event queue
    ///          was full or there was some other error.
    pub fn SDL_PushEvent(event: *mut SDL_Event) -> ::std::os::raw::c_int;
}
pub type SDL_EventFilter = ::std::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::std::os::raw::c_void,
        event: *mut SDL_Event,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    ///  Sets up a filter to process all events before they change internal state and
    ///  are posted to the internal event queue.
    ///
    ///  The filter is prototyped as:
    ///  \code
    ///      int SDL_EventFilter(void *userdata, SDL_Event * event);
    ///  \endcode
    ///
    ///  If the filter returns 1, then the event will be added to the internal queue.
    ///  If it returns 0, then the event will be dropped from the queue, but the
    ///  internal state will still be updated.  This allows selective filtering of
    ///  dynamically arriving events.
    ///
    ///  \warning  Be very careful of what you do in the event filter function, as
    ///            it may run in a different thread!
    ///
    ///  There is one caveat when dealing with the ::SDL_QuitEvent event type.  The
    ///  event filter is only called when the window manager desires to close the
    ///  application window.  If the event filter returns 1, then the window will
    ///  be closed, otherwise the window will remain open if possible.
    ///
    ///  If the quit event is generated by an interrupt signal, it will bypass the
    ///  internal queue and be delivered to the application at the next event poll.
    pub fn SDL_SetEventFilter(filter: SDL_EventFilter, userdata: *mut ::std::os::raw::c_void);
}
extern "C" {
    ///  Return the current event filter - can be used to "chain" filters.
    ///  If there is no event filter set, this function returns SDL_FALSE.
    pub fn SDL_GetEventFilter(
        filter: *mut SDL_EventFilter,
        userdata: *mut *mut ::std::os::raw::c_void,
    ) -> SDL_bool;
}
extern "C" {
    ///  Add a function which is called when an event is added to the queue.
    pub fn SDL_AddEventWatch(filter: SDL_EventFilter, userdata: *mut ::std::os::raw::c_void);
}
extern "C" {
    ///  Remove an event watch function added with SDL_AddEventWatch()
    pub fn SDL_DelEventWatch(filter: SDL_EventFilter, userdata: *mut ::std::os::raw::c_void);
}
extern "C" {
    ///  Run the filter function on the current event queue, removing any
    ///  events for which the filter returns 0.
    pub fn SDL_FilterEvents(filter: SDL_EventFilter, userdata: *mut ::std::os::raw::c_void);
}
extern "C" {
    ///  This function allows you to set the state of processing certain events.
    ///   - If \c state is set to ::SDL_IGNORE, that event will be automatically
    ///     dropped from the event queue and will not event be filtered.
    ///   - If \c state is set to ::SDL_ENABLE, that event will be processed
    ///     normally.
    ///   - If \c state is set to ::SDL_QUERY, SDL_EventState() will return the
    ///     current processing state of the specified event.
    pub fn SDL_EventState(type_: Uint32, state: ::std::os::raw::c_int) -> Uint8;
}
extern "C" {
    ///  This function allocates a set of user-defined events, and returns
    ///  the beginning event number for that set of events.
    ///
    ///  If there aren't enough user-defined events left, this function
    ///  returns (Uint32)-1
    pub fn SDL_RegisterEvents(numevents: ::std::os::raw::c_int) -> Uint32;
}
extern "C" {
    /// \brief Get the path where the application resides.
    ///
    /// Get the "base path". This is the directory where the application was run
    ///  from, which is probably the installation directory, and may or may not
    ///  be the process's current working directory.
    ///
    /// This returns an absolute path in UTF-8 encoding, and is guaranteed to
    ///  end with a path separator ('\\' on Windows, '/' most other places).
    ///
    /// The pointer returned by this function is owned by you. Please call
    ///  SDL_free() on the pointer when you are done with it, or it will be a
    ///  memory leak. This is not necessarily a fast call, though, so you should
    ///  call this once near startup and save the string if you need it.
    ///
    /// Some platforms can't determine the application's path, and on other
    ///  platforms, this might be meaningless. In such cases, this function will
    ///  return NULL.
    ///
    ///  \return String of base dir in UTF-8 encoding, or NULL on error.
    ///
    /// \sa SDL_GetPrefPath
    pub fn SDL_GetBasePath() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// \brief Get the user-and-app-specific path where files can be written.
    ///
    /// Get the "pref dir". This is meant to be where users can write personal
    ///  files (preferences and save games, etc) that are specific to your
    ///  application. This directory is unique per user, per application.
    ///
    /// This function will decide the appropriate location in the native filesystem,
    ///  create the directory if necessary, and return a string of the absolute
    ///  path to the directory in UTF-8 encoding.
    ///
    /// On Windows, the string might look like:
    ///  "C:\\Users\\bob\\AppData\\Roaming\\My Company\\My Program Name\\"
    ///
    /// On Linux, the string might look like:
    ///  "/home/bob/.local/share/My Program Name/"
    ///
    /// On Mac OS X, the string might look like:
    ///  "/Users/bob/Library/Application Support/My Program Name/"
    ///
    /// (etc.)
    ///
    /// You specify the name of your organization (if it's not a real organization,
    ///  your name or an Internet domain you own might do) and the name of your
    ///  application. These should be untranslated proper names.
    ///
    /// Both the org and app strings may become part of a directory name, so
    ///  please follow these rules:
    ///
    ///    - Try to use the same org string (including case-sensitivity) for
    ///      all your applications that use this function.
    ///    - Always use a unique app string for each one, and make sure it never
    ///      changes for an app once you've decided on it.
    ///    - Unicode characters are legal, as long as it's UTF-8 encoded, but...
    ///    - ...only use letters, numbers, and spaces. Avoid punctuation like
    ///      "Game Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.
    ///
    /// This returns an absolute path in UTF-8 encoding, and is guaranteed to
    ///  end with a path separator ('\\' on Windows, '/' most other places).
    ///
    /// The pointer returned by this function is owned by you. Please call
    ///  SDL_free() on the pointer when you are done with it, or it will be a
    ///  memory leak. This is not necessarily a fast call, though, so you should
    ///  call this once near startup and save the string if you need it.
    ///
    /// You should assume the path returned by this function is the only safe
    ///  place to write files (and that SDL_GetBasePath(), while it might be
    ///  writable, or even the parent of the returned path, aren't where you
    ///  should be writing things).
    ///
    /// Some platforms can't determine the pref path, and on other
    ///  platforms, this might be meaningless. In such cases, this function will
    ///  return NULL.
    ///
    ///   \param org The name of your organization.
    ///   \param app The name of your application.
    ///  \return UTF-8 string of user dir in platform-dependent notation. NULL
    ///          if there's a problem (creating directory failed, etc).
    ///
    /// \sa SDL_GetBasePath
    pub fn SDL_GetPrefPath(
        org: *const ::std::os::raw::c_char,
        app: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
///  \typedef SDL_Haptic
///
///  \brief The haptic structure used to identify an SDL haptic.
///
///  \sa SDL_HapticOpen
///  \sa SDL_HapticOpenFromJoystick
///  \sa SDL_HapticClose
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SDL_Haptic {
    _unused: [u8; 0],
}
pub type SDL_Haptic = _SDL_Haptic;
///  \brief Structure that represents a haptic direction.
///
///  Directions can be specified by:
///   - ::SDL_HAPTIC_POLAR : Specified by polar coordinates.
///   - ::SDL_HAPTIC_CARTESIAN : Specified by cartesian coordinates.
///   - ::SDL_HAPTIC_SPHERICAL : Specified by spherical coordinates.
///
///  Cardinal directions of the haptic device are relative to the positioning
///  of the device.  North is considered to be away from the user.
///
///  The following diagram represents the cardinal directions:
///  \verbatim
///.--.
///|__| .-------.
///|=.| |.-----.|
///|--| ||     ||
///|  | |'-----'|
///|__|~')_____('
///[ COMPUTER ]
///
///
///North (0,-1)
///^
///|
///|
///(1,0)  West <----[ HAPTIC ]----> East (-1,0)
///|
///|
///v
///South (0,1)
///
///
///[ USER ]
///\|||/
///(o o)
///---ooO-(_)-Ooo---
///\endverbatim
///
///  If type is ::SDL_HAPTIC_POLAR, direction is encoded by hundredths of a
///  degree starting north and turning clockwise.  ::SDL_HAPTIC_POLAR only uses
///  the first \c dir parameter.  The cardinal directions would be:
///   - North: 0 (0 degrees)
///   - East: 9000 (90 degrees)
///   - South: 18000 (180 degrees)
///   - West: 27000 (270 degrees)
///
///  If type is ::SDL_HAPTIC_CARTESIAN, direction is encoded by three positions
///  (X axis, Y axis and Z axis (with 3 axes)).  ::SDL_HAPTIC_CARTESIAN uses
///  the first three \c dir parameters.  The cardinal directions would be:
///   - North:  0,-1, 0
///   - East:  -1, 0, 0
///   - South:  0, 1, 0
///   - West:   1, 0, 0
///
///  The Z axis represents the height of the effect if supported, otherwise
///  it's unused.  In cartesian encoding (1, 2) would be the same as (2, 4), you
///  can use any multiple you want, only the direction matters.
///
///  If type is ::SDL_HAPTIC_SPHERICAL, direction is encoded by two rotations.
///  The first two \c dir parameters are used.  The \c dir parameters are as
///  follows (all values are in hundredths of degrees):
///   - Degrees from (1, 0) rotated towards (0, 1).
///   - Degrees towards (0, 0, 1) (device needs at least 3 axes).
///
///
///  Example of force coming from the south with all encodings (force coming
///  from the south means the user will have to pull the stick to counteract):
///  \code
///  SDL_HapticDirection direction;
///
///  // Cartesian directions
///  direction.type = SDL_HAPTIC_CARTESIAN; // Using cartesian direction encoding.
///  direction.dir[0] = 0; // X position
///  direction.dir[1] = 1; // Y position
///  // Assuming the device has 2 axes, we don't need to specify third parameter.
///
///  // Polar directions
///  direction.type = SDL_HAPTIC_POLAR; // We'll be using polar direction encoding.
///  direction.dir[0] = 18000; // Polar only uses first parameter
///
///  // Spherical coordinates
///  direction.type = SDL_HAPTIC_SPHERICAL; // Spherical encoding
///  direction.dir[0] = 9000; // Since we only have two axes we don't need more parameters.
///  \endcode
///
///  \sa SDL_HAPTIC_POLAR
///  \sa SDL_HAPTIC_CARTESIAN
///  \sa SDL_HAPTIC_SPHERICAL
///  \sa SDL_HapticEffect
///  \sa SDL_HapticNumAxes
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_HapticDirection {
    ///< The type of encoding.
    pub type_: Uint8,
    ///< The encoded direction.
    pub dir: [Sint32; 3usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticDirection() {
    assert_eq!(
        ::std::mem::size_of::<SDL_HapticDirection>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_HapticDirection))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_HapticDirection>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticDirection))
    );
}
///  \brief A structure containing a template for a Constant effect.
///
///  The struct is exclusive to the ::SDL_HAPTIC_CONSTANT effect.
///
///  A constant effect applies a constant force in the specified direction
///  to the joystick.
///
///  \sa SDL_HAPTIC_CONSTANT
///  \sa SDL_HapticEffect
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_HapticConstant {
    ///< ::SDL_HAPTIC_CONSTANT
    pub type_: Uint16,
    ///< Direction of the effect.
    pub direction: SDL_HapticDirection,
    ///< Duration of the effect.
    pub length: Uint32,
    ///< Delay before starting the effect.
    pub delay: Uint16,
    ///< Button that triggers the effect.
    pub button: Uint16,
    ///< How soon it can be triggered again after button.
    pub interval: Uint16,
    ///< Strength of the constant effect.
    pub level: Sint16,
    ///< Duration of the attack.
    pub attack_length: Uint16,
    ///< Level at the start of the attack.
    pub attack_level: Uint16,
    ///< Duration of the fade.
    pub fade_length: Uint16,
    ///< Level at the end of the fade.
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticConstant() {
    assert_eq!(
        ::std::mem::size_of::<SDL_HapticConstant>(),
        40usize,
        concat!("Size of: ", stringify!(SDL_HapticConstant))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_HapticConstant>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticConstant))
    );
}
///  \brief A structure containing a template for a Periodic effect.
///
///  The struct handles the following effects:
///   - ::SDL_HAPTIC_SINE
///   - ::SDL_HAPTIC_LEFTRIGHT
///   - ::SDL_HAPTIC_TRIANGLE
///   - ::SDL_HAPTIC_SAWTOOTHUP
///   - ::SDL_HAPTIC_SAWTOOTHDOWN
///
///  A periodic effect consists in a wave-shaped effect that repeats itself
///  over time.  The type determines the shape of the wave and the parameters
///  determine the dimensions of the wave.
///
///  Phase is given by hundredth of a cycle meaning that giving the phase a value
///  of 9000 will displace it 25% of its period.  Here are sample values:
///   -     0: No phase displacement.
///   -  9000: Displaced 25% of its period.
///   - 18000: Displaced 50% of its period.
///   - 27000: Displaced 75% of its period.
///   - 36000: Displaced 100% of its period, same as 0, but 0 is preferred.
///
///  Examples:
///  \verbatim
///SDL_HAPTIC_SINE
///__      __      __      __
////  \    /  \    /  \    /
////    \__/    \__/    \__/
///
///SDL_HAPTIC_SQUARE
///__    __    __    __    __
///|  |  |  |  |  |  |  |  |  |
///|  |__|  |__|  |__|  |__|  |
///
///SDL_HAPTIC_TRIANGLE
////\    /\    /\    /\    /\
////  \  /  \  /  \  /  \  /
////    \/    \/    \/    \/
///
///SDL_HAPTIC_SAWTOOTHUP
////|  /|  /|  /|  /|  /|  /|
//// | / | / | / | / | / | / |
////  |/  |/  |/  |/  |/  |/  |
///
///SDL_HAPTIC_SAWTOOTHDOWN
///\  |\  |\  |\  |\  |\  |\  |
///\ | \ | \ | \ | \ | \ | \ |
///\|  \|  \|  \|  \|  \|  \|
///\endverbatim
///
///  \sa SDL_HAPTIC_SINE
///  \sa SDL_HAPTIC_LEFTRIGHT
///  \sa SDL_HAPTIC_TRIANGLE
///  \sa SDL_HAPTIC_SAWTOOTHUP
///  \sa SDL_HAPTIC_SAWTOOTHDOWN
///  \sa SDL_HapticEffect
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_HapticPeriodic {
    ///< ::SDL_HAPTIC_SINE, ::SDL_HAPTIC_LEFTRIGHT,
    ///::SDL_HAPTIC_TRIANGLE, ::SDL_HAPTIC_SAWTOOTHUP or
    ///::SDL_HAPTIC_SAWTOOTHDOWN
    pub type_: Uint16,
    ///< Direction of the effect.
    pub direction: SDL_HapticDirection,
    ///< Duration of the effect.
    pub length: Uint32,
    ///< Delay before starting the effect.
    pub delay: Uint16,
    ///< Button that triggers the effect.
    pub button: Uint16,
    ///< How soon it can be triggered again after button.
    pub interval: Uint16,
    ///< Period of the wave.
    pub period: Uint16,
    ///< Peak value.
    pub magnitude: Sint16,
    ///< Mean value of the wave.
    pub offset: Sint16,
    ///< Horizontal shift given by hundredth of a cycle.
    pub phase: Uint16,
    ///< Duration of the attack.
    pub attack_length: Uint16,
    ///< Level at the start of the attack.
    pub attack_level: Uint16,
    ///< Duration of the fade.
    pub fade_length: Uint16,
    ///< Level at the end of the fade.
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticPeriodic() {
    assert_eq!(
        ::std::mem::size_of::<SDL_HapticPeriodic>(),
        48usize,
        concat!("Size of: ", stringify!(SDL_HapticPeriodic))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_HapticPeriodic>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticPeriodic))
    );
}
///  \brief A structure containing a template for a Condition effect.
///
///  The struct handles the following effects:
///   - ::SDL_HAPTIC_SPRING: Effect based on axes position.
///   - ::SDL_HAPTIC_DAMPER: Effect based on axes velocity.
///   - ::SDL_HAPTIC_INERTIA: Effect based on axes acceleration.
///   - ::SDL_HAPTIC_FRICTION: Effect based on axes movement.
///
///  Direction is handled by condition internals instead of a direction member.
///  The condition effect specific members have three parameters.  The first
///  refers to the X axis, the second refers to the Y axis and the third
///  refers to the Z axis.  The right terms refer to the positive side of the
///  axis and the left terms refer to the negative side of the axis.  Please
///  refer to the ::SDL_HapticDirection diagram for which side is positive and
///  which is negative.
///
///  \sa SDL_HapticDirection
///  \sa SDL_HAPTIC_SPRING
///  \sa SDL_HAPTIC_DAMPER
///  \sa SDL_HAPTIC_INERTIA
///  \sa SDL_HAPTIC_FRICTION
///  \sa SDL_HapticEffect
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_HapticCondition {
    ///< ::SDL_HAPTIC_SPRING, ::SDL_HAPTIC_DAMPER,
    ///::SDL_HAPTIC_INERTIA or ::SDL_HAPTIC_FRICTION
    pub type_: Uint16,
    ///< Direction of the effect - Not used ATM.
    pub direction: SDL_HapticDirection,
    ///< Duration of the effect.
    pub length: Uint32,
    ///< Delay before starting the effect.
    pub delay: Uint16,
    ///< Button that triggers the effect.
    pub button: Uint16,
    ///< How soon it can be triggered again after button.
    pub interval: Uint16,
    ///< Level when joystick is to the positive side.
    pub right_sat: [Uint16; 3usize],
    ///< Level when joystick is to the negative side.
    pub left_sat: [Uint16; 3usize],
    ///< How fast to increase the force towards the positive side.
    pub right_coeff: [Sint16; 3usize],
    ///< How fast to increase the force towards the negative side.
    pub left_coeff: [Sint16; 3usize],
    ///< Size of the dead zone.
    pub deadband: [Uint16; 3usize],
    ///< Position of the dead zone.
    pub center: [Sint16; 3usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticCondition() {
    assert_eq!(
        ::std::mem::size_of::<SDL_HapticCondition>(),
        68usize,
        concat!("Size of: ", stringify!(SDL_HapticCondition))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_HapticCondition>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticCondition))
    );
}
///  \brief A structure containing a template for a Ramp effect.
///
///  This struct is exclusively for the ::SDL_HAPTIC_RAMP effect.
///
///  The ramp effect starts at start strength and ends at end strength.
///  It augments in linear fashion.  If you use attack and fade with a ramp
///  the effects get added to the ramp effect making the effect become
///  quadratic instead of linear.
///
///  \sa SDL_HAPTIC_RAMP
///  \sa SDL_HapticEffect
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_HapticRamp {
    ///< ::SDL_HAPTIC_RAMP
    pub type_: Uint16,
    ///< Direction of the effect.
    pub direction: SDL_HapticDirection,
    ///< Duration of the effect.
    pub length: Uint32,
    ///< Delay before starting the effect.
    pub delay: Uint16,
    ///< Button that triggers the effect.
    pub button: Uint16,
    ///< How soon it can be triggered again after button.
    pub interval: Uint16,
    ///< Beginning strength level.
    pub start: Sint16,
    ///< Ending strength level.
    pub end: Sint16,
    ///< Duration of the attack.
    pub attack_length: Uint16,
    ///< Level at the start of the attack.
    pub attack_level: Uint16,
    ///< Duration of the fade.
    pub fade_length: Uint16,
    ///< Level at the end of the fade.
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticRamp() {
    assert_eq!(
        ::std::mem::size_of::<SDL_HapticRamp>(),
        44usize,
        concat!("Size of: ", stringify!(SDL_HapticRamp))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_HapticRamp>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticRamp))
    );
}
/// \brief A structure containing a template for a Left/Right effect.
///
/// This struct is exclusively for the ::SDL_HAPTIC_LEFTRIGHT effect.
///
/// The Left/Right effect is used to explicitly control the large and small
/// motors, commonly found in modern game controllers. One motor is high
/// frequency, the other is low frequency.
///
/// \sa SDL_HAPTIC_LEFTRIGHT
/// \sa SDL_HapticEffect
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_HapticLeftRight {
    ///< ::SDL_HAPTIC_LEFTRIGHT
    pub type_: Uint16,
    ///< Duration of the effect.
    pub length: Uint32,
    ///< Control of the large controller motor.
    pub large_magnitude: Uint16,
    ///< Control of the small controller motor.
    pub small_magnitude: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticLeftRight() {
    assert_eq!(
        ::std::mem::size_of::<SDL_HapticLeftRight>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_HapticLeftRight))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_HapticLeftRight>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticLeftRight))
    );
}
///  \brief A structure containing a template for the ::SDL_HAPTIC_CUSTOM effect.
///
///  A custom force feedback effect is much like a periodic effect, where the
///  application can define its exact shape.  You will have to allocate the
///  data yourself.  Data should consist of channels * samples Uint16 samples.
///
///  If channels is one, the effect is rotated using the defined direction.
///  Otherwise it uses the samples in data for the different axes.
///
///  \sa SDL_HAPTIC_CUSTOM
///  \sa SDL_HapticEffect
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_HapticCustom {
    ///< ::SDL_HAPTIC_CUSTOM
    pub type_: Uint16,
    ///< Direction of the effect.
    pub direction: SDL_HapticDirection,
    ///< Duration of the effect.
    pub length: Uint32,
    ///< Delay before starting the effect.
    pub delay: Uint16,
    ///< Button that triggers the effect.
    pub button: Uint16,
    ///< How soon it can be triggered again after button.
    pub interval: Uint16,
    ///< Axes to use, minimum of one.
    pub channels: Uint8,
    ///< Sample periods.
    pub period: Uint16,
    ///< Amount of samples.
    pub samples: Uint16,
    ///< Should contain channels*samples items.
    pub data: *mut Uint16,
    ///< Duration of the attack.
    pub attack_length: Uint16,
    ///< Level at the start of the attack.
    pub attack_level: Uint16,
    ///< Duration of the fade.
    pub fade_length: Uint16,
    ///< Level at the end of the fade.
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticCustom() {
    assert_eq!(
        ::std::mem::size_of::<SDL_HapticCustom>(),
        56usize,
        concat!("Size of: ", stringify!(SDL_HapticCustom))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_HapticCustom>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_HapticCustom))
    );
}
///  \brief The generic template for any haptic effect.
///
///  All values max at 32767 (0x7FFF).  Signed values also can be negative.
///  Time values unless specified otherwise are in milliseconds.
///
///  You can also pass ::SDL_HAPTIC_INFINITY to length instead of a 0-32767
///  value.  Neither delay, interval, attack_length nor fade_length support
///  ::SDL_HAPTIC_INFINITY.  Fade will also not be used since effect never ends.
///
///  Additionally, the ::SDL_HAPTIC_RAMP effect does not support a duration of
///  ::SDL_HAPTIC_INFINITY.
///
///  Button triggers may not be supported on all devices, it is advised to not
///  use them if possible.  Buttons start at index 1 instead of index 0 like
///  the joystick.
///
///  If both attack_length and fade_level are 0, the envelope is not used,
///  otherwise both values are used.
///
///  Common parts:
///  \code
///  // Replay - All effects have this
///  Uint32 length;        // Duration of effect (ms).
///  Uint16 delay;         // Delay before starting effect.
///
///  // Trigger - All effects have this
///  Uint16 button;        // Button that triggers effect.
///  Uint16 interval;      // How soon before effect can be triggered again.
///
///  // Envelope - All effects except condition effects have this
///  Uint16 attack_length; // Duration of the attack (ms).
///  Uint16 attack_level;  // Level at the start of the attack.
///  Uint16 fade_length;   // Duration of the fade out (ms).
///  Uint16 fade_level;    // Level at the end of the fade.
///  \endcode
///
///
///  Here we have an example of a constant effect evolution in time:
///  \verbatim
///Strength
///^
///|
///|    effect level -->  _________________
///|                     /                 \
///|                    /                   \
///|                   /                     \
///|                  /                       \
///| attack_level --> |                        \
///|                  |                        |  <---  fade_level
///|
///+--------------------------------------------------> Time
///[--]                 [---]
///attack_length        fade_length
///
///[------------------][-----------------------]
///delay               length
///\endverbatim
///
///  Note either the attack_level or the fade_level may be above the actual
///  effect level.
///
///  \sa SDL_HapticConstant
///  \sa SDL_HapticPeriodic
///  \sa SDL_HapticCondition
///  \sa SDL_HapticRamp
///  \sa SDL_HapticLeftRight
///  \sa SDL_HapticCustom
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_HapticEffect {
    ///< Effect type.
    pub type_: Uint16,
    ///< Constant effect.
    pub constant: SDL_HapticConstant,
    ///< Periodic effect.
    pub periodic: SDL_HapticPeriodic,
    ///< Condition effect.
    pub condition: SDL_HapticCondition,
    ///< Ramp effect.
    pub ramp: SDL_HapticRamp,
    ///< Left/Right effect.
    pub leftright: SDL_HapticLeftRight,
    ///< Custom effect.
    pub custom: SDL_HapticCustom,
    _bindgen_union_align: [u64; 9usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticEffect() {
    assert_eq!(
        ::std::mem::size_of::<SDL_HapticEffect>(),
        72usize,
        concat!("Size of: ", stringify!(SDL_HapticEffect))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_HapticEffect>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_HapticEffect))
    );
}
extern "C" {
    ///  \brief Count the number of haptic devices attached to the system.
    ///
    ///  \return Number of haptic devices detected on the system.
    pub fn SDL_NumHaptics() -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the implementation dependent name of a Haptic device.
    ///
    ///  This can be called before any joysticks are opened.
    ///  If no name can be found, this function returns NULL.
    ///
    ///  \param device_index Index of the device to get its name.
    ///  \return Name of the device or NULL on error.
    ///
    ///  \sa SDL_NumHaptics
    pub fn SDL_HapticName(device_index: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    ///  \brief Opens a Haptic device for usage.
    ///
    ///  The index passed as an argument refers to the N'th Haptic device on this
    ///  system.
    ///
    ///  When opening a haptic device, its gain will be set to maximum and
    ///  autocenter will be disabled.  To modify these values use
    ///  SDL_HapticSetGain() and SDL_HapticSetAutocenter().
    ///
    ///  \param device_index Index of the device to open.
    ///  \return Device identifier or NULL on error.
    ///
    ///  \sa SDL_HapticIndex
    ///  \sa SDL_HapticOpenFromMouse
    ///  \sa SDL_HapticOpenFromJoystick
    ///  \sa SDL_HapticClose
    ///  \sa SDL_HapticSetGain
    ///  \sa SDL_HapticSetAutocenter
    ///  \sa SDL_HapticPause
    ///  \sa SDL_HapticStopAll
    pub fn SDL_HapticOpen(device_index: ::std::os::raw::c_int) -> *mut SDL_Haptic;
}
extern "C" {
    ///  \brief Checks if the haptic device at index has been opened.
    ///
    ///  \param device_index Index to check to see if it has been opened.
    ///  \return 1 if it has been opened or 0 if it hasn't.
    ///
    ///  \sa SDL_HapticOpen
    ///  \sa SDL_HapticIndex
    pub fn SDL_HapticOpened(device_index: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Gets the index of a haptic device.
    ///
    ///  \param haptic Haptic device to get the index of.
    ///  \return The index of the haptic device or -1 on error.
    ///
    ///  \sa SDL_HapticOpen
    ///  \sa SDL_HapticOpened
    pub fn SDL_HapticIndex(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Gets whether or not the current mouse has haptic capabilities.
    ///
    ///  \return SDL_TRUE if the mouse is haptic, SDL_FALSE if it isn't.
    ///
    ///  \sa SDL_HapticOpenFromMouse
    pub fn SDL_MouseIsHaptic() -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Tries to open a haptic device from the current mouse.
    ///
    ///  \return The haptic device identifier or NULL on error.
    ///
    ///  \sa SDL_MouseIsHaptic
    ///  \sa SDL_HapticOpen
    pub fn SDL_HapticOpenFromMouse() -> *mut SDL_Haptic;
}
extern "C" {
    ///  \brief Checks to see if a joystick has haptic features.
    ///
    ///  \param joystick Joystick to test for haptic capabilities.
    ///  \return 1 if the joystick is haptic, 0 if it isn't
    ///          or -1 if an error ocurred.
    ///
    ///  \sa SDL_HapticOpenFromJoystick
    pub fn SDL_JoystickIsHaptic(joystick: *mut SDL_Joystick) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Opens a Haptic device for usage from a Joystick device.
    ///
    ///  You must still close the haptic device seperately.  It will not be closed
    ///  with the joystick.
    ///
    ///  When opening from a joystick you should first close the haptic device before
    ///  closing the joystick device.  If not, on some implementations the haptic
    ///  device will also get unallocated and you'll be unable to use force feedback
    ///  on that device.
    ///
    ///  \param joystick Joystick to create a haptic device from.
    ///  \return A valid haptic device identifier on success or NULL on error.
    ///
    ///  \sa SDL_HapticOpen
    ///  \sa SDL_HapticClose
    pub fn SDL_HapticOpenFromJoystick(joystick: *mut SDL_Joystick) -> *mut SDL_Haptic;
}
extern "C" {
    ///  \brief Closes a Haptic device previously opened with SDL_HapticOpen().
    ///
    ///  \param haptic Haptic device to close.
    pub fn SDL_HapticClose(haptic: *mut SDL_Haptic);
}
extern "C" {
    ///  \brief Returns the number of effects a haptic device can store.
    ///
    ///  On some platforms this isn't fully supported, and therefore is an
    ///  approximation.  Always check to see if your created effect was actually
    ///  created and do not rely solely on SDL_HapticNumEffects().
    ///
    ///  \param haptic The haptic device to query effect max.
    ///  \return The number of effects the haptic device can store or
    ///          -1 on error.
    ///
    ///  \sa SDL_HapticNumEffectsPlaying
    ///  \sa SDL_HapticQuery
    pub fn SDL_HapticNumEffects(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Returns the number of effects a haptic device can play at the same
    ///         time.
    ///
    ///  This is not supported on all platforms, but will always return a value.
    ///  Added here for the sake of completeness.
    ///
    ///  \param haptic The haptic device to query maximum playing effects.
    ///  \return The number of effects the haptic device can play at the same time
    ///          or -1 on error.
    ///
    ///  \sa SDL_HapticNumEffects
    ///  \sa SDL_HapticQuery
    pub fn SDL_HapticNumEffectsPlaying(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Gets the haptic devices supported features in bitwise matter.
    ///
    ///  Example:
    ///  \code
    ///  if (SDL_HapticQuery(haptic) & SDL_HAPTIC_CONSTANT) {
    ///      printf("We have constant haptic effect!");
    ///  }
    ///  \endcode
    ///
    ///  \param haptic The haptic device to query.
    ///  \return Haptic features in bitwise manner (OR'd).
    ///
    ///  \sa SDL_HapticNumEffects
    ///  \sa SDL_HapticEffectSupported
    pub fn SDL_HapticQuery(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_uint;
}
extern "C" {
    ///  \brief Gets the number of haptic axes the device has.
    ///
    ///  \sa SDL_HapticDirection
    pub fn SDL_HapticNumAxes(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Checks to see if effect is supported by haptic.
    ///
    ///  \param haptic Haptic device to check on.
    ///  \param effect Effect to check to see if it is supported.
    ///  \return SDL_TRUE if effect is supported, SDL_FALSE if it isn't or -1 on error.
    ///
    ///  \sa SDL_HapticQuery
    ///  \sa SDL_HapticNewEffect
    pub fn SDL_HapticEffectSupported(
        haptic: *mut SDL_Haptic,
        effect: *mut SDL_HapticEffect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Creates a new haptic effect on the device.
    ///
    ///  \param haptic Haptic device to create the effect on.
    ///  \param effect Properties of the effect to create.
    ///  \return The id of the effect on success or -1 on error.
    ///
    ///  \sa SDL_HapticUpdateEffect
    ///  \sa SDL_HapticRunEffect
    ///  \sa SDL_HapticDestroyEffect
    pub fn SDL_HapticNewEffect(
        haptic: *mut SDL_Haptic,
        effect: *mut SDL_HapticEffect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Updates the properties of an effect.
    ///
    ///  Can be used dynamically, although behaviour when dynamically changing
    ///  direction may be strange.  Specifically the effect may reupload itself
    ///  and start playing from the start.  You cannot change the type either when
    ///  running SDL_HapticUpdateEffect().
    ///
    ///  \param haptic Haptic device that has the effect.
    ///  \param effect Effect to update.
    ///  \param data New effect properties to use.
    ///  \return 0 on success or -1 on error.
    ///
    ///  \sa SDL_HapticNewEffect
    ///  \sa SDL_HapticRunEffect
    ///  \sa SDL_HapticDestroyEffect
    pub fn SDL_HapticUpdateEffect(
        haptic: *mut SDL_Haptic,
        effect: ::std::os::raw::c_int,
        data: *mut SDL_HapticEffect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Runs the haptic effect on its associated haptic device.
    ///
    ///  If iterations are ::SDL_HAPTIC_INFINITY, it'll run the effect over and over
    ///  repeating the envelope (attack and fade) every time.  If you only want the
    ///  effect to last forever, set ::SDL_HAPTIC_INFINITY in the effect's length
    ///  parameter.
    ///
    ///  \param haptic Haptic device to run the effect on.
    ///  \param effect Identifier of the haptic effect to run.
    ///  \param iterations Number of iterations to run the effect. Use
    ///         ::SDL_HAPTIC_INFINITY for infinity.
    ///  \return 0 on success or -1 on error.
    ///
    ///  \sa SDL_HapticStopEffect
    ///  \sa SDL_HapticDestroyEffect
    ///  \sa SDL_HapticGetEffectStatus
    pub fn SDL_HapticRunEffect(
        haptic: *mut SDL_Haptic,
        effect: ::std::os::raw::c_int,
        iterations: Uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Stops the haptic effect on its associated haptic device.
    ///
    ///  \param haptic Haptic device to stop the effect on.
    ///  \param effect Identifier of the effect to stop.
    ///  \return 0 on success or -1 on error.
    ///
    ///  \sa SDL_HapticRunEffect
    ///  \sa SDL_HapticDestroyEffect
    pub fn SDL_HapticStopEffect(
        haptic: *mut SDL_Haptic,
        effect: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Destroys a haptic effect on the device.
    ///
    ///  This will stop the effect if it's running.  Effects are automatically
    ///  destroyed when the device is closed.
    ///
    ///  \param haptic Device to destroy the effect on.
    ///  \param effect Identifier of the effect to destroy.
    ///
    ///  \sa SDL_HapticNewEffect
    pub fn SDL_HapticDestroyEffect(haptic: *mut SDL_Haptic, effect: ::std::os::raw::c_int);
}
extern "C" {
    ///  \brief Gets the status of the current effect on the haptic device.
    ///
    ///  Device must support the ::SDL_HAPTIC_STATUS feature.
    ///
    ///  \param haptic Haptic device to query the effect status on.
    ///  \param effect Identifier of the effect to query its status.
    ///  \return 0 if it isn't playing, 1 if it is playing or -1 on error.
    ///
    ///  \sa SDL_HapticRunEffect
    ///  \sa SDL_HapticStopEffect
    pub fn SDL_HapticGetEffectStatus(
        haptic: *mut SDL_Haptic,
        effect: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Sets the global gain of the device.
    ///
    ///  Device must support the ::SDL_HAPTIC_GAIN feature.
    ///
    ///  The user may specify the maximum gain by setting the environment variable
    ///  SDL_HAPTIC_GAIN_MAX which should be between 0 and 100.  All calls to
    ///  SDL_HapticSetGain() will scale linearly using SDL_HAPTIC_GAIN_MAX as the
    ///  maximum.
    ///
    ///  \param haptic Haptic device to set the gain on.
    ///  \param gain Value to set the gain to, should be between 0 and 100.
    ///  \return 0 on success or -1 on error.
    ///
    ///  \sa SDL_HapticQuery
    pub fn SDL_HapticSetGain(
        haptic: *mut SDL_Haptic,
        gain: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Sets the global autocenter of the device.
    ///
    ///  Autocenter should be between 0 and 100.  Setting it to 0 will disable
    ///  autocentering.
    ///
    ///  Device must support the ::SDL_HAPTIC_AUTOCENTER feature.
    ///
    ///  \param haptic Haptic device to set autocentering on.
    ///  \param autocenter Value to set autocenter to, 0 disables autocentering.
    ///  \return 0 on success or -1 on error.
    ///
    ///  \sa SDL_HapticQuery
    pub fn SDL_HapticSetAutocenter(
        haptic: *mut SDL_Haptic,
        autocenter: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Pauses a haptic device.
    ///
    ///  Device must support the ::SDL_HAPTIC_PAUSE feature.  Call
    ///  SDL_HapticUnpause() to resume playback.
    ///
    ///  Do not modify the effects nor add new ones while the device is paused.
    ///  That can cause all sorts of weird errors.
    ///
    ///  \param haptic Haptic device to pause.
    ///  \return 0 on success or -1 on error.
    ///
    ///  \sa SDL_HapticUnpause
    pub fn SDL_HapticPause(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Unpauses a haptic device.
    ///
    ///  Call to unpause after SDL_HapticPause().
    ///
    ///  \param haptic Haptic device to pause.
    ///  \return 0 on success or -1 on error.
    ///
    ///  \sa SDL_HapticPause
    pub fn SDL_HapticUnpause(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Stops all the currently playing effects on a haptic device.
    ///
    ///  \param haptic Haptic device to stop.
    ///  \return 0 on success or -1 on error.
    pub fn SDL_HapticStopAll(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Checks to see if rumble is supported on a haptic device.
    ///
    ///  \param haptic Haptic device to check to see if it supports rumble.
    ///  \return SDL_TRUE if effect is supported, SDL_FALSE if it isn't or -1 on error.
    ///
    ///  \sa SDL_HapticRumbleInit
    ///  \sa SDL_HapticRumblePlay
    ///  \sa SDL_HapticRumbleStop
    pub fn SDL_HapticRumbleSupported(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Initializes the haptic device for simple rumble playback.
    ///
    ///  \param haptic Haptic device to initialize for simple rumble playback.
    ///  \return 0 on success or -1 on error.
    ///
    ///  \sa SDL_HapticOpen
    ///  \sa SDL_HapticRumbleSupported
    ///  \sa SDL_HapticRumblePlay
    ///  \sa SDL_HapticRumbleStop
    pub fn SDL_HapticRumbleInit(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Runs simple rumble on a haptic device
    ///
    ///  \param haptic Haptic device to play rumble effect on.
    ///  \param strength Strength of the rumble to play as a 0-1 float value.
    ///  \param length Length of the rumble to play in milliseconds.
    ///  \return 0 on success or -1 on error.
    ///
    ///  \sa SDL_HapticRumbleSupported
    ///  \sa SDL_HapticRumbleInit
    ///  \sa SDL_HapticRumbleStop
    pub fn SDL_HapticRumblePlay(
        haptic: *mut SDL_Haptic,
        strength: f32,
        length: Uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Stops the simple rumble on a haptic device.
    ///
    ///  \param haptic Haptic to stop the rumble on.
    ///  \return 0 on success or -1 on error.
    ///
    ///  \sa SDL_HapticRumbleSupported
    ///  \sa SDL_HapticRumbleInit
    ///  \sa SDL_HapticRumblePlay
    pub fn SDL_HapticRumbleStop(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
#[repr(u32)]
///  \brief  An enumeration of hint priorities
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_HintPriority {
    SDL_HINT_DEFAULT = 0,
    SDL_HINT_NORMAL = 1,
    SDL_HINT_OVERRIDE = 2,
}
extern "C" {
    ///  \brief Set a hint with a specific priority
    ///
    ///  The priority controls the behavior when setting a hint that already
    ///  has a value.  Hints will replace existing hints of their priority and
    ///  lower.  Environment variables are considered to have override priority.
    ///
    ///  \return SDL_TRUE if the hint was set, SDL_FALSE otherwise
    pub fn SDL_SetHintWithPriority(
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        priority: SDL_HintPriority,
    ) -> SDL_bool;
}
extern "C" {
    ///  \brief Set a hint with normal priority
    ///
    ///  \return SDL_TRUE if the hint was set, SDL_FALSE otherwise
    pub fn SDL_SetHint(
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> SDL_bool;
}
extern "C" {
    ///  \brief Get a hint
    ///
    ///  \return The string value of a hint variable.
    pub fn SDL_GetHint(name: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
///  \brief Add a function to watch a particular hint
///
///  \param name The hint to watch
///  \param callback The function to call when the hint value changes
///  \param userdata A pointer to pass to the callback function
pub type SDL_HintCallback = ::std::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        oldValue: *const ::std::os::raw::c_char,
        newValue: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    pub fn SDL_AddHintCallback(
        name: *const ::std::os::raw::c_char,
        callback: SDL_HintCallback,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    ///  \brief Remove a function watching a particular hint
    ///
    ///  \param name The hint being watched
    ///  \param callback The function being called when the hint value changes
    ///  \param userdata A pointer being passed to the callback function
    pub fn SDL_DelHintCallback(
        name: *const ::std::os::raw::c_char,
        callback: SDL_HintCallback,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    ///  \brief  Clear all hints
    ///
    ///  This function is called during SDL_Quit() to free stored hints.
    pub fn SDL_ClearHints();
}
extern "C" {
    ///  This function dynamically loads a shared object and returns a pointer
    ///  to the object handle (or NULL if there was an error).
    ///  The 'sofile' parameter is a system dependent name of the object file.
    pub fn SDL_LoadObject(sofile: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    ///  Given an object handle, this function looks up the address of the
    ///  named function in the shared object and returns it.  This address
    ///  is no longer valid after calling SDL_UnloadObject().
    pub fn SDL_LoadFunction(
        handle: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    ///  Unload a shared object from memory.
    pub fn SDL_UnloadObject(handle: *mut ::std::os::raw::c_void);
}
pub const SDL_LOG_CATEGORY_APPLICATION: _bindgen_ty_10 =
    _bindgen_ty_10::SDL_LOG_CATEGORY_APPLICATION;
pub const SDL_LOG_CATEGORY_ERROR: _bindgen_ty_10 = _bindgen_ty_10::SDL_LOG_CATEGORY_ERROR;
pub const SDL_LOG_CATEGORY_ASSERT: _bindgen_ty_10 = _bindgen_ty_10::SDL_LOG_CATEGORY_ASSERT;
pub const SDL_LOG_CATEGORY_SYSTEM: _bindgen_ty_10 = _bindgen_ty_10::SDL_LOG_CATEGORY_SYSTEM;
pub const SDL_LOG_CATEGORY_AUDIO: _bindgen_ty_10 = _bindgen_ty_10::SDL_LOG_CATEGORY_AUDIO;
pub const SDL_LOG_CATEGORY_VIDEO: _bindgen_ty_10 = _bindgen_ty_10::SDL_LOG_CATEGORY_VIDEO;
pub const SDL_LOG_CATEGORY_RENDER: _bindgen_ty_10 = _bindgen_ty_10::SDL_LOG_CATEGORY_RENDER;
pub const SDL_LOG_CATEGORY_INPUT: _bindgen_ty_10 = _bindgen_ty_10::SDL_LOG_CATEGORY_INPUT;
pub const SDL_LOG_CATEGORY_TEST: _bindgen_ty_10 = _bindgen_ty_10::SDL_LOG_CATEGORY_TEST;
pub const SDL_LOG_CATEGORY_RESERVED1: _bindgen_ty_10 = _bindgen_ty_10::SDL_LOG_CATEGORY_RESERVED1;
pub const SDL_LOG_CATEGORY_RESERVED2: _bindgen_ty_10 = _bindgen_ty_10::SDL_LOG_CATEGORY_RESERVED2;
pub const SDL_LOG_CATEGORY_RESERVED3: _bindgen_ty_10 = _bindgen_ty_10::SDL_LOG_CATEGORY_RESERVED3;
pub const SDL_LOG_CATEGORY_RESERVED4: _bindgen_ty_10 = _bindgen_ty_10::SDL_LOG_CATEGORY_RESERVED4;
pub const SDL_LOG_CATEGORY_RESERVED5: _bindgen_ty_10 = _bindgen_ty_10::SDL_LOG_CATEGORY_RESERVED5;
pub const SDL_LOG_CATEGORY_RESERVED6: _bindgen_ty_10 = _bindgen_ty_10::SDL_LOG_CATEGORY_RESERVED6;
pub const SDL_LOG_CATEGORY_RESERVED7: _bindgen_ty_10 = _bindgen_ty_10::SDL_LOG_CATEGORY_RESERVED7;
pub const SDL_LOG_CATEGORY_RESERVED8: _bindgen_ty_10 = _bindgen_ty_10::SDL_LOG_CATEGORY_RESERVED8;
pub const SDL_LOG_CATEGORY_RESERVED9: _bindgen_ty_10 = _bindgen_ty_10::SDL_LOG_CATEGORY_RESERVED9;
pub const SDL_LOG_CATEGORY_RESERVED10: _bindgen_ty_10 = _bindgen_ty_10::SDL_LOG_CATEGORY_RESERVED10;
pub const SDL_LOG_CATEGORY_CUSTOM: _bindgen_ty_10 = _bindgen_ty_10::SDL_LOG_CATEGORY_CUSTOM;
#[repr(u32)]
///  \brief The predefined log categories
///
///  By default the application category is enabled at the INFO level,
///  the assert category is enabled at the WARN level, test is enabled
///  at the VERBOSE level and all other categories are enabled at the
///  CRITICAL level.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_10 {
    SDL_LOG_CATEGORY_APPLICATION = 0,
    SDL_LOG_CATEGORY_ERROR = 1,
    SDL_LOG_CATEGORY_ASSERT = 2,
    SDL_LOG_CATEGORY_SYSTEM = 3,
    SDL_LOG_CATEGORY_AUDIO = 4,
    SDL_LOG_CATEGORY_VIDEO = 5,
    SDL_LOG_CATEGORY_RENDER = 6,
    SDL_LOG_CATEGORY_INPUT = 7,
    SDL_LOG_CATEGORY_TEST = 8,
    SDL_LOG_CATEGORY_RESERVED1 = 9,
    SDL_LOG_CATEGORY_RESERVED2 = 10,
    SDL_LOG_CATEGORY_RESERVED3 = 11,
    SDL_LOG_CATEGORY_RESERVED4 = 12,
    SDL_LOG_CATEGORY_RESERVED5 = 13,
    SDL_LOG_CATEGORY_RESERVED6 = 14,
    SDL_LOG_CATEGORY_RESERVED7 = 15,
    SDL_LOG_CATEGORY_RESERVED8 = 16,
    SDL_LOG_CATEGORY_RESERVED9 = 17,
    SDL_LOG_CATEGORY_RESERVED10 = 18,
    SDL_LOG_CATEGORY_CUSTOM = 19,
}
#[repr(u32)]
///  \brief The predefined log priorities
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_LogPriority {
    SDL_LOG_PRIORITY_VERBOSE = 1,
    SDL_LOG_PRIORITY_DEBUG = 2,
    SDL_LOG_PRIORITY_INFO = 3,
    SDL_LOG_PRIORITY_WARN = 4,
    SDL_LOG_PRIORITY_ERROR = 5,
    SDL_LOG_PRIORITY_CRITICAL = 6,
    SDL_NUM_LOG_PRIORITIES = 7,
}
extern "C" {
    ///  \brief Set the priority of all log categories
    pub fn SDL_LogSetAllPriority(priority: SDL_LogPriority);
}
extern "C" {
    ///  \brief Set the priority of a particular log category
    pub fn SDL_LogSetPriority(category: ::std::os::raw::c_int, priority: SDL_LogPriority);
}
extern "C" {
    ///  \brief Get the priority of a particular log category
    pub fn SDL_LogGetPriority(category: ::std::os::raw::c_int) -> SDL_LogPriority;
}
extern "C" {
    ///  \brief Reset all priorities to default.
    ///
    ///  \note This is called in SDL_Quit().
    pub fn SDL_LogResetPriorities();
}
extern "C" {
    ///  \brief Log a message with SDL_LOG_CATEGORY_APPLICATION and SDL_LOG_PRIORITY_INFO
    pub fn SDL_Log(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    ///  \brief Log a message with SDL_LOG_PRIORITY_VERBOSE
    pub fn SDL_LogVerbose(category: ::std::os::raw::c_int, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    ///  \brief Log a message with SDL_LOG_PRIORITY_DEBUG
    pub fn SDL_LogDebug(category: ::std::os::raw::c_int, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    ///  \brief Log a message with SDL_LOG_PRIORITY_INFO
    pub fn SDL_LogInfo(category: ::std::os::raw::c_int, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    ///  \brief Log a message with SDL_LOG_PRIORITY_WARN
    pub fn SDL_LogWarn(category: ::std::os::raw::c_int, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    ///  \brief Log a message with SDL_LOG_PRIORITY_ERROR
    pub fn SDL_LogError(category: ::std::os::raw::c_int, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    ///  \brief Log a message with SDL_LOG_PRIORITY_CRITICAL
    pub fn SDL_LogCritical(
        category: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    ///  \brief Log a message with the specified category and priority.
    pub fn SDL_LogMessage(
        category: ::std::os::raw::c_int,
        priority: SDL_LogPriority,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    ///  \brief Log a message with the specified category and priority.
    pub fn SDL_LogMessageV(
        category: ::std::os::raw::c_int,
        priority: SDL_LogPriority,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    );
}
///  \brief The prototype for the log output function
pub type SDL_LogOutputFunction = ::std::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::std::os::raw::c_void,
        category: ::std::os::raw::c_int,
        priority: SDL_LogPriority,
        message: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    ///  \brief Get the current log output function.
    pub fn SDL_LogGetOutputFunction(
        callback: *mut SDL_LogOutputFunction,
        userdata: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    ///  \brief This function allows you to replace the default log output
    ///         function with one of your own.
    pub fn SDL_LogSetOutputFunction(
        callback: SDL_LogOutputFunction,
        userdata: *mut ::std::os::raw::c_void,
    );
}
#[repr(u32)]
/// \brief SDL_MessageBox flags. If supported will display warning icon, etc.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_MessageBoxFlags {
    ///< error dialog
    SDL_MESSAGEBOX_ERROR = 16,
    ///< warning dialog
    SDL_MESSAGEBOX_WARNING = 32,
    ///< informational dialog
    SDL_MESSAGEBOX_INFORMATION = 64,
}
#[repr(u32)]
/// \brief Flags for SDL_MessageBoxButtonData.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_MessageBoxButtonFlags {
    ///< Marks the default button when return is hit
    SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT = 1,
    ///< Marks the default button when escape is hit
    SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT = 2,
}
///  \brief Individual button data.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MessageBoxButtonData {
    ///< ::SDL_MessageBoxButtonFlags
    pub flags: Uint32,
    ///< User defined button id (value returned via SDL_ShowMessageBox)
    pub buttonid: ::std::os::raw::c_int,
    ///< The UTF-8 button text
    pub text: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxButtonData() {
    assert_eq!(
        ::std::mem::size_of::<SDL_MessageBoxButtonData>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_MessageBoxButtonData))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_MessageBoxButtonData>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_MessageBoxButtonData))
    );
}
/// \brief RGB value used in a message box color scheme
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MessageBoxColor {
    pub r: Uint8,
    pub g: Uint8,
    pub b: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxColor() {
    assert_eq!(
        ::std::mem::size_of::<SDL_MessageBoxColor>(),
        3usize,
        concat!("Size of: ", stringify!(SDL_MessageBoxColor))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_MessageBoxColor>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_MessageBoxColor))
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_MessageBoxColorType {
    SDL_MESSAGEBOX_COLOR_BACKGROUND = 0,
    SDL_MESSAGEBOX_COLOR_TEXT = 1,
    SDL_MESSAGEBOX_COLOR_BUTTON_BORDER = 2,
    SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND = 3,
    SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED = 4,
    SDL_MESSAGEBOX_COLOR_MAX = 5,
}
/// \brief A set of colors to use for message box dialogs
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MessageBoxColorScheme {
    pub colors: [SDL_MessageBoxColor; 5usize],
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxColorScheme() {
    assert_eq!(
        ::std::mem::size_of::<SDL_MessageBoxColorScheme>(),
        15usize,
        concat!("Size of: ", stringify!(SDL_MessageBoxColorScheme))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_MessageBoxColorScheme>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_MessageBoxColorScheme))
    );
}
///  \brief MessageBox structure containing title, text, window, etc.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MessageBoxData {
    ///< ::SDL_MessageBoxFlags
    pub flags: Uint32,
    ///< Parent window, can be NULL
    pub window: *mut SDL_Window,
    ///< UTF-8 title
    pub title: *const ::std::os::raw::c_char,
    ///< UTF-8 message text
    pub message: *const ::std::os::raw::c_char,
    pub numbuttons: ::std::os::raw::c_int,
    pub buttons: *const SDL_MessageBoxButtonData,
    ///< ::SDL_MessageBoxColorScheme, can be NULL to use system settings
    pub colorScheme: *const SDL_MessageBoxColorScheme,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxData() {
    assert_eq!(
        ::std::mem::size_of::<SDL_MessageBoxData>(),
        56usize,
        concat!("Size of: ", stringify!(SDL_MessageBoxData))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_MessageBoxData>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_MessageBoxData))
    );
}
extern "C" {
    ///  \brief Create a modal message box.
    ///
    ///  \param messageboxdata The SDL_MessageBoxData structure with title, text, etc.
    ///  \param buttonid The pointer to which user id of hit button should be copied.
    ///
    ///  \return -1 on error, otherwise 0 and buttonid contains user id of button
    ///          hit or -1 if dialog was closed.
    ///
    ///  \note This function should be called on the thread that created the parent
    ///        window, or on the main thread if the messagebox has no parent.  It will
    ///        block execution of that thread until the user clicks a button or
    ///        closes the messagebox.
    pub fn SDL_ShowMessageBox(
        messageboxdata: *const SDL_MessageBoxData,
        buttonid: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Create a simple modal message box
    ///
    ///  \param flags    ::SDL_MessageBoxFlags
    ///  \param title    UTF-8 title text
    ///  \param message  UTF-8 message text
    ///  \param window   The parent window, or NULL for no parent
    ///
    ///  \return 0 on success, -1 on error
    ///
    ///  \sa SDL_ShowMessageBox
    pub fn SDL_ShowSimpleMessageBox(
        flags: Uint32,
        title: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
        window: *mut SDL_Window,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
///  \brief The basic state for the system's power supply.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_PowerState {
    ///< cannot determine power status
    SDL_POWERSTATE_UNKNOWN = 0,
    ///< Not plugged in, running on the battery
    SDL_POWERSTATE_ON_BATTERY = 1,
    ///< Plugged in, no battery available
    SDL_POWERSTATE_NO_BATTERY = 2,
    ///< Plugged in, charging battery
    SDL_POWERSTATE_CHARGING = 3,
    ///< Plugged in, battery charged
    SDL_POWERSTATE_CHARGED = 4,
}
extern "C" {
    ///  \brief Get the current power supply details.
    ///
    ///  \param secs Seconds of battery life left. You can pass a NULL here if
    ///              you don't care. Will return -1 if we can't determine a
    ///              value, or we're not running on a battery.
    ///
    ///  \param pct Percentage of battery life left, between 0 and 100. You can
    ///             pass a NULL here if you don't care. Will return -1 if we
    ///             can't determine a value, or we're not running on a battery.
    ///
    ///  \return The state of the battery (if any).
    pub fn SDL_GetPowerInfo(
        secs: *mut ::std::os::raw::c_int,
        pct: *mut ::std::os::raw::c_int,
    ) -> SDL_PowerState;
}
#[repr(u32)]
///  \brief Flags used when creating a rendering context
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_RendererFlags {
    ///< The renderer is a software fallback
    SDL_RENDERER_SOFTWARE = 1,
    ///< The renderer uses hardware
    ///acceleration
    SDL_RENDERER_ACCELERATED = 2,
    ///< Present is synchronized
    ///with the refresh rate
    SDL_RENDERER_PRESENTVSYNC = 4,
    ///< The renderer supports
    ///rendering to texture
    SDL_RENDERER_TARGETTEXTURE = 8,
}
///  \brief Information on the capabilities of a render driver or context.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RendererInfo {
    ///< The name of the renderer
    pub name: *const ::std::os::raw::c_char,
    ///< Supported ::SDL_RendererFlags
    pub flags: Uint32,
    ///< The number of available texture formats
    pub num_texture_formats: Uint32,
    ///< The available texture formats
    pub texture_formats: [Uint32; 16usize],
    ///< The maximimum texture width
    pub max_texture_width: ::std::os::raw::c_int,
    ///< The maximimum texture height
    pub max_texture_height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_RendererInfo() {
    assert_eq!(
        ::std::mem::size_of::<SDL_RendererInfo>(),
        88usize,
        concat!("Size of: ", stringify!(SDL_RendererInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_RendererInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_RendererInfo))
    );
}
#[repr(u32)]
///  \brief The access pattern allowed for a texture.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_TextureAccess {
    ///< Changes rarely, not lockable
    SDL_TEXTUREACCESS_STATIC = 0,
    ///< Changes frequently, lockable
    SDL_TEXTUREACCESS_STREAMING = 1,
    ///< Texture can be used as a render target
    SDL_TEXTUREACCESS_TARGET = 2,
}
#[repr(u32)]
///  \brief The texture channel modulation used in SDL_RenderCopy().
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_TextureModulate {
    ///< No modulation
    SDL_TEXTUREMODULATE_NONE = 0,
    ///< srcC = srcC * color
    SDL_TEXTUREMODULATE_COLOR = 1,
    ///< srcA = srcA * alpha
    SDL_TEXTUREMODULATE_ALPHA = 2,
}
#[repr(u32)]
///  \brief Flip constants for SDL_RenderCopyEx
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_RendererFlip {
    ///< Do not flip
    SDL_FLIP_NONE = 0,
    ///< flip horizontally
    SDL_FLIP_HORIZONTAL = 1,
    ///< flip vertically
    SDL_FLIP_VERTICAL = 2,
}
///  \brief A structure representing rendering state
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Renderer {
    _unused: [u8; 0],
}
///  \brief An efficient driver-specific representation of pixel data
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Texture {
    _unused: [u8; 0],
}
extern "C" {
    ///  \brief Get the number of 2D rendering drivers available for the current
    ///         display.
    ///
    ///  A render driver is a set of code that handles rendering and texture
    ///  management on a particular display.  Normally there is only one, but
    ///  some drivers may have several available with different capabilities.
    ///
    ///  \sa SDL_GetRenderDriverInfo()
    ///  \sa SDL_CreateRenderer()
    pub fn SDL_GetNumRenderDrivers() -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get information about a specific 2D rendering driver for the current
    ///         display.
    ///
    ///  \param index The index of the driver to query information about.
    ///  \param info  A pointer to an SDL_RendererInfo struct to be filled with
    ///               information on the rendering driver.
    ///
    ///  \return 0 on success, -1 if the index was out of range.
    ///
    ///  \sa SDL_CreateRenderer()
    pub fn SDL_GetRenderDriverInfo(
        index: ::std::os::raw::c_int,
        info: *mut SDL_RendererInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Create a window and default renderer
    ///
    ///  \param width    The width of the window
    ///  \param height   The height of the window
    ///  \param window_flags The flags used to create the window
    ///  \param window   A pointer filled with the window, or NULL on error
    ///  \param renderer A pointer filled with the renderer, or NULL on error
    ///
    ///  \return 0 on success, or -1 on error
    pub fn SDL_CreateWindowAndRenderer(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        window_flags: Uint32,
        window: *mut *mut SDL_Window,
        renderer: *mut *mut SDL_Renderer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Create a 2D rendering context for a window.
    ///
    ///  \param window The window where rendering is displayed.
    ///  \param index    The index of the rendering driver to initialize, or -1 to
    ///                  initialize the first one supporting the requested flags.
    ///  \param flags    ::SDL_RendererFlags.
    ///
    ///  \return A valid rendering context or NULL if there was an error.
    ///
    ///  \sa SDL_CreateSoftwareRenderer()
    ///  \sa SDL_GetRendererInfo()
    ///  \sa SDL_DestroyRenderer()
    pub fn SDL_CreateRenderer(
        window: *mut SDL_Window,
        index: ::std::os::raw::c_int,
        flags: Uint32,
    ) -> *mut SDL_Renderer;
}
extern "C" {
    ///  \brief Create a 2D software rendering context for a surface.
    ///
    ///  \param surface The surface where rendering is done.
    ///
    ///  \return A valid rendering context or NULL if there was an error.
    ///
    ///  \sa SDL_CreateRenderer()
    ///  \sa SDL_DestroyRenderer()
    pub fn SDL_CreateSoftwareRenderer(surface: *mut SDL_Surface) -> *mut SDL_Renderer;
}
extern "C" {
    ///  \brief Get the renderer associated with a window.
    pub fn SDL_GetRenderer(window: *mut SDL_Window) -> *mut SDL_Renderer;
}
extern "C" {
    ///  \brief Get information about a rendering context.
    pub fn SDL_GetRendererInfo(
        renderer: *mut SDL_Renderer,
        info: *mut SDL_RendererInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the output size of a rendering context.
    pub fn SDL_GetRendererOutputSize(
        renderer: *mut SDL_Renderer,
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Create a texture for a rendering context.
    ///
    ///  \param renderer The renderer.
    ///  \param format The format of the texture.
    ///  \param access One of the enumerated values in ::SDL_TextureAccess.
    ///  \param w      The width of the texture in pixels.
    ///  \param h      The height of the texture in pixels.
    ///
    ///  \return The created texture is returned, or 0 if no rendering context was
    ///          active,  the format was unsupported, or the width or height were out
    ///          of range.
    ///
    ///  \sa SDL_QueryTexture()
    ///  \sa SDL_UpdateTexture()
    ///  \sa SDL_DestroyTexture()
    pub fn SDL_CreateTexture(
        renderer: *mut SDL_Renderer,
        format: Uint32,
        access: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    ) -> *mut SDL_Texture;
}
extern "C" {
    ///  \brief Create a texture from an existing surface.
    ///
    ///  \param renderer The renderer.
    ///  \param surface The surface containing pixel data used to fill the texture.
    ///
    ///  \return The created texture is returned, or 0 on error.
    ///
    ///  \note The surface is not modified or freed by this function.
    ///
    ///  \sa SDL_QueryTexture()
    ///  \sa SDL_DestroyTexture()
    pub fn SDL_CreateTextureFromSurface(
        renderer: *mut SDL_Renderer,
        surface: *mut SDL_Surface,
    ) -> *mut SDL_Texture;
}
extern "C" {
    ///  \brief Query the attributes of a texture
    ///
    ///  \param texture A texture to be queried.
    ///  \param format  A pointer filled in with the raw format of the texture.  The
    ///                 actual format may differ, but pixel transfers will use this
    ///                 format.
    ///  \param access  A pointer filled in with the actual access to the texture.
    ///  \param w       A pointer filled in with the width of the texture in pixels.
    ///  \param h       A pointer filled in with the height of the texture in pixels.
    ///
    ///  \return 0 on success, or -1 if the texture is not valid.
    pub fn SDL_QueryTexture(
        texture: *mut SDL_Texture,
        format: *mut Uint32,
        access: *mut ::std::os::raw::c_int,
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Set an additional color value used in render copy operations.
    ///
    ///  \param texture The texture to update.
    ///  \param r       The red color value multiplied into copy operations.
    ///  \param g       The green color value multiplied into copy operations.
    ///  \param b       The blue color value multiplied into copy operations.
    ///
    ///  \return 0 on success, or -1 if the texture is not valid or color modulation
    ///          is not supported.
    ///
    ///  \sa SDL_GetTextureColorMod()
    pub fn SDL_SetTextureColorMod(
        texture: *mut SDL_Texture,
        r: Uint8,
        g: Uint8,
        b: Uint8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the additional color value used in render copy operations.
    ///
    ///  \param texture The texture to query.
    ///  \param r         A pointer filled in with the current red color value.
    ///  \param g         A pointer filled in with the current green color value.
    ///  \param b         A pointer filled in with the current blue color value.
    ///
    ///  \return 0 on success, or -1 if the texture is not valid.
    ///
    ///  \sa SDL_SetTextureColorMod()
    pub fn SDL_GetTextureColorMod(
        texture: *mut SDL_Texture,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Set an additional alpha value used in render copy operations.
    ///
    ///  \param texture The texture to update.
    ///  \param alpha     The alpha value multiplied into copy operations.
    ///
    ///  \return 0 on success, or -1 if the texture is not valid or alpha modulation
    ///          is not supported.
    ///
    ///  \sa SDL_GetTextureAlphaMod()
    pub fn SDL_SetTextureAlphaMod(texture: *mut SDL_Texture, alpha: Uint8)
        -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the additional alpha value used in render copy operations.
    ///
    ///  \param texture The texture to query.
    ///  \param alpha     A pointer filled in with the current alpha value.
    ///
    ///  \return 0 on success, or -1 if the texture is not valid.
    ///
    ///  \sa SDL_SetTextureAlphaMod()
    pub fn SDL_GetTextureAlphaMod(
        texture: *mut SDL_Texture,
        alpha: *mut Uint8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Set the blend mode used for texture copy operations.
    ///
    ///  \param texture The texture to update.
    ///  \param blendMode ::SDL_BlendMode to use for texture blending.
    ///
    ///  \return 0 on success, or -1 if the texture is not valid or the blend mode is
    ///          not supported.
    ///
    ///  \note If the blend mode is not supported, the closest supported mode is
    ///        chosen.
    ///
    ///  \sa SDL_GetTextureBlendMode()
    pub fn SDL_SetTextureBlendMode(
        texture: *mut SDL_Texture,
        blendMode: SDL_BlendMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the blend mode used for texture copy operations.
    ///
    ///  \param texture   The texture to query.
    ///  \param blendMode A pointer filled in with the current blend mode.
    ///
    ///  \return 0 on success, or -1 if the texture is not valid.
    ///
    ///  \sa SDL_SetTextureBlendMode()
    pub fn SDL_GetTextureBlendMode(
        texture: *mut SDL_Texture,
        blendMode: *mut SDL_BlendMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Update the given texture rectangle with new pixel data.
    ///
    ///  \param texture   The texture to update
    ///  \param rect      A pointer to the rectangle of pixels to update, or NULL to
    ///                   update the entire texture.
    ///  \param pixels    The raw pixel data.
    ///  \param pitch     The number of bytes between rows of pixel data.
    ///
    ///  \return 0 on success, or -1 if the texture is not valid.
    ///
    ///  \note This is a fairly slow function.
    pub fn SDL_UpdateTexture(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        pixels: *const ::std::os::raw::c_void,
        pitch: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Update a rectangle within a planar YV12 or IYUV texture with new pixel data.
    ///
    ///  \param texture   The texture to update
    ///  \param rect      A pointer to the rectangle of pixels to update, or NULL to
    ///                   update the entire texture.
    ///  \param Yplane    The raw pixel data for the Y plane.
    ///  \param Ypitch    The number of bytes between rows of pixel data for the Y plane.
    ///  \param Uplane    The raw pixel data for the U plane.
    ///  \param Upitch    The number of bytes between rows of pixel data for the U plane.
    ///  \param Vplane    The raw pixel data for the V plane.
    ///  \param Vpitch    The number of bytes between rows of pixel data for the V plane.
    ///
    ///  \return 0 on success, or -1 if the texture is not valid.
    ///
    ///  \note You can use SDL_UpdateTexture() as long as your pixel data is
    ///        a contiguous block of Y and U/V planes in the proper order, but
    ///        this function is available if your pixel data is not contiguous.
    pub fn SDL_UpdateYUVTexture(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        Yplane: *const Uint8,
        Ypitch: ::std::os::raw::c_int,
        Uplane: *const Uint8,
        Upitch: ::std::os::raw::c_int,
        Vplane: *const Uint8,
        Vpitch: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Lock a portion of the texture for write-only pixel access.
    ///
    ///  \param texture   The texture to lock for access, which was created with
    ///                   ::SDL_TEXTUREACCESS_STREAMING.
    ///  \param rect      A pointer to the rectangle to lock for access. If the rect
    ///                   is NULL, the entire texture will be locked.
    ///  \param pixels    This is filled in with a pointer to the locked pixels,
    ///                   appropriately offset by the locked area.
    ///  \param pitch     This is filled in with the pitch of the locked pixels.
    ///
    ///  \return 0 on success, or -1 if the texture is not valid or was not created with ::SDL_TEXTUREACCESS_STREAMING.
    ///
    ///  \sa SDL_UnlockTexture()
    pub fn SDL_LockTexture(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        pixels: *mut *mut ::std::os::raw::c_void,
        pitch: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Unlock a texture, uploading the changes to video memory, if needed.
    ///
    ///  \sa SDL_LockTexture()
    pub fn SDL_UnlockTexture(texture: *mut SDL_Texture);
}
extern "C" {
    /// \brief Determines whether a window supports the use of render targets
    ///
    /// \param renderer The renderer that will be checked
    ///
    /// \return SDL_TRUE if supported, SDL_FALSE if not.
    pub fn SDL_RenderTargetSupported(renderer: *mut SDL_Renderer) -> SDL_bool;
}
extern "C" {
    /// \brief Set a texture as the current rendering target.
    ///
    /// \param renderer The renderer.
    /// \param texture The targeted texture, which must be created with the SDL_TEXTUREACCESS_TARGET flag, or NULL for the default render target
    ///
    /// \return 0 on success, or -1 on error
    ///
    ///  \sa SDL_GetRenderTarget()
    pub fn SDL_SetRenderTarget(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the current render target or NULL for the default render target.
    ///
    /// \return The current render target
    ///
    ///  \sa SDL_SetRenderTarget()
    pub fn SDL_GetRenderTarget(renderer: *mut SDL_Renderer) -> *mut SDL_Texture;
}
extern "C" {
    ///  \brief Set device independent resolution for rendering
    ///
    ///  \param renderer The renderer for which resolution should be set.
    ///  \param w      The width of the logical resolution
    ///  \param h      The height of the logical resolution
    ///
    ///  This function uses the viewport and scaling functionality to allow a fixed logical
    ///  resolution for rendering, regardless of the actual output resolution.  If the actual
    ///  output resolution doesn't have the same aspect ratio the output rendering will be
    ///  centered within the output display.
    ///
    ///  If the output display is a window, mouse events in the window will be filtered
    ///  and scaled so they seem to arrive within the logical resolution.
    ///
    ///  \note If this function results in scaling or subpixel drawing by the
    ///        rendering backend, it will be handled using the appropriate
    ///        quality hints.
    ///
    ///  \sa SDL_RenderGetLogicalSize()
    ///  \sa SDL_RenderSetScale()
    ///  \sa SDL_RenderSetViewport()
    pub fn SDL_RenderSetLogicalSize(
        renderer: *mut SDL_Renderer,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get device independent resolution for rendering
    ///
    ///  \param renderer The renderer from which resolution should be queried.
    ///  \param w      A pointer filled with the width of the logical resolution
    ///  \param h      A pointer filled with the height of the logical resolution
    ///
    ///  \sa SDL_RenderSetLogicalSize()
    pub fn SDL_RenderGetLogicalSize(
        renderer: *mut SDL_Renderer,
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    ///  \brief Set the drawing area for rendering on the current target.
    ///
    ///  \param renderer The renderer for which the drawing area should be set.
    ///  \param rect The rectangle representing the drawing area, or NULL to set the viewport to the entire target.
    ///
    ///  The x,y of the viewport rect represents the origin for rendering.
    ///
    ///  \return 0 on success, or -1 on error
    ///
    ///  \note If the window associated with the renderer is resized, the viewport is automatically reset.
    ///
    ///  \sa SDL_RenderGetViewport()
    ///  \sa SDL_RenderSetLogicalSize()
    pub fn SDL_RenderSetViewport(
        renderer: *mut SDL_Renderer,
        rect: *const SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the drawing area for the current target.
    ///
    ///  \sa SDL_RenderSetViewport()
    pub fn SDL_RenderGetViewport(renderer: *mut SDL_Renderer, rect: *mut SDL_Rect);
}
extern "C" {
    ///  \brief Set the clip rectangle for the current target.
    ///
    ///  \param renderer The renderer for which clip rectangle should be set.
    ///  \param rect   A pointer to the rectangle to set as the clip rectangle, or
    ///                NULL to disable clipping.
    ///
    ///  \return 0 on success, or -1 on error
    ///
    ///  \sa SDL_RenderGetClipRect()
    pub fn SDL_RenderSetClipRect(
        renderer: *mut SDL_Renderer,
        rect: *const SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the clip rectangle for the current target.
    ///
    ///  \param renderer The renderer from which clip rectangle should be queried.
    ///  \param rect   A pointer filled in with the current clip rectangle, or
    ///                an empty rectangle if clipping is disabled.
    ///
    ///  \sa SDL_RenderSetClipRect()
    pub fn SDL_RenderGetClipRect(renderer: *mut SDL_Renderer, rect: *mut SDL_Rect);
}
extern "C" {
    ///  \brief Set the drawing scale for rendering on the current target.
    ///
    ///  \param renderer The renderer for which the drawing scale should be set.
    ///  \param scaleX The horizontal scaling factor
    ///  \param scaleY The vertical scaling factor
    ///
    ///  The drawing coordinates are scaled by the x/y scaling factors
    ///  before they are used by the renderer.  This allows resolution
    ///  independent drawing with a single coordinate system.
    ///
    ///  \note If this results in scaling or subpixel drawing by the
    ///        rendering backend, it will be handled using the appropriate
    ///        quality hints.  For best results use integer scaling factors.
    ///
    ///  \sa SDL_RenderGetScale()
    ///  \sa SDL_RenderSetLogicalSize()
    pub fn SDL_RenderSetScale(
        renderer: *mut SDL_Renderer,
        scaleX: f32,
        scaleY: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the drawing scale for the current target.
    ///
    ///  \param renderer The renderer from which drawing scale should be queried.
    ///  \param scaleX A pointer filled in with the horizontal scaling factor
    ///  \param scaleY A pointer filled in with the vertical scaling factor
    ///
    ///  \sa SDL_RenderSetScale()
    pub fn SDL_RenderGetScale(renderer: *mut SDL_Renderer, scaleX: *mut f32, scaleY: *mut f32);
}
extern "C" {
    ///  \brief Set the color used for drawing operations (Rect, Line and Clear).
    ///
    ///  \param renderer The renderer for which drawing color should be set.
    ///  \param r The red value used to draw on the rendering target.
    ///  \param g The green value used to draw on the rendering target.
    ///  \param b The blue value used to draw on the rendering target.
    ///  \param a The alpha value used to draw on the rendering target, usually
    ///           ::SDL_ALPHA_OPAQUE (255).
    ///
    ///  \return 0 on success, or -1 on error
    pub fn SDL_SetRenderDrawColor(
        renderer: *mut SDL_Renderer,
        r: Uint8,
        g: Uint8,
        b: Uint8,
        a: Uint8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the color used for drawing operations (Rect, Line and Clear).
    ///
    ///  \param renderer The renderer from which drawing color should be queried.
    ///  \param r A pointer to the red value used to draw on the rendering target.
    ///  \param g A pointer to the green value used to draw on the rendering target.
    ///  \param b A pointer to the blue value used to draw on the rendering target.
    ///  \param a A pointer to the alpha value used to draw on the rendering target,
    ///           usually ::SDL_ALPHA_OPAQUE (255).
    ///
    ///  \return 0 on success, or -1 on error
    pub fn SDL_GetRenderDrawColor(
        renderer: *mut SDL_Renderer,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
        a: *mut Uint8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Set the blend mode used for drawing operations (Fill and Line).
    ///
    ///  \param renderer The renderer for which blend mode should be set.
    ///  \param blendMode ::SDL_BlendMode to use for blending.
    ///
    ///  \return 0 on success, or -1 on error
    ///
    ///  \note If the blend mode is not supported, the closest supported mode is
    ///        chosen.
    ///
    ///  \sa SDL_GetRenderDrawBlendMode()
    pub fn SDL_SetRenderDrawBlendMode(
        renderer: *mut SDL_Renderer,
        blendMode: SDL_BlendMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Get the blend mode used for drawing operations.
    ///
    ///  \param renderer The renderer from which blend mode should be queried.
    ///  \param blendMode A pointer filled in with the current blend mode.
    ///
    ///  \return 0 on success, or -1 on error
    ///
    ///  \sa SDL_SetRenderDrawBlendMode()
    pub fn SDL_GetRenderDrawBlendMode(
        renderer: *mut SDL_Renderer,
        blendMode: *mut SDL_BlendMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Clear the current rendering target with the drawing color
    ///
    ///  This function clears the entire rendering target, ignoring the viewport.
    ///
    ///  \return 0 on success, or -1 on error
    pub fn SDL_RenderClear(renderer: *mut SDL_Renderer) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Draw a point on the current rendering target.
    ///
    ///  \param renderer The renderer which should draw a point.
    ///  \param x The x coordinate of the point.
    ///  \param y The y coordinate of the point.
    ///
    ///  \return 0 on success, or -1 on error
    pub fn SDL_RenderDrawPoint(
        renderer: *mut SDL_Renderer,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Draw multiple points on the current rendering target.
    ///
    ///  \param renderer The renderer which should draw multiple points.
    ///  \param points The points to draw
    ///  \param count The number of points to draw
    ///
    ///  \return 0 on success, or -1 on error
    pub fn SDL_RenderDrawPoints(
        renderer: *mut SDL_Renderer,
        points: *const SDL_Point,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Draw a line on the current rendering target.
    ///
    ///  \param renderer The renderer which should draw a line.
    ///  \param x1 The x coordinate of the start point.
    ///  \param y1 The y coordinate of the start point.
    ///  \param x2 The x coordinate of the end point.
    ///  \param y2 The y coordinate of the end point.
    ///
    ///  \return 0 on success, or -1 on error
    pub fn SDL_RenderDrawLine(
        renderer: *mut SDL_Renderer,
        x1: ::std::os::raw::c_int,
        y1: ::std::os::raw::c_int,
        x2: ::std::os::raw::c_int,
        y2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Draw a series of connected lines on the current rendering target.
    ///
    ///  \param renderer The renderer which should draw multiple lines.
    ///  \param points The points along the lines
    ///  \param count The number of points, drawing count-1 lines
    ///
    ///  \return 0 on success, or -1 on error
    pub fn SDL_RenderDrawLines(
        renderer: *mut SDL_Renderer,
        points: *const SDL_Point,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Draw a rectangle on the current rendering target.
    ///
    ///  \param renderer The renderer which should draw a rectangle.
    ///  \param rect A pointer to the destination rectangle, or NULL to outline the entire rendering target.
    ///
    ///  \return 0 on success, or -1 on error
    pub fn SDL_RenderDrawRect(
        renderer: *mut SDL_Renderer,
        rect: *const SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Draw some number of rectangles on the current rendering target.
    ///
    ///  \param renderer The renderer which should draw multiple rectangles.
    ///  \param rects A pointer to an array of destination rectangles.
    ///  \param count The number of rectangles.
    ///
    ///  \return 0 on success, or -1 on error
    pub fn SDL_RenderDrawRects(
        renderer: *mut SDL_Renderer,
        rects: *const SDL_Rect,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Fill a rectangle on the current rendering target with the drawing color.
    ///
    ///  \param renderer The renderer which should fill a rectangle.
    ///  \param rect A pointer to the destination rectangle, or NULL for the entire
    ///              rendering target.
    ///
    ///  \return 0 on success, or -1 on error
    pub fn SDL_RenderFillRect(
        renderer: *mut SDL_Renderer,
        rect: *const SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Fill some number of rectangles on the current rendering target with the drawing color.
    ///
    ///  \param renderer The renderer which should fill multiple rectangles.
    ///  \param rects A pointer to an array of destination rectangles.
    ///  \param count The number of rectangles.
    ///
    ///  \return 0 on success, or -1 on error
    pub fn SDL_RenderFillRects(
        renderer: *mut SDL_Renderer,
        rects: *const SDL_Rect,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Copy a portion of the texture to the current rendering target.
    ///
    ///  \param renderer The renderer which should copy parts of a texture.
    ///  \param texture The source texture.
    ///  \param srcrect   A pointer to the source rectangle, or NULL for the entire
    ///                   texture.
    ///  \param dstrect   A pointer to the destination rectangle, or NULL for the
    ///                   entire rendering target.
    ///
    ///  \return 0 on success, or -1 on error
    pub fn SDL_RenderCopy(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        srcrect: *const SDL_Rect,
        dstrect: *const SDL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Copy a portion of the source texture to the current rendering target, rotating it by angle around the given center
    ///
    ///  \param renderer The renderer which should copy parts of a texture.
    ///  \param texture The source texture.
    ///  \param srcrect   A pointer to the source rectangle, or NULL for the entire
    ///                   texture.
    ///  \param dstrect   A pointer to the destination rectangle, or NULL for the
    ///                   entire rendering target.
    ///  \param angle    An angle in degrees that indicates the rotation that will be applied to dstrect
    ///  \param center   A pointer to a point indicating the point around which dstrect will be rotated (if NULL, rotation will be done aroud dstrect.w/2, dstrect.h/2)
    ///  \param flip     An SDL_RendererFlip value stating which flipping actions should be performed on the texture
    ///
    ///  \return 0 on success, or -1 on error
    pub fn SDL_RenderCopyEx(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        srcrect: *const SDL_Rect,
        dstrect: *const SDL_Rect,
        angle: f64,
        center: *const SDL_Point,
        flip: SDL_RendererFlip,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Read pixels from the current rendering target.
    ///
    ///  \param renderer The renderer from which pixels should be read.
    ///  \param rect   A pointer to the rectangle to read, or NULL for the entire
    ///                render target.
    ///  \param format The desired format of the pixel data, or 0 to use the format
    ///                of the rendering target
    ///  \param pixels A pointer to be filled in with the pixel data
    ///  \param pitch  The pitch of the pixels parameter.
    ///
    ///  \return 0 on success, or -1 if pixel reading is not supported.
    ///
    ///  \warning This is a very slow operation, and should not be used frequently.
    pub fn SDL_RenderReadPixels(
        renderer: *mut SDL_Renderer,
        rect: *const SDL_Rect,
        format: Uint32,
        pixels: *mut ::std::os::raw::c_void,
        pitch: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Update the screen with rendering performed.
    pub fn SDL_RenderPresent(renderer: *mut SDL_Renderer);
}
extern "C" {
    ///  \brief Destroy the specified texture.
    ///
    ///  \sa SDL_CreateTexture()
    ///  \sa SDL_CreateTextureFromSurface()
    pub fn SDL_DestroyTexture(texture: *mut SDL_Texture);
}
extern "C" {
    ///  \brief Destroy the rendering context for a window and free associated
    ///         textures.
    ///
    ///  \sa SDL_CreateRenderer()
    pub fn SDL_DestroyRenderer(renderer: *mut SDL_Renderer);
}
extern "C" {
    ///  \brief Bind the texture to the current OpenGL/ES/ES2 context for use with
    ///         OpenGL instructions.
    ///
    ///  \param texture  The SDL texture to bind
    ///  \param texw     A pointer to a float that will be filled with the texture width
    ///  \param texh     A pointer to a float that will be filled with the texture height
    ///
    ///  \return 0 on success, or -1 if the operation is not supported
    pub fn SDL_GL_BindTexture(
        texture: *mut SDL_Texture,
        texw: *mut f32,
        texh: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  \brief Unbind a texture from the current OpenGL/ES/ES2 context.
    ///
    ///  \param texture  The SDL texture to unbind
    ///
    ///  \return 0 on success, or -1 if the operation is not supported
    pub fn SDL_GL_UnbindTexture(texture: *mut SDL_Texture) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the number of milliseconds since the SDL library initialization.
    ///
    /// \note This value wraps if the program runs for more than ~49 days.
    pub fn SDL_GetTicks() -> Uint32;
}
extern "C" {
    /// \brief Get the current value of the high resolution counter
    pub fn SDL_GetPerformanceCounter() -> Uint64;
}
extern "C" {
    /// \brief Get the count per second of the high resolution counter
    pub fn SDL_GetPerformanceFrequency() -> Uint64;
}
extern "C" {
    /// \brief Wait a specified number of milliseconds before returning.
    pub fn SDL_Delay(ms: Uint32);
}
///  Function prototype for the timer callback function.
///
///  The callback function is passed the current timer interval and returns
///  the next timer interval.  If the returned value is the same as the one
///  passed in, the periodic alarm continues, otherwise a new alarm is
///  scheduled.  If the callback returns 0, the periodic alarm is cancelled.
pub type SDL_TimerCallback = ::std::option::Option<
    unsafe extern "C" fn(interval: Uint32, param: *mut ::std::os::raw::c_void) -> Uint32,
>;
/// Definition of the timer ID type.
pub type SDL_TimerID = ::std::os::raw::c_int;
extern "C" {
    /// \brief Add a new timer to the pool of timers already running.
    ///
    /// \return A timer ID, or NULL when an error occurs.
    pub fn SDL_AddTimer(
        interval: Uint32,
        callback: SDL_TimerCallback,
        param: *mut ::std::os::raw::c_void,
    ) -> SDL_TimerID;
}
extern "C" {
    /// \brief Remove a timer knowing its ID.
    ///
    /// \return A boolean value indicating success or failure.
    ///
    /// \warning It is not safe to remove a timer multiple times.
    pub fn SDL_RemoveTimer(id: SDL_TimerID) -> SDL_bool;
}
///  \brief Information the version of SDL in use.
///
///  Represents the library's version as three levels: major revision
///  (increments with massive changes, additions, and enhancements),
///  minor revision (increments with backwards-compatible changes to the
///  major revision), and patchlevel (increments with fixes to the minor
///  revision).
///
///  \sa SDL_VERSION
///  \sa SDL_GetVersion
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_version {
    ///< major version
    pub major: Uint8,
    ///< minor version
    pub minor: Uint8,
    ///< update version
    pub patch: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_version() {
    assert_eq!(
        ::std::mem::size_of::<SDL_version>(),
        3usize,
        concat!("Size of: ", stringify!(SDL_version))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_version>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_version))
    );
}
extern "C" {
    ///  \brief Get the version of SDL that is linked against your program.
    ///
    ///  If you are linking to SDL dynamically, then it is possible that the
    ///  current version will be different than the version you compiled against.
    ///  This function returns the current version, while SDL_VERSION() is a
    ///  macro that tells you what version you compiled with.
    ///
    ///  \code
    ///  SDL_version compiled;
    ///  SDL_version linked;
    ///
    ///  SDL_VERSION(&compiled);
    ///  SDL_GetVersion(&linked);
    ///  printf("We compiled against SDL version %d.%d.%d ...\n",
    ///         compiled.major, compiled.minor, compiled.patch);
    ///  printf("But we linked against SDL version %d.%d.%d.\n",
    ///         linked.major, linked.minor, linked.patch);
    ///  \endcode
    ///
    ///  This function may be called safely at any time, even before SDL_Init().
    ///
    ///  \sa SDL_VERSION
    pub fn SDL_GetVersion(ver: *mut SDL_version);
}
extern "C" {
    ///  \brief Get the code revision of SDL that is linked against your program.
    ///
    ///  Returns an arbitrary string (a hash value) uniquely identifying the
    ///  exact revision of the SDL library in use, and is only useful in comparing
    ///  against other revisions. It is NOT an incrementing number.
    pub fn SDL_GetRevision() -> *const ::std::os::raw::c_char;
}
extern "C" {
    ///  \brief Get the revision number of SDL that is linked against your program.
    ///
    ///  Returns a number uniquely identifying the exact revision of the SDL
    ///  library in use. It is an incrementing number based on commits to
    ///  hg.libsdl.org.
    pub fn SDL_GetRevisionNumber() -> ::std::os::raw::c_int;
}
extern "C" {
    ///  This function initializes  the subsystems specified by \c flags
    ///  Unless the ::SDL_INIT_NOPARACHUTE flag is set, it will install cleanup
    ///  signal handlers for some commonly ignored fatal signals (like SIGSEGV).
    pub fn SDL_Init(flags: Uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  This function initializes specific SDL subsystems
    pub fn SDL_InitSubSystem(flags: Uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  This function cleans up specific SDL subsystems
    pub fn SDL_QuitSubSystem(flags: Uint32);
}
extern "C" {
    ///  This function returns a mask of the specified subsystems which have
    ///  previously been initialized.
    ///
    ///  If \c flags is 0, it returns a mask of all initialized subsystems.
    pub fn SDL_WasInit(flags: Uint32) -> Uint32;
}
extern "C" {
    ///  This function cleans up all initialized subsystems. You should
    ///  call it upon all exit conditions.
    pub fn SDL_Quit();
}
pub type XID = ::std::os::raw::c_ulong;
pub type Mask = ::std::os::raw::c_ulong;
pub type Atom = ::std::os::raw::c_ulong;
pub type VisualID = ::std::os::raw::c_ulong;
pub type Time = ::std::os::raw::c_ulong;
pub type Window = XID;
pub type Drawable = XID;
pub type Font = XID;
pub type Pixmap = XID;
pub type Cursor = XID;
pub type Colormap = XID;
pub type GContext = XID;
pub type KeySym = XID;
pub type KeyCode = ::std::os::raw::c_uchar;
extern "C" {
    pub fn _Xmblen(
        str: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type XPointer = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XExtData {
    pub number: ::std::os::raw::c_int,
    pub next: *mut _XExtData,
    pub free_private: ::std::option::Option<
        unsafe extern "C" fn(extension: *mut _XExtData) -> ::std::os::raw::c_int,
    >,
    pub private_data: XPointer,
}
#[test]
fn bindgen_test_layout__XExtData() {
    assert_eq!(
        ::std::mem::size_of::<_XExtData>(),
        32usize,
        concat!("Size of: ", stringify!(_XExtData))
    );
    assert_eq!(
        ::std::mem::align_of::<_XExtData>(),
        8usize,
        concat!("Alignment of ", stringify!(_XExtData))
    );
}
pub type XExtData = _XExtData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XExtCodes {
    pub extension: ::std::os::raw::c_int,
    pub major_opcode: ::std::os::raw::c_int,
    pub first_event: ::std::os::raw::c_int,
    pub first_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XExtCodes() {
    assert_eq!(
        ::std::mem::size_of::<XExtCodes>(),
        16usize,
        concat!("Size of: ", stringify!(XExtCodes))
    );
    assert_eq!(
        ::std::mem::align_of::<XExtCodes>(),
        4usize,
        concat!("Alignment of ", stringify!(XExtCodes))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XPixmapFormatValues {
    pub depth: ::std::os::raw::c_int,
    pub bits_per_pixel: ::std::os::raw::c_int,
    pub scanline_pad: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XPixmapFormatValues() {
    assert_eq!(
        ::std::mem::size_of::<XPixmapFormatValues>(),
        12usize,
        concat!("Size of: ", stringify!(XPixmapFormatValues))
    );
    assert_eq!(
        ::std::mem::align_of::<XPixmapFormatValues>(),
        4usize,
        concat!("Alignment of ", stringify!(XPixmapFormatValues))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XGCValues {
    pub function: ::std::os::raw::c_int,
    pub plane_mask: ::std::os::raw::c_ulong,
    pub foreground: ::std::os::raw::c_ulong,
    pub background: ::std::os::raw::c_ulong,
    pub line_width: ::std::os::raw::c_int,
    pub line_style: ::std::os::raw::c_int,
    pub cap_style: ::std::os::raw::c_int,
    pub join_style: ::std::os::raw::c_int,
    pub fill_style: ::std::os::raw::c_int,
    pub fill_rule: ::std::os::raw::c_int,
    pub arc_mode: ::std::os::raw::c_int,
    pub tile: Pixmap,
    pub stipple: Pixmap,
    pub ts_x_origin: ::std::os::raw::c_int,
    pub ts_y_origin: ::std::os::raw::c_int,
    pub font: Font,
    pub subwindow_mode: ::std::os::raw::c_int,
    pub graphics_exposures: ::std::os::raw::c_int,
    pub clip_x_origin: ::std::os::raw::c_int,
    pub clip_y_origin: ::std::os::raw::c_int,
    pub clip_mask: Pixmap,
    pub dash_offset: ::std::os::raw::c_int,
    pub dashes: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_XGCValues() {
    assert_eq!(
        ::std::mem::size_of::<XGCValues>(),
        128usize,
        concat!("Size of: ", stringify!(XGCValues))
    );
    assert_eq!(
        ::std::mem::align_of::<XGCValues>(),
        8usize,
        concat!("Alignment of ", stringify!(XGCValues))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XGC {
    _unused: [u8; 0],
}
pub type GC = *mut _XGC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Visual {
    pub ext_data: *mut XExtData,
    pub visualid: VisualID,
    pub class: ::std::os::raw::c_int,
    pub red_mask: ::std::os::raw::c_ulong,
    pub green_mask: ::std::os::raw::c_ulong,
    pub blue_mask: ::std::os::raw::c_ulong,
    pub bits_per_rgb: ::std::os::raw::c_int,
    pub map_entries: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Visual() {
    assert_eq!(
        ::std::mem::size_of::<Visual>(),
        56usize,
        concat!("Size of: ", stringify!(Visual))
    );
    assert_eq!(
        ::std::mem::align_of::<Visual>(),
        8usize,
        concat!("Alignment of ", stringify!(Visual))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Depth {
    pub depth: ::std::os::raw::c_int,
    pub nvisuals: ::std::os::raw::c_int,
    pub visuals: *mut Visual,
}
#[test]
fn bindgen_test_layout_Depth() {
    assert_eq!(
        ::std::mem::size_of::<Depth>(),
        16usize,
        concat!("Size of: ", stringify!(Depth))
    );
    assert_eq!(
        ::std::mem::align_of::<Depth>(),
        8usize,
        concat!("Alignment of ", stringify!(Depth))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XDisplay {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Screen {
    pub ext_data: *mut XExtData,
    pub display: *mut _XDisplay,
    pub root: Window,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub mwidth: ::std::os::raw::c_int,
    pub mheight: ::std::os::raw::c_int,
    pub ndepths: ::std::os::raw::c_int,
    pub depths: *mut Depth,
    pub root_depth: ::std::os::raw::c_int,
    pub root_visual: *mut Visual,
    pub default_gc: GC,
    pub cmap: Colormap,
    pub white_pixel: ::std::os::raw::c_ulong,
    pub black_pixel: ::std::os::raw::c_ulong,
    pub max_maps: ::std::os::raw::c_int,
    pub min_maps: ::std::os::raw::c_int,
    pub backing_store: ::std::os::raw::c_int,
    pub save_unders: ::std::os::raw::c_int,
    pub root_input_mask: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_Screen() {
    assert_eq!(
        ::std::mem::size_of::<Screen>(),
        128usize,
        concat!("Size of: ", stringify!(Screen))
    );
    assert_eq!(
        ::std::mem::align_of::<Screen>(),
        8usize,
        concat!("Alignment of ", stringify!(Screen))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ScreenFormat {
    pub ext_data: *mut XExtData,
    pub depth: ::std::os::raw::c_int,
    pub bits_per_pixel: ::std::os::raw::c_int,
    pub scanline_pad: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ScreenFormat() {
    assert_eq!(
        ::std::mem::size_of::<ScreenFormat>(),
        24usize,
        concat!("Size of: ", stringify!(ScreenFormat))
    );
    assert_eq!(
        ::std::mem::align_of::<ScreenFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(ScreenFormat))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XSetWindowAttributes {
    pub background_pixmap: Pixmap,
    pub background_pixel: ::std::os::raw::c_ulong,
    pub border_pixmap: Pixmap,
    pub border_pixel: ::std::os::raw::c_ulong,
    pub bit_gravity: ::std::os::raw::c_int,
    pub win_gravity: ::std::os::raw::c_int,
    pub backing_store: ::std::os::raw::c_int,
    pub backing_planes: ::std::os::raw::c_ulong,
    pub backing_pixel: ::std::os::raw::c_ulong,
    pub save_under: ::std::os::raw::c_int,
    pub event_mask: ::std::os::raw::c_long,
    pub do_not_propagate_mask: ::std::os::raw::c_long,
    pub override_redirect: ::std::os::raw::c_int,
    pub colormap: Colormap,
    pub cursor: Cursor,
}
#[test]
fn bindgen_test_layout_XSetWindowAttributes() {
    assert_eq!(
        ::std::mem::size_of::<XSetWindowAttributes>(),
        112usize,
        concat!("Size of: ", stringify!(XSetWindowAttributes))
    );
    assert_eq!(
        ::std::mem::align_of::<XSetWindowAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(XSetWindowAttributes))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XWindowAttributes {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub border_width: ::std::os::raw::c_int,
    pub depth: ::std::os::raw::c_int,
    pub visual: *mut Visual,
    pub root: Window,
    pub class: ::std::os::raw::c_int,
    pub bit_gravity: ::std::os::raw::c_int,
    pub win_gravity: ::std::os::raw::c_int,
    pub backing_store: ::std::os::raw::c_int,
    pub backing_planes: ::std::os::raw::c_ulong,
    pub backing_pixel: ::std::os::raw::c_ulong,
    pub save_under: ::std::os::raw::c_int,
    pub colormap: Colormap,
    pub map_installed: ::std::os::raw::c_int,
    pub map_state: ::std::os::raw::c_int,
    pub all_event_masks: ::std::os::raw::c_long,
    pub your_event_mask: ::std::os::raw::c_long,
    pub do_not_propagate_mask: ::std::os::raw::c_long,
    pub override_redirect: ::std::os::raw::c_int,
    pub screen: *mut Screen,
}
#[test]
fn bindgen_test_layout_XWindowAttributes() {
    assert_eq!(
        ::std::mem::size_of::<XWindowAttributes>(),
        136usize,
        concat!("Size of: ", stringify!(XWindowAttributes))
    );
    assert_eq!(
        ::std::mem::align_of::<XWindowAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(XWindowAttributes))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XHostAddress {
    pub family: ::std::os::raw::c_int,
    pub length: ::std::os::raw::c_int,
    pub address: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_XHostAddress() {
    assert_eq!(
        ::std::mem::size_of::<XHostAddress>(),
        16usize,
        concat!("Size of: ", stringify!(XHostAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<XHostAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(XHostAddress))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XServerInterpretedAddress {
    pub typelength: ::std::os::raw::c_int,
    pub valuelength: ::std::os::raw::c_int,
    pub type_: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_XServerInterpretedAddress() {
    assert_eq!(
        ::std::mem::size_of::<XServerInterpretedAddress>(),
        24usize,
        concat!("Size of: ", stringify!(XServerInterpretedAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<XServerInterpretedAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(XServerInterpretedAddress))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XImage {
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub xoffset: ::std::os::raw::c_int,
    pub format: ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_char,
    pub byte_order: ::std::os::raw::c_int,
    pub bitmap_unit: ::std::os::raw::c_int,
    pub bitmap_bit_order: ::std::os::raw::c_int,
    pub bitmap_pad: ::std::os::raw::c_int,
    pub depth: ::std::os::raw::c_int,
    pub bytes_per_line: ::std::os::raw::c_int,
    pub bits_per_pixel: ::std::os::raw::c_int,
    pub red_mask: ::std::os::raw::c_ulong,
    pub green_mask: ::std::os::raw::c_ulong,
    pub blue_mask: ::std::os::raw::c_ulong,
    pub obdata: XPointer,
    pub f: _XImage_funcs,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XImage_funcs {
    pub create_image: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _XDisplay,
            arg2: *mut Visual,
            arg3: ::std::os::raw::c_uint,
            arg4: ::std::os::raw::c_int,
            arg5: ::std::os::raw::c_int,
            arg6: *mut ::std::os::raw::c_char,
            arg7: ::std::os::raw::c_uint,
            arg8: ::std::os::raw::c_uint,
            arg9: ::std::os::raw::c_int,
            arg10: ::std::os::raw::c_int,
        ) -> *mut _XImage,
    >,
    pub destroy_image:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _XImage) -> ::std::os::raw::c_int>,
    pub get_pixel: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _XImage,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulong,
    >,
    pub put_pixel: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _XImage,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_int,
    >,
    pub sub_image: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _XImage,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: ::std::os::raw::c_uint,
            arg5: ::std::os::raw::c_uint,
        ) -> *mut _XImage,
    >,
    pub add_pixel: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _XImage,
            arg2: ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__XImage_funcs() {
    assert_eq!(
        ::std::mem::size_of::<_XImage_funcs>(),
        48usize,
        concat!("Size of: ", stringify!(_XImage_funcs))
    );
    assert_eq!(
        ::std::mem::align_of::<_XImage_funcs>(),
        8usize,
        concat!("Alignment of ", stringify!(_XImage_funcs))
    );
}
#[test]
fn bindgen_test_layout__XImage() {
    assert_eq!(
        ::std::mem::size_of::<_XImage>(),
        136usize,
        concat!("Size of: ", stringify!(_XImage))
    );
    assert_eq!(
        ::std::mem::align_of::<_XImage>(),
        8usize,
        concat!("Alignment of ", stringify!(_XImage))
    );
}
pub type XImage = _XImage;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XWindowChanges {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub border_width: ::std::os::raw::c_int,
    pub sibling: Window,
    pub stack_mode: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XWindowChanges() {
    assert_eq!(
        ::std::mem::size_of::<XWindowChanges>(),
        40usize,
        concat!("Size of: ", stringify!(XWindowChanges))
    );
    assert_eq!(
        ::std::mem::align_of::<XWindowChanges>(),
        8usize,
        concat!("Alignment of ", stringify!(XWindowChanges))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XColor {
    pub pixel: ::std::os::raw::c_ulong,
    pub red: ::std::os::raw::c_ushort,
    pub green: ::std::os::raw::c_ushort,
    pub blue: ::std::os::raw::c_ushort,
    pub flags: ::std::os::raw::c_char,
    pub pad: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_XColor() {
    assert_eq!(
        ::std::mem::size_of::<XColor>(),
        16usize,
        concat!("Size of: ", stringify!(XColor))
    );
    assert_eq!(
        ::std::mem::align_of::<XColor>(),
        8usize,
        concat!("Alignment of ", stringify!(XColor))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XSegment {
    pub x1: ::std::os::raw::c_short,
    pub y1: ::std::os::raw::c_short,
    pub x2: ::std::os::raw::c_short,
    pub y2: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_XSegment() {
    assert_eq!(
        ::std::mem::size_of::<XSegment>(),
        8usize,
        concat!("Size of: ", stringify!(XSegment))
    );
    assert_eq!(
        ::std::mem::align_of::<XSegment>(),
        2usize,
        concat!("Alignment of ", stringify!(XSegment))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XPoint {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_XPoint() {
    assert_eq!(
        ::std::mem::size_of::<XPoint>(),
        4usize,
        concat!("Size of: ", stringify!(XPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<XPoint>(),
        2usize,
        concat!("Alignment of ", stringify!(XPoint))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XRectangle {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub width: ::std::os::raw::c_ushort,
    pub height: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_XRectangle() {
    assert_eq!(
        ::std::mem::size_of::<XRectangle>(),
        8usize,
        concat!("Size of: ", stringify!(XRectangle))
    );
    assert_eq!(
        ::std::mem::align_of::<XRectangle>(),
        2usize,
        concat!("Alignment of ", stringify!(XRectangle))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XArc {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub width: ::std::os::raw::c_ushort,
    pub height: ::std::os::raw::c_ushort,
    pub angle1: ::std::os::raw::c_short,
    pub angle2: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_XArc() {
    assert_eq!(
        ::std::mem::size_of::<XArc>(),
        12usize,
        concat!("Size of: ", stringify!(XArc))
    );
    assert_eq!(
        ::std::mem::align_of::<XArc>(),
        2usize,
        concat!("Alignment of ", stringify!(XArc))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XKeyboardControl {
    pub key_click_percent: ::std::os::raw::c_int,
    pub bell_percent: ::std::os::raw::c_int,
    pub bell_pitch: ::std::os::raw::c_int,
    pub bell_duration: ::std::os::raw::c_int,
    pub led: ::std::os::raw::c_int,
    pub led_mode: ::std::os::raw::c_int,
    pub key: ::std::os::raw::c_int,
    pub auto_repeat_mode: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XKeyboardControl() {
    assert_eq!(
        ::std::mem::size_of::<XKeyboardControl>(),
        32usize,
        concat!("Size of: ", stringify!(XKeyboardControl))
    );
    assert_eq!(
        ::std::mem::align_of::<XKeyboardControl>(),
        4usize,
        concat!("Alignment of ", stringify!(XKeyboardControl))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XKeyboardState {
    pub key_click_percent: ::std::os::raw::c_int,
    pub bell_percent: ::std::os::raw::c_int,
    pub bell_pitch: ::std::os::raw::c_uint,
    pub bell_duration: ::std::os::raw::c_uint,
    pub led_mask: ::std::os::raw::c_ulong,
    pub global_auto_repeat: ::std::os::raw::c_int,
    pub auto_repeats: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_XKeyboardState() {
    assert_eq!(
        ::std::mem::size_of::<XKeyboardState>(),
        64usize,
        concat!("Size of: ", stringify!(XKeyboardState))
    );
    assert_eq!(
        ::std::mem::align_of::<XKeyboardState>(),
        8usize,
        concat!("Alignment of ", stringify!(XKeyboardState))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XTimeCoord {
    pub time: Time,
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_XTimeCoord() {
    assert_eq!(
        ::std::mem::size_of::<XTimeCoord>(),
        16usize,
        concat!("Size of: ", stringify!(XTimeCoord))
    );
    assert_eq!(
        ::std::mem::align_of::<XTimeCoord>(),
        8usize,
        concat!("Alignment of ", stringify!(XTimeCoord))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XModifierKeymap {
    pub max_keypermod: ::std::os::raw::c_int,
    pub modifiermap: *mut KeyCode,
}
#[test]
fn bindgen_test_layout_XModifierKeymap() {
    assert_eq!(
        ::std::mem::size_of::<XModifierKeymap>(),
        16usize,
        concat!("Size of: ", stringify!(XModifierKeymap))
    );
    assert_eq!(
        ::std::mem::align_of::<XModifierKeymap>(),
        8usize,
        concat!("Alignment of ", stringify!(XModifierKeymap))
    );
}
pub type Display = _XDisplay;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XPrivate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XrmHashBucketRec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _bindgen_ty_11 {
    pub ext_data: *mut XExtData,
    pub private1: *mut _XPrivate,
    pub fd: ::std::os::raw::c_int,
    pub private2: ::std::os::raw::c_int,
    pub proto_major_version: ::std::os::raw::c_int,
    pub proto_minor_version: ::std::os::raw::c_int,
    pub vendor: *mut ::std::os::raw::c_char,
    pub private3: XID,
    pub private4: XID,
    pub private5: XID,
    pub private6: ::std::os::raw::c_int,
    pub resource_alloc: ::std::option::Option<unsafe extern "C" fn(arg1: *mut _XDisplay) -> XID>,
    pub byte_order: ::std::os::raw::c_int,
    pub bitmap_unit: ::std::os::raw::c_int,
    pub bitmap_pad: ::std::os::raw::c_int,
    pub bitmap_bit_order: ::std::os::raw::c_int,
    pub nformats: ::std::os::raw::c_int,
    pub pixmap_format: *mut ScreenFormat,
    pub private8: ::std::os::raw::c_int,
    pub release: ::std::os::raw::c_int,
    pub private9: *mut _XPrivate,
    pub private10: *mut _XPrivate,
    pub qlen: ::std::os::raw::c_int,
    pub last_request_read: ::std::os::raw::c_ulong,
    pub request: ::std::os::raw::c_ulong,
    pub private11: XPointer,
    pub private12: XPointer,
    pub private13: XPointer,
    pub private14: XPointer,
    pub max_request_size: ::std::os::raw::c_uint,
    pub db: *mut _XrmHashBucketRec,
    pub private15:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _XDisplay) -> ::std::os::raw::c_int>,
    pub display_name: *mut ::std::os::raw::c_char,
    pub default_screen: ::std::os::raw::c_int,
    pub nscreens: ::std::os::raw::c_int,
    pub screens: *mut Screen,
    pub motion_buffer: ::std::os::raw::c_ulong,
    pub private16: ::std::os::raw::c_ulong,
    pub min_keycode: ::std::os::raw::c_int,
    pub max_keycode: ::std::os::raw::c_int,
    pub private17: XPointer,
    pub private18: XPointer,
    pub private19: ::std::os::raw::c_int,
    pub xdefaults: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_11() {
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_11>(),
        296usize,
        concat!("Size of: ", stringify!(_bindgen_ty_11))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_11>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_11))
    );
}
pub type _XPrivDisplay = *mut _bindgen_ty_11;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XKeyEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub root: Window,
    pub subwindow: Window,
    pub time: Time,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub x_root: ::std::os::raw::c_int,
    pub y_root: ::std::os::raw::c_int,
    pub state: ::std::os::raw::c_uint,
    pub keycode: ::std::os::raw::c_uint,
    pub same_screen: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XKeyEvent() {
    assert_eq!(
        ::std::mem::size_of::<XKeyEvent>(),
        96usize,
        concat!("Size of: ", stringify!(XKeyEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XKeyEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XKeyEvent))
    );
}
pub type XKeyPressedEvent = XKeyEvent;
pub type XKeyReleasedEvent = XKeyEvent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XButtonEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub root: Window,
    pub subwindow: Window,
    pub time: Time,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub x_root: ::std::os::raw::c_int,
    pub y_root: ::std::os::raw::c_int,
    pub state: ::std::os::raw::c_uint,
    pub button: ::std::os::raw::c_uint,
    pub same_screen: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XButtonEvent() {
    assert_eq!(
        ::std::mem::size_of::<XButtonEvent>(),
        96usize,
        concat!("Size of: ", stringify!(XButtonEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XButtonEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XButtonEvent))
    );
}
pub type XButtonPressedEvent = XButtonEvent;
pub type XButtonReleasedEvent = XButtonEvent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XMotionEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub root: Window,
    pub subwindow: Window,
    pub time: Time,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub x_root: ::std::os::raw::c_int,
    pub y_root: ::std::os::raw::c_int,
    pub state: ::std::os::raw::c_uint,
    pub is_hint: ::std::os::raw::c_char,
    pub same_screen: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XMotionEvent() {
    assert_eq!(
        ::std::mem::size_of::<XMotionEvent>(),
        96usize,
        concat!("Size of: ", stringify!(XMotionEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XMotionEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XMotionEvent))
    );
}
pub type XPointerMovedEvent = XMotionEvent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XCrossingEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub root: Window,
    pub subwindow: Window,
    pub time: Time,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub x_root: ::std::os::raw::c_int,
    pub y_root: ::std::os::raw::c_int,
    pub mode: ::std::os::raw::c_int,
    pub detail: ::std::os::raw::c_int,
    pub same_screen: ::std::os::raw::c_int,
    pub focus: ::std::os::raw::c_int,
    pub state: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_XCrossingEvent() {
    assert_eq!(
        ::std::mem::size_of::<XCrossingEvent>(),
        104usize,
        concat!("Size of: ", stringify!(XCrossingEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XCrossingEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XCrossingEvent))
    );
}
pub type XEnterWindowEvent = XCrossingEvent;
pub type XLeaveWindowEvent = XCrossingEvent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XFocusChangeEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub mode: ::std::os::raw::c_int,
    pub detail: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XFocusChangeEvent() {
    assert_eq!(
        ::std::mem::size_of::<XFocusChangeEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XFocusChangeEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XFocusChangeEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XFocusChangeEvent))
    );
}
pub type XFocusInEvent = XFocusChangeEvent;
pub type XFocusOutEvent = XFocusChangeEvent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XKeymapEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub key_vector: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_XKeymapEvent() {
    assert_eq!(
        ::std::mem::size_of::<XKeymapEvent>(),
        72usize,
        concat!("Size of: ", stringify!(XKeymapEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XKeymapEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XKeymapEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XExposeEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XExposeEvent() {
    assert_eq!(
        ::std::mem::size_of::<XExposeEvent>(),
        64usize,
        concat!("Size of: ", stringify!(XExposeEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XExposeEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XExposeEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XGraphicsExposeEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub drawable: Drawable,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
    pub major_code: ::std::os::raw::c_int,
    pub minor_code: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XGraphicsExposeEvent() {
    assert_eq!(
        ::std::mem::size_of::<XGraphicsExposeEvent>(),
        72usize,
        concat!("Size of: ", stringify!(XGraphicsExposeEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XGraphicsExposeEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XGraphicsExposeEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XNoExposeEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub drawable: Drawable,
    pub major_code: ::std::os::raw::c_int,
    pub minor_code: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XNoExposeEvent() {
    assert_eq!(
        ::std::mem::size_of::<XNoExposeEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XNoExposeEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XNoExposeEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XNoExposeEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XVisibilityEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub state: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XVisibilityEvent() {
    assert_eq!(
        ::std::mem::size_of::<XVisibilityEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XVisibilityEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XVisibilityEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XVisibilityEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XCreateWindowEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub parent: Window,
    pub window: Window,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub border_width: ::std::os::raw::c_int,
    pub override_redirect: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XCreateWindowEvent() {
    assert_eq!(
        ::std::mem::size_of::<XCreateWindowEvent>(),
        72usize,
        concat!("Size of: ", stringify!(XCreateWindowEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XCreateWindowEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XCreateWindowEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XDestroyWindowEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
}
#[test]
fn bindgen_test_layout_XDestroyWindowEvent() {
    assert_eq!(
        ::std::mem::size_of::<XDestroyWindowEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XDestroyWindowEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XDestroyWindowEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XDestroyWindowEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XUnmapEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub from_configure: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XUnmapEvent() {
    assert_eq!(
        ::std::mem::size_of::<XUnmapEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XUnmapEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XUnmapEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XUnmapEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XMapEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub override_redirect: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XMapEvent() {
    assert_eq!(
        ::std::mem::size_of::<XMapEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XMapEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XMapEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XMapEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XMapRequestEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub parent: Window,
    pub window: Window,
}
#[test]
fn bindgen_test_layout_XMapRequestEvent() {
    assert_eq!(
        ::std::mem::size_of::<XMapRequestEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XMapRequestEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XMapRequestEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XMapRequestEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XReparentEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub parent: Window,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub override_redirect: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XReparentEvent() {
    assert_eq!(
        ::std::mem::size_of::<XReparentEvent>(),
        72usize,
        concat!("Size of: ", stringify!(XReparentEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XReparentEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XReparentEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XConfigureEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub border_width: ::std::os::raw::c_int,
    pub above: Window,
    pub override_redirect: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XConfigureEvent() {
    assert_eq!(
        ::std::mem::size_of::<XConfigureEvent>(),
        88usize,
        concat!("Size of: ", stringify!(XConfigureEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XConfigureEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XConfigureEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XGravityEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XGravityEvent() {
    assert_eq!(
        ::std::mem::size_of::<XGravityEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XGravityEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XGravityEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XGravityEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XResizeRequestEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XResizeRequestEvent() {
    assert_eq!(
        ::std::mem::size_of::<XResizeRequestEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XResizeRequestEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XResizeRequestEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XResizeRequestEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XConfigureRequestEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub parent: Window,
    pub window: Window,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub border_width: ::std::os::raw::c_int,
    pub above: Window,
    pub detail: ::std::os::raw::c_int,
    pub value_mask: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_XConfigureRequestEvent() {
    assert_eq!(
        ::std::mem::size_of::<XConfigureRequestEvent>(),
        96usize,
        concat!("Size of: ", stringify!(XConfigureRequestEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XConfigureRequestEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XConfigureRequestEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XCirculateEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub place: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XCirculateEvent() {
    assert_eq!(
        ::std::mem::size_of::<XCirculateEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XCirculateEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XCirculateEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XCirculateEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XCirculateRequestEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub parent: Window,
    pub window: Window,
    pub place: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XCirculateRequestEvent() {
    assert_eq!(
        ::std::mem::size_of::<XCirculateRequestEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XCirculateRequestEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XCirculateRequestEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XCirculateRequestEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XPropertyEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub atom: Atom,
    pub time: Time,
    pub state: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XPropertyEvent() {
    assert_eq!(
        ::std::mem::size_of::<XPropertyEvent>(),
        64usize,
        concat!("Size of: ", stringify!(XPropertyEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XPropertyEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XPropertyEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XSelectionClearEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub selection: Atom,
    pub time: Time,
}
#[test]
fn bindgen_test_layout_XSelectionClearEvent() {
    assert_eq!(
        ::std::mem::size_of::<XSelectionClearEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XSelectionClearEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XSelectionClearEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XSelectionClearEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XSelectionRequestEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub owner: Window,
    pub requestor: Window,
    pub selection: Atom,
    pub target: Atom,
    pub property: Atom,
    pub time: Time,
}
#[test]
fn bindgen_test_layout_XSelectionRequestEvent() {
    assert_eq!(
        ::std::mem::size_of::<XSelectionRequestEvent>(),
        80usize,
        concat!("Size of: ", stringify!(XSelectionRequestEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XSelectionRequestEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XSelectionRequestEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XSelectionEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub requestor: Window,
    pub selection: Atom,
    pub target: Atom,
    pub property: Atom,
    pub time: Time,
}
#[test]
fn bindgen_test_layout_XSelectionEvent() {
    assert_eq!(
        ::std::mem::size_of::<XSelectionEvent>(),
        72usize,
        concat!("Size of: ", stringify!(XSelectionEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XSelectionEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XSelectionEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XColormapEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub colormap: Colormap,
    pub new: ::std::os::raw::c_int,
    pub state: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XColormapEvent() {
    assert_eq!(
        ::std::mem::size_of::<XColormapEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XColormapEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XColormapEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XColormapEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XClientMessageEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub message_type: Atom,
    pub format: ::std::os::raw::c_int,
    pub data: XClientMessageEvent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union XClientMessageEvent__bindgen_ty_1 {
    pub b: [::std::os::raw::c_char; 20usize],
    pub s: [::std::os::raw::c_short; 10usize],
    pub l: [::std::os::raw::c_long; 5usize],
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_XClientMessageEvent__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<XClientMessageEvent__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(XClientMessageEvent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<XClientMessageEvent__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(XClientMessageEvent__bindgen_ty_1)
        )
    );
}
#[test]
fn bindgen_test_layout_XClientMessageEvent() {
    assert_eq!(
        ::std::mem::size_of::<XClientMessageEvent>(),
        96usize,
        concat!("Size of: ", stringify!(XClientMessageEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XClientMessageEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XClientMessageEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XMappingEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub request: ::std::os::raw::c_int,
    pub first_keycode: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XMappingEvent() {
    assert_eq!(
        ::std::mem::size_of::<XMappingEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XMappingEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XMappingEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XMappingEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XErrorEvent {
    pub type_: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub resourceid: XID,
    pub serial: ::std::os::raw::c_ulong,
    pub error_code: ::std::os::raw::c_uchar,
    pub request_code: ::std::os::raw::c_uchar,
    pub minor_code: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_XErrorEvent() {
    assert_eq!(
        ::std::mem::size_of::<XErrorEvent>(),
        40usize,
        concat!("Size of: ", stringify!(XErrorEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XErrorEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XErrorEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XAnyEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
}
#[test]
fn bindgen_test_layout_XAnyEvent() {
    assert_eq!(
        ::std::mem::size_of::<XAnyEvent>(),
        40usize,
        concat!("Size of: ", stringify!(XAnyEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XAnyEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XAnyEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XGenericEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub extension: ::std::os::raw::c_int,
    pub evtype: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XGenericEvent() {
    assert_eq!(
        ::std::mem::size_of::<XGenericEvent>(),
        40usize,
        concat!("Size of: ", stringify!(XGenericEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XGenericEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XGenericEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XGenericEventCookie {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub extension: ::std::os::raw::c_int,
    pub evtype: ::std::os::raw::c_int,
    pub cookie: ::std::os::raw::c_uint,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_XGenericEventCookie() {
    assert_eq!(
        ::std::mem::size_of::<XGenericEventCookie>(),
        56usize,
        concat!("Size of: ", stringify!(XGenericEventCookie))
    );
    assert_eq!(
        ::std::mem::align_of::<XGenericEventCookie>(),
        8usize,
        concat!("Alignment of ", stringify!(XGenericEventCookie))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XEvent {
    pub type_: ::std::os::raw::c_int,
    pub xany: XAnyEvent,
    pub xkey: XKeyEvent,
    pub xbutton: XButtonEvent,
    pub xmotion: XMotionEvent,
    pub xcrossing: XCrossingEvent,
    pub xfocus: XFocusChangeEvent,
    pub xexpose: XExposeEvent,
    pub xgraphicsexpose: XGraphicsExposeEvent,
    pub xnoexpose: XNoExposeEvent,
    pub xvisibility: XVisibilityEvent,
    pub xcreatewindow: XCreateWindowEvent,
    pub xdestroywindow: XDestroyWindowEvent,
    pub xunmap: XUnmapEvent,
    pub xmap: XMapEvent,
    pub xmaprequest: XMapRequestEvent,
    pub xreparent: XReparentEvent,
    pub xconfigure: XConfigureEvent,
    pub xgravity: XGravityEvent,
    pub xresizerequest: XResizeRequestEvent,
    pub xconfigurerequest: XConfigureRequestEvent,
    pub xcirculate: XCirculateEvent,
    pub xcirculaterequest: XCirculateRequestEvent,
    pub xproperty: XPropertyEvent,
    pub xselectionclear: XSelectionClearEvent,
    pub xselectionrequest: XSelectionRequestEvent,
    pub xselection: XSelectionEvent,
    pub xcolormap: XColormapEvent,
    pub xclient: XClientMessageEvent,
    pub xmapping: XMappingEvent,
    pub xerror: XErrorEvent,
    pub xkeymap: XKeymapEvent,
    pub xgeneric: XGenericEvent,
    pub xcookie: XGenericEventCookie,
    pub pad: [::std::os::raw::c_long; 24usize],
    _bindgen_union_align: [u64; 24usize],
}
#[test]
fn bindgen_test_layout__XEvent() {
    assert_eq!(
        ::std::mem::size_of::<_XEvent>(),
        192usize,
        concat!("Size of: ", stringify!(_XEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<_XEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(_XEvent))
    );
}
pub type XEvent = _XEvent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XCharStruct {
    pub lbearing: ::std::os::raw::c_short,
    pub rbearing: ::std::os::raw::c_short,
    pub width: ::std::os::raw::c_short,
    pub ascent: ::std::os::raw::c_short,
    pub descent: ::std::os::raw::c_short,
    pub attributes: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_XCharStruct() {
    assert_eq!(
        ::std::mem::size_of::<XCharStruct>(),
        12usize,
        concat!("Size of: ", stringify!(XCharStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<XCharStruct>(),
        2usize,
        concat!("Alignment of ", stringify!(XCharStruct))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XFontProp {
    pub name: Atom,
    pub card32: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_XFontProp() {
    assert_eq!(
        ::std::mem::size_of::<XFontProp>(),
        16usize,
        concat!("Size of: ", stringify!(XFontProp))
    );
    assert_eq!(
        ::std::mem::align_of::<XFontProp>(),
        8usize,
        concat!("Alignment of ", stringify!(XFontProp))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XFontStruct {
    pub ext_data: *mut XExtData,
    pub fid: Font,
    pub direction: ::std::os::raw::c_uint,
    pub min_char_or_byte2: ::std::os::raw::c_uint,
    pub max_char_or_byte2: ::std::os::raw::c_uint,
    pub min_byte1: ::std::os::raw::c_uint,
    pub max_byte1: ::std::os::raw::c_uint,
    pub all_chars_exist: ::std::os::raw::c_int,
    pub default_char: ::std::os::raw::c_uint,
    pub n_properties: ::std::os::raw::c_int,
    pub properties: *mut XFontProp,
    pub min_bounds: XCharStruct,
    pub max_bounds: XCharStruct,
    pub per_char: *mut XCharStruct,
    pub ascent: ::std::os::raw::c_int,
    pub descent: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XFontStruct() {
    assert_eq!(
        ::std::mem::size_of::<XFontStruct>(),
        96usize,
        concat!("Size of: ", stringify!(XFontStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<XFontStruct>(),
        8usize,
        concat!("Alignment of ", stringify!(XFontStruct))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XTextItem {
    pub chars: *mut ::std::os::raw::c_char,
    pub nchars: ::std::os::raw::c_int,
    pub delta: ::std::os::raw::c_int,
    pub font: Font,
}
#[test]
fn bindgen_test_layout_XTextItem() {
    assert_eq!(
        ::std::mem::size_of::<XTextItem>(),
        24usize,
        concat!("Size of: ", stringify!(XTextItem))
    );
    assert_eq!(
        ::std::mem::align_of::<XTextItem>(),
        8usize,
        concat!("Alignment of ", stringify!(XTextItem))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XChar2b {
    pub byte1: ::std::os::raw::c_uchar,
    pub byte2: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_XChar2b() {
    assert_eq!(
        ::std::mem::size_of::<XChar2b>(),
        2usize,
        concat!("Size of: ", stringify!(XChar2b))
    );
    assert_eq!(
        ::std::mem::align_of::<XChar2b>(),
        1usize,
        concat!("Alignment of ", stringify!(XChar2b))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XTextItem16 {
    pub chars: *mut XChar2b,
    pub nchars: ::std::os::raw::c_int,
    pub delta: ::std::os::raw::c_int,
    pub font: Font,
}
#[test]
fn bindgen_test_layout_XTextItem16() {
    assert_eq!(
        ::std::mem::size_of::<XTextItem16>(),
        24usize,
        concat!("Size of: ", stringify!(XTextItem16))
    );
    assert_eq!(
        ::std::mem::align_of::<XTextItem16>(),
        8usize,
        concat!("Alignment of ", stringify!(XTextItem16))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union XEDataObject {
    pub display: *mut Display,
    pub gc: GC,
    pub visual: *mut Visual,
    pub screen: *mut Screen,
    pub pixmap_format: *mut ScreenFormat,
    pub font: *mut XFontStruct,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_XEDataObject() {
    assert_eq!(
        ::std::mem::size_of::<XEDataObject>(),
        8usize,
        concat!("Size of: ", stringify!(XEDataObject))
    );
    assert_eq!(
        ::std::mem::align_of::<XEDataObject>(),
        8usize,
        concat!("Alignment of ", stringify!(XEDataObject))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XFontSetExtents {
    pub max_ink_extent: XRectangle,
    pub max_logical_extent: XRectangle,
}
#[test]
fn bindgen_test_layout_XFontSetExtents() {
    assert_eq!(
        ::std::mem::size_of::<XFontSetExtents>(),
        16usize,
        concat!("Size of: ", stringify!(XFontSetExtents))
    );
    assert_eq!(
        ::std::mem::align_of::<XFontSetExtents>(),
        2usize,
        concat!("Alignment of ", stringify!(XFontSetExtents))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XOM {
    _unused: [u8; 0],
}
pub type XOM = *mut _XOM;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XOC {
    _unused: [u8; 0],
}
pub type XOC = *mut _XOC;
pub type XFontSet = *mut _XOC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XmbTextItem {
    pub chars: *mut ::std::os::raw::c_char,
    pub nchars: ::std::os::raw::c_int,
    pub delta: ::std::os::raw::c_int,
    pub font_set: XFontSet,
}
#[test]
fn bindgen_test_layout_XmbTextItem() {
    assert_eq!(
        ::std::mem::size_of::<XmbTextItem>(),
        24usize,
        concat!("Size of: ", stringify!(XmbTextItem))
    );
    assert_eq!(
        ::std::mem::align_of::<XmbTextItem>(),
        8usize,
        concat!("Alignment of ", stringify!(XmbTextItem))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XwcTextItem {
    pub chars: *mut wchar_t,
    pub nchars: ::std::os::raw::c_int,
    pub delta: ::std::os::raw::c_int,
    pub font_set: XFontSet,
}
#[test]
fn bindgen_test_layout_XwcTextItem() {
    assert_eq!(
        ::std::mem::size_of::<XwcTextItem>(),
        24usize,
        concat!("Size of: ", stringify!(XwcTextItem))
    );
    assert_eq!(
        ::std::mem::align_of::<XwcTextItem>(),
        8usize,
        concat!("Alignment of ", stringify!(XwcTextItem))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XOMCharSetList {
    pub charset_count: ::std::os::raw::c_int,
    pub charset_list: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_XOMCharSetList() {
    assert_eq!(
        ::std::mem::size_of::<XOMCharSetList>(),
        16usize,
        concat!("Size of: ", stringify!(XOMCharSetList))
    );
    assert_eq!(
        ::std::mem::align_of::<XOMCharSetList>(),
        8usize,
        concat!("Alignment of ", stringify!(XOMCharSetList))
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum XOrientation {
    XOMOrientation_LTR_TTB = 0,
    XOMOrientation_RTL_TTB = 1,
    XOMOrientation_TTB_LTR = 2,
    XOMOrientation_TTB_RTL = 3,
    XOMOrientation_Context = 4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XOMOrientation {
    pub num_orientation: ::std::os::raw::c_int,
    pub orientation: *mut XOrientation,
}
#[test]
fn bindgen_test_layout_XOMOrientation() {
    assert_eq!(
        ::std::mem::size_of::<XOMOrientation>(),
        16usize,
        concat!("Size of: ", stringify!(XOMOrientation))
    );
    assert_eq!(
        ::std::mem::align_of::<XOMOrientation>(),
        8usize,
        concat!("Alignment of ", stringify!(XOMOrientation))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XOMFontInfo {
    pub num_font: ::std::os::raw::c_int,
    pub font_struct_list: *mut *mut XFontStruct,
    pub font_name_list: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_XOMFontInfo() {
    assert_eq!(
        ::std::mem::size_of::<XOMFontInfo>(),
        24usize,
        concat!("Size of: ", stringify!(XOMFontInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<XOMFontInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(XOMFontInfo))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIM {
    _unused: [u8; 0],
}
pub type XIM = *mut _XIM;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIC {
    _unused: [u8; 0],
}
pub type XIC = *mut _XIC;
pub type XIMProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: XIM, arg2: XPointer, arg3: XPointer)>;
pub type XICProc = ::std::option::Option<
    unsafe extern "C" fn(arg1: XIC, arg2: XPointer, arg3: XPointer) -> ::std::os::raw::c_int,
>;
pub type XIDProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Display, arg2: XPointer, arg3: XPointer)>;
pub type XIMStyle = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XIMStyles {
    pub count_styles: ::std::os::raw::c_ushort,
    pub supported_styles: *mut XIMStyle,
}
#[test]
fn bindgen_test_layout_XIMStyles() {
    assert_eq!(
        ::std::mem::size_of::<XIMStyles>(),
        16usize,
        concat!("Size of: ", stringify!(XIMStyles))
    );
    assert_eq!(
        ::std::mem::align_of::<XIMStyles>(),
        8usize,
        concat!("Alignment of ", stringify!(XIMStyles))
    );
}
pub type XVaNestedList = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XIMCallback {
    pub client_data: XPointer,
    pub callback: XIMProc,
}
#[test]
fn bindgen_test_layout_XIMCallback() {
    assert_eq!(
        ::std::mem::size_of::<XIMCallback>(),
        16usize,
        concat!("Size of: ", stringify!(XIMCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<XIMCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(XIMCallback))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XICCallback {
    pub client_data: XPointer,
    pub callback: XICProc,
}
#[test]
fn bindgen_test_layout_XICCallback() {
    assert_eq!(
        ::std::mem::size_of::<XICCallback>(),
        16usize,
        concat!("Size of: ", stringify!(XICCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<XICCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(XICCallback))
    );
}
pub type XIMFeedback = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMText {
    pub length: ::std::os::raw::c_ushort,
    pub feedback: *mut XIMFeedback,
    pub encoding_is_wchar: ::std::os::raw::c_int,
    pub string: _XIMText__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XIMText__bindgen_ty_1 {
    pub multi_byte: *mut ::std::os::raw::c_char,
    pub wide_char: *mut wchar_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__XIMText__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_XIMText__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_XIMText__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMText__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMText__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout__XIMText() {
    assert_eq!(
        ::std::mem::size_of::<_XIMText>(),
        32usize,
        concat!("Size of: ", stringify!(_XIMText))
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMText>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMText))
    );
}
pub type XIMText = _XIMText;
pub type XIMPreeditState = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMPreeditStateNotifyCallbackStruct {
    pub state: XIMPreeditState,
}
#[test]
fn bindgen_test_layout__XIMPreeditStateNotifyCallbackStruct() {
    assert_eq!(
        ::std::mem::size_of::<_XIMPreeditStateNotifyCallbackStruct>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_XIMPreeditStateNotifyCallbackStruct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMPreeditStateNotifyCallbackStruct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_XIMPreeditStateNotifyCallbackStruct)
        )
    );
}
pub type XIMPreeditStateNotifyCallbackStruct = _XIMPreeditStateNotifyCallbackStruct;
pub type XIMResetState = ::std::os::raw::c_ulong;
pub type XIMStringConversionFeedback = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMStringConversionText {
    pub length: ::std::os::raw::c_ushort,
    pub feedback: *mut XIMStringConversionFeedback,
    pub encoding_is_wchar: ::std::os::raw::c_int,
    pub string: _XIMStringConversionText__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XIMStringConversionText__bindgen_ty_1 {
    pub mbs: *mut ::std::os::raw::c_char,
    pub wcs: *mut wchar_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__XIMStringConversionText__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_XIMStringConversionText__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_XIMStringConversionText__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMStringConversionText__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_XIMStringConversionText__bindgen_ty_1)
        )
    );
}
#[test]
fn bindgen_test_layout__XIMStringConversionText() {
    assert_eq!(
        ::std::mem::size_of::<_XIMStringConversionText>(),
        32usize,
        concat!("Size of: ", stringify!(_XIMStringConversionText))
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMStringConversionText>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMStringConversionText))
    );
}
pub type XIMStringConversionText = _XIMStringConversionText;
pub type XIMStringConversionPosition = ::std::os::raw::c_ushort;
pub type XIMStringConversionType = ::std::os::raw::c_ushort;
pub type XIMStringConversionOperation = ::std::os::raw::c_ushort;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum XIMCaretDirection {
    XIMForwardChar = 0,
    XIMBackwardChar = 1,
    XIMForwardWord = 2,
    XIMBackwardWord = 3,
    XIMCaretUp = 4,
    XIMCaretDown = 5,
    XIMNextLine = 6,
    XIMPreviousLine = 7,
    XIMLineStart = 8,
    XIMLineEnd = 9,
    XIMAbsolutePosition = 10,
    XIMDontChange = 11,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMStringConversionCallbackStruct {
    pub position: XIMStringConversionPosition,
    pub direction: XIMCaretDirection,
    pub operation: XIMStringConversionOperation,
    pub factor: ::std::os::raw::c_ushort,
    pub text: *mut XIMStringConversionText,
}
#[test]
fn bindgen_test_layout__XIMStringConversionCallbackStruct() {
    assert_eq!(
        ::std::mem::size_of::<_XIMStringConversionCallbackStruct>(),
        24usize,
        concat!("Size of: ", stringify!(_XIMStringConversionCallbackStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMStringConversionCallbackStruct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_XIMStringConversionCallbackStruct)
        )
    );
}
pub type XIMStringConversionCallbackStruct = _XIMStringConversionCallbackStruct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMPreeditDrawCallbackStruct {
    pub caret: ::std::os::raw::c_int,
    pub chg_first: ::std::os::raw::c_int,
    pub chg_length: ::std::os::raw::c_int,
    pub text: *mut XIMText,
}
#[test]
fn bindgen_test_layout__XIMPreeditDrawCallbackStruct() {
    assert_eq!(
        ::std::mem::size_of::<_XIMPreeditDrawCallbackStruct>(),
        24usize,
        concat!("Size of: ", stringify!(_XIMPreeditDrawCallbackStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMPreeditDrawCallbackStruct>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMPreeditDrawCallbackStruct))
    );
}
pub type XIMPreeditDrawCallbackStruct = _XIMPreeditDrawCallbackStruct;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum XIMCaretStyle {
    XIMIsInvisible = 0,
    XIMIsPrimary = 1,
    XIMIsSecondary = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMPreeditCaretCallbackStruct {
    pub position: ::std::os::raw::c_int,
    pub direction: XIMCaretDirection,
    pub style: XIMCaretStyle,
}
#[test]
fn bindgen_test_layout__XIMPreeditCaretCallbackStruct() {
    assert_eq!(
        ::std::mem::size_of::<_XIMPreeditCaretCallbackStruct>(),
        12usize,
        concat!("Size of: ", stringify!(_XIMPreeditCaretCallbackStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMPreeditCaretCallbackStruct>(),
        4usize,
        concat!("Alignment of ", stringify!(_XIMPreeditCaretCallbackStruct))
    );
}
pub type XIMPreeditCaretCallbackStruct = _XIMPreeditCaretCallbackStruct;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum XIMStatusDataType {
    XIMTextType = 0,
    XIMBitmapType = 1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMStatusDrawCallbackStruct {
    pub type_: XIMStatusDataType,
    pub data: _XIMStatusDrawCallbackStruct__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XIMStatusDrawCallbackStruct__bindgen_ty_1 {
    pub text: *mut XIMText,
    pub bitmap: Pixmap,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__XIMStatusDrawCallbackStruct__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_XIMStatusDrawCallbackStruct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_XIMStatusDrawCallbackStruct__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMStatusDrawCallbackStruct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_XIMStatusDrawCallbackStruct__bindgen_ty_1)
        )
    );
}
#[test]
fn bindgen_test_layout__XIMStatusDrawCallbackStruct() {
    assert_eq!(
        ::std::mem::size_of::<_XIMStatusDrawCallbackStruct>(),
        16usize,
        concat!("Size of: ", stringify!(_XIMStatusDrawCallbackStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMStatusDrawCallbackStruct>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMStatusDrawCallbackStruct))
    );
}
pub type XIMStatusDrawCallbackStruct = _XIMStatusDrawCallbackStruct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMHotKeyTrigger {
    pub keysym: KeySym,
    pub modifier: ::std::os::raw::c_int,
    pub modifier_mask: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__XIMHotKeyTrigger() {
    assert_eq!(
        ::std::mem::size_of::<_XIMHotKeyTrigger>(),
        16usize,
        concat!("Size of: ", stringify!(_XIMHotKeyTrigger))
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMHotKeyTrigger>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMHotKeyTrigger))
    );
}
pub type XIMHotKeyTrigger = _XIMHotKeyTrigger;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMHotKeyTriggers {
    pub num_hot_key: ::std::os::raw::c_int,
    pub key: *mut XIMHotKeyTrigger,
}
#[test]
fn bindgen_test_layout__XIMHotKeyTriggers() {
    assert_eq!(
        ::std::mem::size_of::<_XIMHotKeyTriggers>(),
        16usize,
        concat!("Size of: ", stringify!(_XIMHotKeyTriggers))
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMHotKeyTriggers>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMHotKeyTriggers))
    );
}
pub type XIMHotKeyTriggers = _XIMHotKeyTriggers;
pub type XIMHotKeyState = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XIMValuesList {
    pub count_values: ::std::os::raw::c_ushort,
    pub supported_values: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_XIMValuesList() {
    assert_eq!(
        ::std::mem::size_of::<XIMValuesList>(),
        16usize,
        concat!("Size of: ", stringify!(XIMValuesList))
    );
    assert_eq!(
        ::std::mem::align_of::<XIMValuesList>(),
        8usize,
        concat!("Alignment of ", stringify!(XIMValuesList))
    );
}
extern "C" {
    #[link_name = "\u{1}_Xdebug"]
    pub static mut _Xdebug: ::std::os::raw::c_int;
}
extern "C" {
    pub fn XLoadQueryFont(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut XFontStruct;
}
extern "C" {
    pub fn XQueryFont(arg1: *mut Display, arg2: XID) -> *mut XFontStruct;
}
extern "C" {
    pub fn XGetMotionEvents(
        arg1: *mut Display,
        arg2: Window,
        arg3: Time,
        arg4: Time,
        arg5: *mut ::std::os::raw::c_int,
    ) -> *mut XTimeCoord;
}
extern "C" {
    pub fn XDeleteModifiermapEntry(
        arg1: *mut XModifierKeymap,
        arg2: KeyCode,
        arg3: ::std::os::raw::c_int,
    ) -> *mut XModifierKeymap;
}
extern "C" {
    pub fn XGetModifierMapping(arg1: *mut Display) -> *mut XModifierKeymap;
}
extern "C" {
    pub fn XInsertModifiermapEntry(
        arg1: *mut XModifierKeymap,
        arg2: KeyCode,
        arg3: ::std::os::raw::c_int,
    ) -> *mut XModifierKeymap;
}
extern "C" {
    pub fn XNewModifiermap(arg1: ::std::os::raw::c_int) -> *mut XModifierKeymap;
}
extern "C" {
    pub fn XCreateImage(
        arg1: *mut Display,
        arg2: *mut Visual,
        arg3: ::std::os::raw::c_uint,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_char,
        arg7: ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_uint,
        arg9: ::std::os::raw::c_int,
        arg10: ::std::os::raw::c_int,
    ) -> *mut XImage;
}
extern "C" {
    pub fn XInitImage(arg1: *mut XImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetImage(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_uint,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_ulong,
        arg8: ::std::os::raw::c_int,
    ) -> *mut XImage;
}
extern "C" {
    pub fn XGetSubImage(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_uint,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_ulong,
        arg8: ::std::os::raw::c_int,
        arg9: *mut XImage,
        arg10: ::std::os::raw::c_int,
        arg11: ::std::os::raw::c_int,
    ) -> *mut XImage;
}
extern "C" {
    pub fn XOpenDisplay(arg1: *const ::std::os::raw::c_char) -> *mut Display;
}
extern "C" {
    pub fn XrmInitialize();
}
extern "C" {
    pub fn XFetchBytes(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XFetchBuffer(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XGetAtomName(arg1: *mut Display, arg2: Atom) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XGetAtomNames(
        arg1: *mut Display,
        arg2: *mut Atom,
        arg3: ::std::os::raw::c_int,
        arg4: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetDefault(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XDisplayName(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XKeysymToString(arg1: KeySym) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XSynchronize(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Display,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn XSetAfterFunction(
        arg1: *mut Display,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut Display) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Display,
            arg2: ::std::option::Option<
                unsafe extern "C" fn(arg1: *mut Display) -> ::std::os::raw::c_int,
            >,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn XInternAtom(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> Atom;
}
extern "C" {
    pub fn XInternAtoms(
        arg1: *mut Display,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut Atom,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCopyColormapAndFree(arg1: *mut Display, arg2: Colormap) -> Colormap;
}
extern "C" {
    pub fn XCreateColormap(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Visual,
        arg4: ::std::os::raw::c_int,
    ) -> Colormap;
}
extern "C" {
    pub fn XCreatePixmapCursor(
        arg1: *mut Display,
        arg2: Pixmap,
        arg3: Pixmap,
        arg4: *mut XColor,
        arg5: *mut XColor,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_uint,
    ) -> Cursor;
}
extern "C" {
    pub fn XCreateGlyphCursor(
        arg1: *mut Display,
        arg2: Font,
        arg3: Font,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
        arg6: *const XColor,
        arg7: *const XColor,
    ) -> Cursor;
}
extern "C" {
    pub fn XCreateFontCursor(arg1: *mut Display, arg2: ::std::os::raw::c_uint) -> Cursor;
}
extern "C" {
    pub fn XLoadFont(arg1: *mut Display, arg2: *const ::std::os::raw::c_char) -> Font;
}
extern "C" {
    pub fn XCreateGC(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: ::std::os::raw::c_ulong,
        arg4: *mut XGCValues,
    ) -> GC;
}
extern "C" {
    pub fn XGContextFromGC(arg1: GC) -> GContext;
}
extern "C" {
    pub fn XFlushGC(arg1: *mut Display, arg2: GC);
}
extern "C" {
    pub fn XCreatePixmap(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: ::std::os::raw::c_uint,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
    ) -> Pixmap;
}
extern "C" {
    pub fn XCreateBitmapFromData(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: *const ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
    ) -> Pixmap;
}
extern "C" {
    pub fn XCreatePixmapFromBitmapData(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
        arg6: ::std::os::raw::c_ulong,
        arg7: ::std::os::raw::c_ulong,
        arg8: ::std::os::raw::c_uint,
    ) -> Pixmap;
}
extern "C" {
    pub fn XCreateSimpleWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_uint,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_ulong,
        arg9: ::std::os::raw::c_ulong,
    ) -> Window;
}
extern "C" {
    pub fn XGetSelectionOwner(arg1: *mut Display, arg2: Atom) -> Window;
}
extern "C" {
    pub fn XCreateWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_uint,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_int,
        arg9: ::std::os::raw::c_uint,
        arg10: *mut Visual,
        arg11: ::std::os::raw::c_ulong,
        arg12: *mut XSetWindowAttributes,
    ) -> Window;
}
extern "C" {
    pub fn XListInstalledColormaps(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut ::std::os::raw::c_int,
    ) -> *mut Colormap;
}
extern "C" {
    pub fn XListFonts(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XListFontsWithInfo(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut *mut XFontStruct,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XGetFontPath(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XListExtensions(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XListProperties(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut ::std::os::raw::c_int,
    ) -> *mut Atom;
}
extern "C" {
    pub fn XListHosts(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
    ) -> *mut XHostAddress;
}
extern "C" {
    pub fn XKeycodeToKeysym(
        arg1: *mut Display,
        arg2: KeyCode,
        arg3: ::std::os::raw::c_int,
    ) -> KeySym;
}
extern "C" {
    pub fn XLookupKeysym(arg1: *mut XKeyEvent, arg2: ::std::os::raw::c_int) -> KeySym;
}
extern "C" {
    pub fn XGetKeyboardMapping(
        arg1: *mut Display,
        arg2: KeyCode,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut KeySym;
}
extern "C" {
    pub fn XStringToKeysym(arg1: *const ::std::os::raw::c_char) -> KeySym;
}
extern "C" {
    pub fn XMaxRequestSize(arg1: *mut Display) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn XExtendedMaxRequestSize(arg1: *mut Display) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn XResourceManagerString(arg1: *mut Display) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XScreenResourceString(arg1: *mut Screen) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XDisplayMotionBufferSize(arg1: *mut Display) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn XVisualIDFromVisual(arg1: *mut Visual) -> VisualID;
}
extern "C" {
    pub fn XInitThreads() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XLockDisplay(arg1: *mut Display);
}
extern "C" {
    pub fn XUnlockDisplay(arg1: *mut Display);
}
extern "C" {
    pub fn XInitExtension(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut XExtCodes;
}
extern "C" {
    pub fn XAddExtension(arg1: *mut Display) -> *mut XExtCodes;
}
extern "C" {
    pub fn XFindOnExtensionList(
        arg1: *mut *mut XExtData,
        arg2: ::std::os::raw::c_int,
    ) -> *mut XExtData;
}
extern "C" {
    pub fn XEHeadOfExtensionList(arg1: XEDataObject) -> *mut *mut XExtData;
}
extern "C" {
    pub fn XRootWindow(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> Window;
}
extern "C" {
    pub fn XDefaultRootWindow(arg1: *mut Display) -> Window;
}
extern "C" {
    pub fn XRootWindowOfScreen(arg1: *mut Screen) -> Window;
}
extern "C" {
    pub fn XDefaultVisual(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> *mut Visual;
}
extern "C" {
    pub fn XDefaultVisualOfScreen(arg1: *mut Screen) -> *mut Visual;
}
extern "C" {
    pub fn XDefaultGC(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> GC;
}
extern "C" {
    pub fn XDefaultGCOfScreen(arg1: *mut Screen) -> GC;
}
extern "C" {
    pub fn XBlackPixel(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn XWhitePixel(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn XAllPlanes() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn XBlackPixelOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn XWhitePixelOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn XNextRequest(arg1: *mut Display) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn XLastKnownRequestProcessed(arg1: *mut Display) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn XServerVendor(arg1: *mut Display) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XDisplayString(arg1: *mut Display) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XDefaultColormap(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> Colormap;
}
extern "C" {
    pub fn XDefaultColormapOfScreen(arg1: *mut Screen) -> Colormap;
}
extern "C" {
    pub fn XDisplayOfScreen(arg1: *mut Screen) -> *mut Display;
}
extern "C" {
    pub fn XScreenOfDisplay(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> *mut Screen;
}
extern "C" {
    pub fn XDefaultScreenOfDisplay(arg1: *mut Display) -> *mut Screen;
}
extern "C" {
    pub fn XEventMaskOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn XScreenNumberOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
pub type XErrorHandler = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut Display, arg2: *mut XErrorEvent) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn XSetErrorHandler(arg1: XErrorHandler) -> XErrorHandler;
}
pub type XIOErrorHandler =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Display) -> ::std::os::raw::c_int>;
extern "C" {
    pub fn XSetIOErrorHandler(arg1: XIOErrorHandler) -> XIOErrorHandler;
}
extern "C" {
    pub fn XListPixmapFormats(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_int,
    ) -> *mut XPixmapFormatValues;
}
extern "C" {
    pub fn XListDepths(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn XReconfigureWMWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_uint,
        arg5: *mut XWindowChanges,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetWMProtocols(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut Atom,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetWMProtocols(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Atom,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XIconifyWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XWithdrawWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetCommand(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetWMColormapWindows(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut Window,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetWMColormapWindows(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Window,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeStringList(arg1: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn XSetTransientForHint(
        arg1: *mut Display,
        arg2: Window,
        arg3: Window,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XActivateScreenSaver(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAddHost(arg1: *mut Display, arg2: *mut XHostAddress) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAddHosts(
        arg1: *mut Display,
        arg2: *mut XHostAddress,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAddToExtensionList(
        arg1: *mut *mut _XExtData,
        arg2: *mut XExtData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAddToSaveSet(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAllocColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *mut XColor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAllocColorCells(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_ulong,
        arg5: ::std::os::raw::c_uint,
        arg6: *mut ::std::os::raw::c_ulong,
        arg7: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAllocColorPlanes(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_ulong,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
        arg8: ::std::os::raw::c_int,
        arg9: *mut ::std::os::raw::c_ulong,
        arg10: *mut ::std::os::raw::c_ulong,
        arg11: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAllocNamedColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut XColor,
        arg5: *mut XColor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAllowEvents(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: Time,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAutoRepeatOff(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAutoRepeatOn(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XBell(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XBitmapBitOrder(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XBitmapPad(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XBitmapUnit(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCellsOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XChangeActivePointerGrab(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_uint,
        arg3: Cursor,
        arg4: Time,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XChangeGC(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_ulong,
        arg4: *mut XGCValues,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XChangeKeyboardControl(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut XKeyboardControl,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XChangeKeyboardMapping(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut KeySym,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XChangePointerControl(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XChangeProperty(
        arg1: *mut Display,
        arg2: Window,
        arg3: Atom,
        arg4: Atom,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: *const ::std::os::raw::c_uchar,
        arg8: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XChangeSaveSet(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XChangeWindowAttributes(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_ulong,
        arg4: *mut XSetWindowAttributes,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCheckIfEvent(
        arg1: *mut Display,
        arg2: *mut XEvent,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Display,
                arg2: *mut XEvent,
                arg3: XPointer,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: XPointer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCheckMaskEvent(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_long,
        arg3: *mut XEvent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCheckTypedEvent(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: *mut XEvent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCheckTypedWindowEvent(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: *mut XEvent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCheckWindowEvent(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_long,
        arg4: *mut XEvent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCirculateSubwindows(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCirculateSubwindowsDown(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCirculateSubwindowsUp(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XClearArea(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_uint,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XClearWindow(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCloseDisplay(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XConfigureWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_uint,
        arg4: *mut XWindowChanges,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XConnectionNumber(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XConvertSelection(
        arg1: *mut Display,
        arg2: Atom,
        arg3: Atom,
        arg4: Atom,
        arg5: Window,
        arg6: Time,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCopyArea(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: Drawable,
        arg4: GC,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_uint,
        arg9: ::std::os::raw::c_int,
        arg10: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCopyGC(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_ulong,
        arg4: GC,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCopyPlane(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: Drawable,
        arg4: GC,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_uint,
        arg9: ::std::os::raw::c_int,
        arg10: ::std::os::raw::c_int,
        arg11: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDefaultDepth(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDefaultDepthOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDefaultScreen(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDefineCursor(arg1: *mut Display, arg2: Window, arg3: Cursor) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDeleteProperty(arg1: *mut Display, arg2: Window, arg3: Atom) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDestroyWindow(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDestroySubwindows(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDoesBackingStore(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDoesSaveUnders(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDisableAccessControl(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDisplayCells(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDisplayHeight(arg1: *mut Display, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDisplayHeightMM(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDisplayKeycodes(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDisplayPlanes(arg1: *mut Display, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDisplayWidth(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDisplayWidthMM(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawArc(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_int,
        arg9: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawArcs(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XArc,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawImageString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *const ::std::os::raw::c_char,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawImageString16(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *const XChar2b,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawLine(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawLines(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XPoint,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawPoint(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawPoints(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XPoint,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawRectangle(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawRectangles(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XRectangle,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawSegments(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XSegment,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *const ::std::os::raw::c_char,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawString16(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *const XChar2b,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawText(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *mut XTextItem,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawText16(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *mut XTextItem16,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XEnableAccessControl(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XEventsQueued(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFetchName(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFillArc(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_int,
        arg9: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFillArcs(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XArc,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFillPolygon(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XPoint,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFillRectangle(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFillRectangles(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XRectangle,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFlush(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XForceScreenSaver(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFree(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeColormap(arg1: *mut Display, arg2: Colormap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeColors(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *mut ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeCursor(arg1: *mut Display, arg2: Cursor) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeExtensionList(arg1: *mut *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeFont(arg1: *mut Display, arg2: *mut XFontStruct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeFontInfo(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut XFontStruct,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeFontNames(arg1: *mut *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeFontPath(arg1: *mut *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeGC(arg1: *mut Display, arg2: GC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeModifiermap(arg1: *mut XModifierKeymap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreePixmap(arg1: *mut Display, arg2: Pixmap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGeometry(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_int,
        arg9: ::std::os::raw::c_int,
        arg10: *mut ::std::os::raw::c_int,
        arg11: *mut ::std::os::raw::c_int,
        arg12: *mut ::std::os::raw::c_int,
        arg13: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetErrorDatabaseText(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut ::std::os::raw::c_char,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetErrorText(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetFontProperty(
        arg1: *mut XFontStruct,
        arg2: Atom,
        arg3: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetGCValues(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_ulong,
        arg4: *mut XGCValues,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetGeometry(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: *mut Window,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_uint,
        arg7: *mut ::std::os::raw::c_uint,
        arg8: *mut ::std::os::raw::c_uint,
        arg9: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetIconName(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetInputFocus(
        arg1: *mut Display,
        arg2: *mut Window,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetKeyboardControl(
        arg1: *mut Display,
        arg2: *mut XKeyboardState,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetPointerControl(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetPointerMapping(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetScreenSaver(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetTransientForHint(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Window,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetWindowProperty(
        arg1: *mut Display,
        arg2: Window,
        arg3: Atom,
        arg4: ::std::os::raw::c_long,
        arg5: ::std::os::raw::c_long,
        arg6: ::std::os::raw::c_int,
        arg7: Atom,
        arg8: *mut Atom,
        arg9: *mut ::std::os::raw::c_int,
        arg10: *mut ::std::os::raw::c_ulong,
        arg11: *mut ::std::os::raw::c_ulong,
        arg12: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetWindowAttributes(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut XWindowAttributes,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGrabButton(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_uint,
        arg3: ::std::os::raw::c_uint,
        arg4: Window,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_int,
        arg8: ::std::os::raw::c_int,
        arg9: Window,
        arg10: Cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGrabKey(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_uint,
        arg4: Window,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGrabKeyboard(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: Time,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGrabPointer(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: Window,
        arg8: Cursor,
        arg9: Time,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGrabServer(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XHeightMMOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XHeightOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XIfEvent(
        arg1: *mut Display,
        arg2: *mut XEvent,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Display,
                arg2: *mut XEvent,
                arg3: XPointer,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: XPointer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XImageByteOrder(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XInstallColormap(arg1: *mut Display, arg2: Colormap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XKeysymToKeycode(arg1: *mut Display, arg2: KeySym) -> KeyCode;
}
extern "C" {
    pub fn XKillClient(arg1: *mut Display, arg2: XID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XLookupColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut XColor,
        arg5: *mut XColor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XLowerWindow(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XMapRaised(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XMapSubwindows(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XMapWindow(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XMaskEvent(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_long,
        arg3: *mut XEvent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XMaxCmapsOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XMinCmapsOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XMoveResizeWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_uint,
        arg6: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XMoveWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XNextEvent(arg1: *mut Display, arg2: *mut XEvent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XNoOp(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XParseColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut XColor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XParseGeometry(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_uint,
        arg5: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XPeekEvent(arg1: *mut Display, arg2: *mut XEvent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XPeekIfEvent(
        arg1: *mut Display,
        arg2: *mut XEvent,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Display,
                arg2: *mut XEvent,
                arg3: XPointer,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: XPointer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XPending(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XPlanesOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XProtocolRevision(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XProtocolVersion(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XPutBackEvent(arg1: *mut Display, arg2: *mut XEvent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XPutImage(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XImage,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
        arg8: ::std::os::raw::c_int,
        arg9: ::std::os::raw::c_uint,
        arg10: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQLength(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryBestCursor(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: ::std::os::raw::c_uint,
        arg4: ::std::os::raw::c_uint,
        arg5: *mut ::std::os::raw::c_uint,
        arg6: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryBestSize(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: Drawable,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
        arg6: *mut ::std::os::raw::c_uint,
        arg7: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryBestStipple(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: ::std::os::raw::c_uint,
        arg4: ::std::os::raw::c_uint,
        arg5: *mut ::std::os::raw::c_uint,
        arg6: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryBestTile(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: ::std::os::raw::c_uint,
        arg4: ::std::os::raw::c_uint,
        arg5: *mut ::std::os::raw::c_uint,
        arg6: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *mut XColor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryColors(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *mut XColor,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryExtension(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryKeymap(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryPointer(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Window,
        arg4: *mut Window,
        arg5: *mut ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_int,
        arg7: *mut ::std::os::raw::c_int,
        arg8: *mut ::std::os::raw::c_int,
        arg9: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryTextExtents(
        arg1: *mut Display,
        arg2: XID,
        arg3: *const ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_int,
        arg7: *mut ::std::os::raw::c_int,
        arg8: *mut XCharStruct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryTextExtents16(
        arg1: *mut Display,
        arg2: XID,
        arg3: *const XChar2b,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_int,
        arg7: *mut ::std::os::raw::c_int,
        arg8: *mut XCharStruct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryTree(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Window,
        arg4: *mut Window,
        arg5: *mut *mut Window,
        arg6: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRaiseWindow(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XReadBitmapFile(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_uint,
        arg5: *mut ::std::os::raw::c_uint,
        arg6: *mut Pixmap,
        arg7: *mut ::std::os::raw::c_int,
        arg8: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XReadBitmapFileData(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_uint,
        arg3: *mut ::std::os::raw::c_uint,
        arg4: *mut *mut ::std::os::raw::c_uchar,
        arg5: *mut ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRebindKeysym(
        arg1: *mut Display,
        arg2: KeySym,
        arg3: *mut KeySym,
        arg4: ::std::os::raw::c_int,
        arg5: *const ::std::os::raw::c_uchar,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRecolorCursor(
        arg1: *mut Display,
        arg2: Cursor,
        arg3: *mut XColor,
        arg4: *mut XColor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRefreshKeyboardMapping(arg1: *mut XMappingEvent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRemoveFromSaveSet(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRemoveHost(arg1: *mut Display, arg2: *mut XHostAddress) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRemoveHosts(
        arg1: *mut Display,
        arg2: *mut XHostAddress,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XReparentWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: Window,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XResetScreenSaver(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XResizeWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_uint,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRestackWindows(
        arg1: *mut Display,
        arg2: *mut Window,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRotateBuffers(arg1: *mut Display, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRotateWindowProperties(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Atom,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XScreenCount(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSelectInput(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSendEvent(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_long,
        arg5: *mut XEvent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetAccessControl(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetArcMode(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetBackground(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetClipMask(arg1: *mut Display, arg2: GC, arg3: Pixmap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetClipOrigin(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetClipRectangles(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut XRectangle,
        arg6: ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetCloseDownMode(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetCommand(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetDashes(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetFillRule(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetFillStyle(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetFont(arg1: *mut Display, arg2: GC, arg3: Font) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetFontPath(
        arg1: *mut Display,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetForeground(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetFunction(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetGraphicsExposures(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetIconName(
        arg1: *mut Display,
        arg2: Window,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetInputFocus(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: Time,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetLineAttributes(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_uint,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetModifierMapping(
        arg1: *mut Display,
        arg2: *mut XModifierKeymap,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetPlaneMask(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetPointerMapping(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_uchar,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetScreenSaver(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetSelectionOwner(
        arg1: *mut Display,
        arg2: Atom,
        arg3: Window,
        arg4: Time,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetState(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_ulong,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetStipple(arg1: *mut Display, arg2: GC, arg3: Pixmap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetSubwindowMode(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetTSOrigin(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetTile(arg1: *mut Display, arg2: GC, arg3: Pixmap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetWindowBackground(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetWindowBackgroundPixmap(
        arg1: *mut Display,
        arg2: Window,
        arg3: Pixmap,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetWindowBorder(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetWindowBorderPixmap(
        arg1: *mut Display,
        arg2: Window,
        arg3: Pixmap,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetWindowBorderWidth(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetWindowColormap(
        arg1: *mut Display,
        arg2: Window,
        arg3: Colormap,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XStoreBuffer(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XStoreBytes(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XStoreColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *mut XColor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XStoreColors(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *mut XColor,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XStoreName(
        arg1: *mut Display,
        arg2: Window,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XStoreNamedColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *const ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_ulong,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSync(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XTextExtents(
        arg1: *mut XFontStruct,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_int,
        arg7: *mut XCharStruct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XTextExtents16(
        arg1: *mut XFontStruct,
        arg2: *const XChar2b,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_int,
        arg7: *mut XCharStruct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XTextWidth(
        arg1: *mut XFontStruct,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XTextWidth16(
        arg1: *mut XFontStruct,
        arg2: *const XChar2b,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XTranslateCoordinates(
        arg1: *mut Display,
        arg2: Window,
        arg3: Window,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_int,
        arg7: *mut ::std::os::raw::c_int,
        arg8: *mut Window,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUndefineCursor(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUngrabButton(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_uint,
        arg3: ::std::os::raw::c_uint,
        arg4: Window,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUngrabKey(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_uint,
        arg4: Window,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUngrabKeyboard(arg1: *mut Display, arg2: Time) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUngrabPointer(arg1: *mut Display, arg2: Time) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUngrabServer(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUninstallColormap(arg1: *mut Display, arg2: Colormap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUnloadFont(arg1: *mut Display, arg2: Font) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUnmapSubwindows(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUnmapWindow(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XVendorRelease(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XWarpPointer(
        arg1: *mut Display,
        arg2: Window,
        arg3: Window,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_int,
        arg9: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XWidthMMOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XWidthOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XWindowEvent(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_long,
        arg4: *mut XEvent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XWriteBitmapFile(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
        arg3: Pixmap,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
        arg6: ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSupportsLocale() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetLocaleModifiers(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XOpenOM(
        arg1: *mut Display,
        arg2: *mut _XrmHashBucketRec,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> XOM;
}
extern "C" {
    pub fn XCloseOM(arg1: XOM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetOMValues(arg1: XOM, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XGetOMValues(arg1: XOM, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XDisplayOfOM(arg1: XOM) -> *mut Display;
}
extern "C" {
    pub fn XLocaleOfOM(arg1: XOM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XCreateOC(arg1: XOM, ...) -> XOC;
}
extern "C" {
    pub fn XDestroyOC(arg1: XOC);
}
extern "C" {
    pub fn XOMOfOC(arg1: XOC) -> XOM;
}
extern "C" {
    pub fn XSetOCValues(arg1: XOC, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XGetOCValues(arg1: XOC, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XCreateFontSet(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut *mut ::std::os::raw::c_char,
    ) -> XFontSet;
}
extern "C" {
    pub fn XFreeFontSet(arg1: *mut Display, arg2: XFontSet);
}
extern "C" {
    pub fn XFontsOfFontSet(
        arg1: XFontSet,
        arg2: *mut *mut *mut XFontStruct,
        arg3: *mut *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XBaseFontNameListOfFontSet(arg1: XFontSet) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XLocaleOfFontSet(arg1: XFontSet) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XContextDependentDrawing(arg1: XFontSet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDirectionalDependentDrawing(arg1: XFontSet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XContextualDrawing(arg1: XFontSet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XExtentsOfFontSet(arg1: XFontSet) -> *mut XFontSetExtents;
}
extern "C" {
    pub fn XmbTextEscapement(
        arg1: XFontSet,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XwcTextEscapement(
        arg1: XFontSet,
        arg2: *const wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Xutf8TextEscapement(
        arg1: XFontSet,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XmbTextExtents(
        arg1: XFontSet,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XwcTextExtents(
        arg1: XFontSet,
        arg2: *const wchar_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Xutf8TextExtents(
        arg1: XFontSet,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XmbTextPerCharExtents(
        arg1: XFontSet,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
        arg6: ::std::os::raw::c_int,
        arg7: *mut ::std::os::raw::c_int,
        arg8: *mut XRectangle,
        arg9: *mut XRectangle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XwcTextPerCharExtents(
        arg1: XFontSet,
        arg2: *const wchar_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
        arg6: ::std::os::raw::c_int,
        arg7: *mut ::std::os::raw::c_int,
        arg8: *mut XRectangle,
        arg9: *mut XRectangle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Xutf8TextPerCharExtents(
        arg1: XFontSet,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
        arg6: ::std::os::raw::c_int,
        arg7: *mut ::std::os::raw::c_int,
        arg8: *mut XRectangle,
        arg9: *mut XRectangle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XmbDrawText(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *mut XmbTextItem,
        arg7: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn XwcDrawText(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *mut XwcTextItem,
        arg7: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Xutf8DrawText(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *mut XmbTextItem,
        arg7: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn XmbDrawString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: *const ::std::os::raw::c_char,
        arg8: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn XwcDrawString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: *const wchar_t,
        arg8: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Xutf8DrawString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: *const ::std::os::raw::c_char,
        arg8: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn XmbDrawImageString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: *const ::std::os::raw::c_char,
        arg8: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn XwcDrawImageString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: *const wchar_t,
        arg8: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Xutf8DrawImageString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: *const ::std::os::raw::c_char,
        arg8: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn XOpenIM(
        arg1: *mut Display,
        arg2: *mut _XrmHashBucketRec,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
    ) -> XIM;
}
extern "C" {
    pub fn XCloseIM(arg1: XIM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetIMValues(arg1: XIM, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XSetIMValues(arg1: XIM, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XDisplayOfIM(arg1: XIM) -> *mut Display;
}
extern "C" {
    pub fn XLocaleOfIM(arg1: XIM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XCreateIC(arg1: XIM, ...) -> XIC;
}
extern "C" {
    pub fn XDestroyIC(arg1: XIC);
}
extern "C" {
    pub fn XSetICFocus(arg1: XIC);
}
extern "C" {
    pub fn XUnsetICFocus(arg1: XIC);
}
extern "C" {
    pub fn XwcResetIC(arg1: XIC) -> *mut wchar_t;
}
extern "C" {
    pub fn XmbResetIC(arg1: XIC) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Xutf8ResetIC(arg1: XIC) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XSetICValues(arg1: XIC, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XGetICValues(arg1: XIC, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XIMOfIC(arg1: XIC) -> XIM;
}
extern "C" {
    pub fn XFilterEvent(arg1: *mut XEvent, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XmbLookupString(
        arg1: XIC,
        arg2: *mut XKeyPressedEvent,
        arg3: *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
        arg5: *mut KeySym,
        arg6: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XwcLookupString(
        arg1: XIC,
        arg2: *mut XKeyPressedEvent,
        arg3: *mut wchar_t,
        arg4: ::std::os::raw::c_int,
        arg5: *mut KeySym,
        arg6: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Xutf8LookupString(
        arg1: XIC,
        arg2: *mut XKeyPressedEvent,
        arg3: *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
        arg5: *mut KeySym,
        arg6: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XVaCreateNestedList(arg1: ::std::os::raw::c_int, ...) -> XVaNestedList;
}
extern "C" {
    pub fn XRegisterIMInstantiateCallback(
        arg1: *mut Display,
        arg2: *mut _XrmHashBucketRec,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
        arg5: XIDProc,
        arg6: XPointer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUnregisterIMInstantiateCallback(
        arg1: *mut Display,
        arg2: *mut _XrmHashBucketRec,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
        arg5: XIDProc,
        arg6: XPointer,
    ) -> ::std::os::raw::c_int;
}
pub type XConnectionWatchProc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut Display,
        arg2: XPointer,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut XPointer,
    ),
>;
extern "C" {
    pub fn XInternalConnectionNumbers(
        arg1: *mut Display,
        arg2: *mut *mut ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XProcessInternalConnection(arg1: *mut Display, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn XAddConnectionWatch(
        arg1: *mut Display,
        arg2: XConnectionWatchProc,
        arg3: XPointer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRemoveConnectionWatch(arg1: *mut Display, arg2: XConnectionWatchProc, arg3: XPointer);
}
extern "C" {
    pub fn XSetAuthorization(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn _Xmbtowc(
        arg1: *mut wchar_t,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Xwctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetEventData(
        arg1: *mut Display,
        arg2: *mut XGenericEventCookie,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeEventData(arg1: *mut Display, arg2: *mut XGenericEventCookie);
}
#[repr(u32)]
///  These are the various supported windowing subsystems
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_SYSWM_TYPE {
    SDL_SYSWM_UNKNOWN = 0,
    SDL_SYSWM_WINDOWS = 1,
    SDL_SYSWM_X11 = 2,
    SDL_SYSWM_DIRECTFB = 3,
    SDL_SYSWM_COCOA = 4,
    SDL_SYSWM_UIKIT = 5,
    SDL_SYSWM_WAYLAND = 6,
    SDL_SYSWM_MIR = 7,
}
///  The custom event structure.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMmsg {
    pub version: SDL_version,
    pub subsystem: SDL_SYSWM_TYPE,
    pub msg: SDL_SysWMmsg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_SysWMmsg__bindgen_ty_1 {
    pub x11: SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1,
    pub dummy: ::std::os::raw::c_int,
    _bindgen_union_align: [u64; 24usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1 {
    pub event: XEvent,
}
#[test]
fn bindgen_test_layout_SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1>(),
        192usize,
        concat!(
            "Size of: ",
            stringify!(SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_SysWMmsg__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SDL_SysWMmsg__bindgen_ty_1>(),
        192usize,
        concat!("Size of: ", stringify!(SDL_SysWMmsg__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_SysWMmsg__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_SysWMmsg__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout_SDL_SysWMmsg() {
    assert_eq!(
        ::std::mem::size_of::<SDL_SysWMmsg>(),
        200usize,
        concat!("Size of: ", stringify!(SDL_SysWMmsg))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_SysWMmsg>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_SysWMmsg))
    );
}
///  The custom window manager information structure.
///
///  When this structure is returned, it holds information about which
///  low level system it is using, and will be one of SDL_SYSWM_TYPE.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMinfo {
    pub version: SDL_version,
    pub subsystem: SDL_SYSWM_TYPE,
    pub info: SDL_SysWMinfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_SysWMinfo__bindgen_ty_1 {
    pub x11: SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1,
    pub wl: SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2,
    pub dummy: ::std::os::raw::c_int,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1 {
    ///< The X11 display
    pub display: *mut Display,
    ///< The X11 window
    pub window: Window,
}
#[test]
fn bindgen_test_layout_SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2 {
    ///< Wayland display
    pub display: *mut wl_display,
    ///< Wayland surface
    pub surface: *mut wl_surface,
    ///< Wayland shell_surface (window manager handle)
    pub shell_surface: *mut wl_shell_surface,
}
#[test]
fn bindgen_test_layout_SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_SysWMinfo__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SDL_SysWMinfo__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_SysWMinfo__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_SysWMinfo__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_SysWMinfo__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout_SDL_SysWMinfo() {
    assert_eq!(
        ::std::mem::size_of::<SDL_SysWMinfo>(),
        32usize,
        concat!("Size of: ", stringify!(SDL_SysWMinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<SDL_SysWMinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_SysWMinfo))
    );
}
extern "C" {
    ///  \brief This function allows access to driver-dependent window information.
    ///
    ///  \param window The window about which information is being requested
    ///  \param info This structure must be initialized with the SDL version, and is
    ///              then filled in with information about the given window.
    ///
    ///  \return SDL_TRUE if the function is implemented and the version member of
    ///          the \c info struct is valid, SDL_FALSE otherwise.
    ///
    ///  You typically use this function like this:
    ///  \code
    ///  SDL_SysWMinfo info;
    ///  SDL_VERSION(&info.version);
    ///  if ( SDL_GetWindowWMInfo(window, &info) ) { ... }
    ///  \endcode
    pub fn SDL_GetWindowWMInfo(window: *mut SDL_Window, info: *mut SDL_SysWMinfo) -> SDL_bool;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
///< Private
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_BlitMap {
    pub _address: u8,
}
///< Wayland display
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wl_display {
    pub _address: u8,
}
///< Wayland surface
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wl_surface {
    pub _address: u8,
}
///< Wayland shell_surface (window manager handle)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wl_shell_surface {
    pub _address: u8,
}
